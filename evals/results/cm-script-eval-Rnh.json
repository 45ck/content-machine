{
  "evalId": "eval-Rnh-2026-01-10T08:40:08",
  "results": {
    "version": 3,
    "timestamp": "2026-01-10T08:40:08.298Z",
    "prompts": [
      {
        "raw": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"{{ topic }}\"\n\nFORMAT: {{ archetype }}\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Use short sentences (<=15 words) and one idea per sentence.\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n\n{% if archetype == \"listicle\" %}\nStructure as a numbered list with a hook, clear items, and a call-to-action.\n{% endif %}\n{% if archetype == \"versus\" %}\nPresent a balanced comparison with a clear recommendation at the end.\n{% endif %}\n{% if archetype == \"howto\" %}\nGive step-by-step instructions that are easy to follow.\n{% endif %}\n{% if archetype == \"myth\" %}\nStart with the myth, then reveal the reality with evidence.\n{% endif %}\n{% if archetype == \"story\" %}\nUse narrative structure: setup, conflict, resolution.\n{% endif %}\n{% if archetype == \"hot-take\" %}\nLead with a provocative opinion, then back it up with reasoning.\n{% endif %}\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n",
        "label": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"{{ topic }}\"\n\nFORMAT: {{ archetype }}\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Use short sentences (<=15 words) and one idea per sentence.\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n\n{% if archetype == \"listicle\" %}\nStructure as a numbered list with a hook, clear items, and a call-to-action.\n{% endif %}\n{% if archetype == \"versus\" %}\nPresent a balanced comparison with a clear recommendation at the end.\n{% endif %}\n{% if archetype == \"howto\" %}\nGive step-by-step instructions that are easy to follow.\n{% endif %}\n{% if archetype == \"myth\" %}\nStart with the myth, then reveal the reality with evidence.\n{% endif %}\n{% if archetype == \"story\" %}\nUse narrative structure: setup, conflict, resolution.\n{% endif %}\n{% if archetype == \"hot-take\" %}\nLead with a provocative opinion, then back it up with reasoning.\n{% endif %}\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n",
        "id": "a3df67e6ef678c5736d74fe2db715f65a7b49b042e23a17fda9e6b7bcc746265",
        "provider": "openai:gpt-4o",
        "metrics": {
          "score": 5.137362637362638,
          "testPassCount": 0,
          "testFailCount": 6,
          "testErrorCount": 0,
          "assertPassCount": 42,
          "assertFailCount": 9,
          "totalLatencyMs": 35211,
          "tokenUsage": {
            "prompt": 2309,
            "completion": 2386,
            "cached": 0,
            "total": 4695,
            "numRequests": 6,
            "completionDetails": {
              "reasoning": 0,
              "acceptedPrediction": 0,
              "rejectedPrediction": 0
            },
            "assertions": {
              "total": 8676,
              "prompt": 7917,
              "completion": 759,
              "cached": 0,
              "numRequests": 0,
              "completionDetails": {
                "reasoning": 0,
                "acceptedPrediction": 0,
                "rejectedPrediction": 0
              }
            }
          },
          "namedScores": {},
          "namedScoresCount": {},
          "cost": 0.0296325
        }
      }
    ],
    "results": [
      {
        "cost": 0.0050775,
        "error": "Custom function returned false\ntry {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 80 && wordCount <= 200;\n} catch { return false; }",
        "gradingResult": {
          "pass": false,
          "score": 0.9285714285714286,
          "reason": "Custom function returned false\ntry {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 80 && wordCount <= 200;\n} catch { return false; }",
          "namedScores": {},
          "tokensUsed": {
            "total": 2442,
            "prompt": 2219,
            "completion": 223,
            "cached": 0,
            "numRequests": 4
          },
          "componentResults": [
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return (\n    Array.isArray(script.scenes) &&\n    script.scenes.length >= 3 &&\n    script.scenes.length <= 7\n  );\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": false,
              "score": 0,
              "reason": "Custom function returned false\ntry {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 80 && wordCount <= 200;\n} catch { return false; }",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 80 && wordCount <= 200;\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return (script.scenes || []).every((scene) =>\n    typeof scene.visualDirection === 'string' && scene.visualDirection.trim().length > 5\n  );\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean)\n    .join(' ');\n  const hasEmoji = /\\p{Extended_Pictographic}/u.test(spoken);\n  const hasMarkdown = /[`*_]/.test(spoken) || /\\[(.+?)\\]\\((.+?)\\)/.test(spoken);\n  const hasHashtag = /(^|\\s)#\\w+/.test(spoken);\n  return !hasEmoji && !hasMarkdown && !hasHashtag;\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return typeof script.reasoning === 'string' && script.reasoning.trim().length > 10;\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "The script opens with an attention-grabbing hook that would stop a TikTok user from scrolling.\nThe first sentence should be surprising, controversial, or promise immediate value.\nScore 0 if it's a generic introduction like \"In this video...\" or \"Today we'll cover...\".\n",
                "threshold": 0.7,
                "weight": 2
              },
              "pass": true,
              "score": 1,
              "reason": "The hook 'Want to code like a JavaScript pro? Here are 5 tips you need!' grabs attention by promising immediate value and suggesting improvement in coding skills.",
              "tokensUsed": {
                "total": 614,
                "prompt": 564,
                "completion": 50,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"Number one, use 'let' and 'const' instead of 'var'. Keeps your code cleaner.\\\",\\\"visualDirection\\\":\\\"Show code snippet with 'var', then switch to 'let' and 'const'.\\\",\\\"mood\\\":\\\"Informative and upbeat.\\\"},{\\\"text\\\":\\\"Tip two, arrow functions make your code shorter and sweeter.\\\",\\\"visualDirection\\\":\\\"Display a long function, then transform it into an arrow function.\\\",\\\"mood\\\":\\\"Satisfying and engaging.\\\"},{\\\"text\\\":\\\"Three, use template literals for easy string interpolation.\\\",\\\"visualDirection\\\":\\\"Show a complex string concatenation, then simplify with backticks.\\\",\\\"mood\\\":\\\"Clear and enlightening.\\\"},{\\\"text\\\":\\\"Four, destructuring assignment helps you extract values easily.\\\",\\\"visualDirection\\\":\\\"Animate extracting values from an object using destructuring.\\\",\\\"mood\\\":\\\"Smooth and enlightening.\\\"},{\\\"text\\\":\\\"Finally, use 'map' and 'filter' to work with arrays efficiently.\\\",\\\"visualDirection\\\":\\\"Show a loop, then replace it with 'map' and 'filter'.\\\",\\\"mood\\\":\\\"Efficient and motivating.\\\"}],\\\"reasoning\\\":\\\"The video is structured as a listicle to provide quick and helpful JavaScript tips that are highly relevant to developers. Each tip is presented with a clear and concise explanation, paired with visual examples to make the content engaging and easy to understand. The call-to-action invites viewers to deepen their engagement.\\\",\\\"title\\\":\\\"5 JavaScript Tips Every Developer Should Know\\\",\\\"hook\\\":\\\"Want to code like a JavaScript pro? Here are 5 tips you need!\\\",\\\"cta\\\":\\\"Follow for more coding tips and tricks!\\\",\\\"hashtags\\\":[\\\"#JavaScript\\\",\\\"#CodingTips\\\",\\\"#WebDevelopment\\\"]}\\n</Output>\\n<Rubric>\\nThe script opens with an attention-grabbing hook that would stop a TikTok user from scrolling.\\nThe first sentence should be surprising, controversial, or promise immediate value.\\nScore 0 if it's a generic introduction like \\\"In this video...\\\" or \\\"Today we'll cover...\\\".\\n\\n</Rubric>\"}]"
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "The language is casual, conversational, and suitable for TikTok/Reels/Shorts.\nNo corporate jargon, no formal academic language, no \"as a developer\" phrases.\nShould sound like a friend giving advice, not a textbook.\n",
                "threshold": 0.8,
                "weight": 1
              },
              "pass": true,
              "score": 1,
              "reason": "The language used is casual and engaging, suitable for a TikTok/Reels/Shorts format. Phrases like 'Want to code like a JavaScript pro?' and 'Here are 5 tips you need!' sound conversational and friendly.",
              "tokensUsed": {
                "total": 622,
                "prompt": 557,
                "completion": 65,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"Number one, use 'let' and 'const' instead of 'var'. Keeps your code cleaner.\\\",\\\"visualDirection\\\":\\\"Show code snippet with 'var', then switch to 'let' and 'const'.\\\",\\\"mood\\\":\\\"Informative and upbeat.\\\"},{\\\"text\\\":\\\"Tip two, arrow functions make your code shorter and sweeter.\\\",\\\"visualDirection\\\":\\\"Display a long function, then transform it into an arrow function.\\\",\\\"mood\\\":\\\"Satisfying and engaging.\\\"},{\\\"text\\\":\\\"Three, use template literals for easy string interpolation.\\\",\\\"visualDirection\\\":\\\"Show a complex string concatenation, then simplify with backticks.\\\",\\\"mood\\\":\\\"Clear and enlightening.\\\"},{\\\"text\\\":\\\"Four, destructuring assignment helps you extract values easily.\\\",\\\"visualDirection\\\":\\\"Animate extracting values from an object using destructuring.\\\",\\\"mood\\\":\\\"Smooth and enlightening.\\\"},{\\\"text\\\":\\\"Finally, use 'map' and 'filter' to work with arrays efficiently.\\\",\\\"visualDirection\\\":\\\"Show a loop, then replace it with 'map' and 'filter'.\\\",\\\"mood\\\":\\\"Efficient and motivating.\\\"}],\\\"reasoning\\\":\\\"The video is structured as a listicle to provide quick and helpful JavaScript tips that are highly relevant to developers. Each tip is presented with a clear and concise explanation, paired with visual examples to make the content engaging and easy to understand. The call-to-action invites viewers to deepen their engagement.\\\",\\\"title\\\":\\\"5 JavaScript Tips Every Developer Should Know\\\",\\\"hook\\\":\\\"Want to code like a JavaScript pro? Here are 5 tips you need!\\\",\\\"cta\\\":\\\"Follow for more coding tips and tricks!\\\",\\\"hashtags\\\":[\\\"#JavaScript\\\",\\\"#CodingTips\\\",\\\"#WebDevelopment\\\"]}\\n</Output>\\n<Rubric>\\nThe language is casual, conversational, and suitable for TikTok/Reels/Shorts.\\nNo corporate jargon, no formal academic language, no \\\"as a developer\\\" phrases.\\nShould sound like a friend giving advice, not a textbook.\\n\\n</Rubric>\"}]"
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "Each scene has a specific, filmable visual description.\nVisual directions should describe what the viewer will SEE on screen.\nAvoid abstract concepts that cannot be filmed (like \"efficiency\" or \"code quality\").\n",
                "threshold": 0.8,
                "weight": 1
              },
              "pass": true,
              "score": 1,
              "reason": "Each scene includes specific visual directions that describe concrete actions or transformations on screen, such as showing code snippets and animations that can be filmed. Abstract concepts are avoided, focusing instead on clear visual representations.",
              "tokensUsed": {
                "total": 603,
                "prompt": 551,
                "completion": 52,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"Number one, use 'let' and 'const' instead of 'var'. Keeps your code cleaner.\\\",\\\"visualDirection\\\":\\\"Show code snippet with 'var', then switch to 'let' and 'const'.\\\",\\\"mood\\\":\\\"Informative and upbeat.\\\"},{\\\"text\\\":\\\"Tip two, arrow functions make your code shorter and sweeter.\\\",\\\"visualDirection\\\":\\\"Display a long function, then transform it into an arrow function.\\\",\\\"mood\\\":\\\"Satisfying and engaging.\\\"},{\\\"text\\\":\\\"Three, use template literals for easy string interpolation.\\\",\\\"visualDirection\\\":\\\"Show a complex string concatenation, then simplify with backticks.\\\",\\\"mood\\\":\\\"Clear and enlightening.\\\"},{\\\"text\\\":\\\"Four, destructuring assignment helps you extract values easily.\\\",\\\"visualDirection\\\":\\\"Animate extracting values from an object using destructuring.\\\",\\\"mood\\\":\\\"Smooth and enlightening.\\\"},{\\\"text\\\":\\\"Finally, use 'map' and 'filter' to work with arrays efficiently.\\\",\\\"visualDirection\\\":\\\"Show a loop, then replace it with 'map' and 'filter'.\\\",\\\"mood\\\":\\\"Efficient and motivating.\\\"}],\\\"reasoning\\\":\\\"The video is structured as a listicle to provide quick and helpful JavaScript tips that are highly relevant to developers. Each tip is presented with a clear and concise explanation, paired with visual examples to make the content engaging and easy to understand. The call-to-action invites viewers to deepen their engagement.\\\",\\\"title\\\":\\\"5 JavaScript Tips Every Developer Should Know\\\",\\\"hook\\\":\\\"Want to code like a JavaScript pro? Here are 5 tips you need!\\\",\\\"cta\\\":\\\"Follow for more coding tips and tricks!\\\",\\\"hashtags\\\":[\\\"#JavaScript\\\",\\\"#CodingTips\\\",\\\"#WebDevelopment\\\"]}\\n</Output>\\n<Rubric>\\nEach scene has a specific, filmable visual description.\\nVisual directions should describe what the viewer will SEE on screen.\\nAvoid abstract concepts that cannot be filmed (like \\\"efficiency\\\" or \\\"code quality\\\").\\n\\n</Rubric>\"}]"
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "For a listicle archetype, the script should have a clear numbered structure.\nEach tip should be distinct and actionable.\nThe list should feel complete, not like it was cut off.\n",
                "threshold": 0.8,
                "weight": 1
              },
              "pass": true,
              "score": 1,
              "reason": "The output contains a clear numbered structure, with five distinct and actionable tips related to JavaScript. The final tip indicates completion of the list, giving the impression that the list is not cut off.",
              "tokensUsed": {
                "total": 603,
                "prompt": 547,
                "completion": 56,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"Number one, use 'let' and 'const' instead of 'var'. Keeps your code cleaner.\\\",\\\"visualDirection\\\":\\\"Show code snippet with 'var', then switch to 'let' and 'const'.\\\",\\\"mood\\\":\\\"Informative and upbeat.\\\"},{\\\"text\\\":\\\"Tip two, arrow functions make your code shorter and sweeter.\\\",\\\"visualDirection\\\":\\\"Display a long function, then transform it into an arrow function.\\\",\\\"mood\\\":\\\"Satisfying and engaging.\\\"},{\\\"text\\\":\\\"Three, use template literals for easy string interpolation.\\\",\\\"visualDirection\\\":\\\"Show a complex string concatenation, then simplify with backticks.\\\",\\\"mood\\\":\\\"Clear and enlightening.\\\"},{\\\"text\\\":\\\"Four, destructuring assignment helps you extract values easily.\\\",\\\"visualDirection\\\":\\\"Animate extracting values from an object using destructuring.\\\",\\\"mood\\\":\\\"Smooth and enlightening.\\\"},{\\\"text\\\":\\\"Finally, use 'map' and 'filter' to work with arrays efficiently.\\\",\\\"visualDirection\\\":\\\"Show a loop, then replace it with 'map' and 'filter'.\\\",\\\"mood\\\":\\\"Efficient and motivating.\\\"}],\\\"reasoning\\\":\\\"The video is structured as a listicle to provide quick and helpful JavaScript tips that are highly relevant to developers. Each tip is presented with a clear and concise explanation, paired with visual examples to make the content engaging and easy to understand. The call-to-action invites viewers to deepen their engagement.\\\",\\\"title\\\":\\\"5 JavaScript Tips Every Developer Should Know\\\",\\\"hook\\\":\\\"Want to code like a JavaScript pro? Here are 5 tips you need!\\\",\\\"cta\\\":\\\"Follow for more coding tips and tricks!\\\",\\\"hashtags\\\":[\\\"#JavaScript\\\",\\\"#CodingTips\\\",\\\"#WebDevelopment\\\"]}\\n</Output>\\n<Rubric>\\nFor a listicle archetype, the script should have a clear numbered structure.\\nEach tip should be distinct and actionable.\\nThe list should feel complete, not like it was cut off.\\n\\n</Rubric>\"}]"
              }
            }
          ]
        },
        "id": "d25b6dc6-0f76-4a6f-a0d5-4896c9390c5b",
        "latencyMs": 4937,
        "namedScores": {},
        "prompt": {
          "raw": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"5 JavaScript tips every developer should know\"\n\nFORMAT: listicle\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Use short sentences (<=15 words) and one idea per sentence.\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n\n\nStructure as a numbered list with a hook, clear items, and a call-to-action.\n\n\n\n\n\n\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n",
          "label": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"{{ topic }}\"\n\nFORMAT: {{ archetype }}\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Use short sentences (<=15 words) and one idea per sentence.\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n\n{% if archetype == \"listicle\" %}\nStructure as a numbered list with a hook, clear items, and a call-to-action.\n{% endif %}\n{% if archetype == \"versus\" %}\nPresent a balanced comparison with a clear recommendation at the end.\n{% endif %}\n{% if archetype == \"howto\" %}\nGive step-by-step instructions that are easy to follow.\n{% endif %}\n{% if archetype == \"myth\" %}\nStart with the myth, then reveal the reality with evidence.\n{% endif %}\n{% if archetype == \"story\" %}\nUse narrative structure: setup, conflict, resolution.\n{% endif %}\n{% if archetype == \"hot-take\" %}\nLead with a provocative opinion, then back it up with reasoning.\n{% endif %}\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n"
        },
        "promptId": "a3df67e6ef678c5736d74fe2db715f65a7b49b042e23a17fda9e6b7bcc746265",
        "promptIdx": 0,
        "provider": {
          "id": "openai:gpt-4o",
          "label": ""
        },
        "response": {
          "output": "{\n  \"scenes\": [\n    {\n      \"text\": \"Number one, use 'let' and 'const' instead of 'var'. Keeps your code cleaner.\",\n      \"visualDirection\": \"Show code snippet with 'var', then switch to 'let' and 'const'.\",\n      \"mood\": \"Informative and upbeat.\"\n    },\n    {\n      \"text\": \"Tip two, arrow functions make your code shorter and sweeter.\",\n      \"visualDirection\": \"Display a long function, then transform it into an arrow function.\",\n      \"mood\": \"Satisfying and engaging.\"\n    },\n    {\n      \"text\": \"Three, use template literals for easy string interpolation.\",\n      \"visualDirection\": \"Show a complex string concatenation, then simplify with backticks.\",\n      \"mood\": \"Clear and enlightening.\"\n    },\n    {\n      \"text\": \"Four, destructuring assignment helps you extract values easily.\",\n      \"visualDirection\": \"Animate extracting values from an object using destructuring.\",\n      \"mood\": \"Smooth and enlightening.\"\n    },\n    {\n      \"text\": \"Finally, use 'map' and 'filter' to work with arrays efficiently.\",\n      \"visualDirection\": \"Show a loop, then replace it with 'map' and 'filter'.\",\n      \"mood\": \"Efficient and motivating.\"\n    }\n  ],\n  \"reasoning\": \"The video is structured as a listicle to provide quick and helpful JavaScript tips that are highly relevant to developers. Each tip is presented with a clear and concise explanation, paired with visual examples to make the content engaging and easy to understand. The call-to-action invites viewers to deepen their engagement.\",\n  \"title\": \"5 JavaScript Tips Every Developer Should Know\",\n  \"hook\": \"Want to code like a JavaScript pro? Here are 5 tips you need!\",\n  \"cta\": \"Follow for more coding tips and tricks!\",\n  \"hashtags\": [\"#JavaScript\", \"#CodingTips\", \"#WebDevelopment\"]\n}",
          "tokenUsage": {
            "total": 801,
            "prompt": 391,
            "completion": 410,
            "numRequests": 1,
            "completionDetails": {
              "reasoning": 0,
              "acceptedPrediction": 0,
              "rejectedPrediction": 0
            }
          },
          "cached": false,
          "latencyMs": 4937,
          "finishReason": "stop",
          "cost": 0.0050775,
          "guardrails": {
            "flagged": false
          }
        },
        "score": 0.9285714285714286,
        "success": false,
        "testCase": {
          "vars": {
            "topic": "5 JavaScript tips every developer should know",
            "archetype": "listicle"
          },
          "assert": [
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return (\n    Array.isArray(script.scenes) &&\n    script.scenes.length >= 3 &&\n    script.scenes.length <= 7\n  );\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 80 && wordCount <= 200;\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return (script.scenes || []).every((scene) =>\n    typeof scene.visualDirection === 'string' && scene.visualDirection.trim().length > 5\n  );\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean)\n    .join(' ');\n  const hasEmoji = /\\p{Extended_Pictographic}/u.test(spoken);\n  const hasMarkdown = /[`*_]/.test(spoken) || /\\[(.+?)\\]\\((.+?)\\)/.test(spoken);\n  const hasHashtag = /(^|\\s)#\\w+/.test(spoken);\n  return !hasEmoji && !hasMarkdown && !hasHashtag;\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return typeof script.reasoning === 'string' && script.reasoning.trim().length > 10;\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "llm-rubric",
              "value": "The script opens with an attention-grabbing hook that would stop a TikTok user from scrolling.\nThe first sentence should be surprising, controversial, or promise immediate value.\nScore 0 if it's a generic introduction like \"In this video...\" or \"Today we'll cover...\".\n",
              "threshold": 0.7,
              "weight": 2
            },
            {
              "type": "llm-rubric",
              "value": "The language is casual, conversational, and suitable for TikTok/Reels/Shorts.\nNo corporate jargon, no formal academic language, no \"as a developer\" phrases.\nShould sound like a friend giving advice, not a textbook.\n",
              "threshold": 0.8,
              "weight": 1
            },
            {
              "type": "llm-rubric",
              "value": "Each scene has a specific, filmable visual description.\nVisual directions should describe what the viewer will SEE on screen.\nAvoid abstract concepts that cannot be filmed (like \"efficiency\" or \"code quality\").\n",
              "threshold": 0.8,
              "weight": 1
            },
            {
              "type": "llm-rubric",
              "value": "For a listicle archetype, the script should have a clear numbered structure.\nEach tip should be distinct and actionable.\nThe list should feel complete, not like it was cut off.\n",
              "threshold": 0.8,
              "weight": 1
            }
          ],
          "options": {
            "provider": "openai:gpt-4o-mini"
          },
          "metadata": {}
        },
        "testIdx": 0,
        "vars": {
          "topic": "5 JavaScript tips every developer should know",
          "archetype": "listicle"
        },
        "metadata": {
          "_promptfooFileMetadata": {}
        },
        "failureReason": 1
      },
      {
        "cost": 0.005115000000000001,
        "error": "Custom function returned false\ntry {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }",
        "gradingResult": {
          "pass": false,
          "score": 0.7857142857142857,
          "reason": "Custom function returned false\ntry {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }",
          "namedScores": {},
          "tokensUsed": {
            "total": 1733,
            "prompt": 1592,
            "completion": 141,
            "cached": 0,
            "numRequests": 3
          },
          "componentResults": [
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return (\n    Array.isArray(script.scenes) &&\n    script.scenes.length >= 3 &&\n    script.scenes.length <= 7\n  );\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": false,
              "score": 0,
              "reason": "Custom function returned false\ntry {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 80 && wordCount <= 200;\n} catch { return false; }",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 80 && wordCount <= 200;\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return (script.scenes || []).every((scene) =>\n    typeof scene.visualDirection === 'string' && scene.visualDirection.trim().length > 5\n  );\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean)\n    .join(' ');\n  const hasEmoji = /\\p{Extended_Pictographic}/u.test(spoken);\n  const hasMarkdown = /[`*_]/.test(spoken) || /\\[(.+?)\\]\\((.+?)\\)/.test(spoken);\n  const hasHashtag = /(^|\\s)#\\w+/.test(spoken);\n  return !hasEmoji && !hasMarkdown && !hasHashtag;\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": false,
              "score": 0,
              "reason": "Custom function returned false\ntry {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return typeof script.reasoning === 'string' && script.reasoning.trim().length > 10;\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "The script opens with an attention-grabbing hook.\nFor a versus video, this might be a provocative statement like \"You're using the wrong database\"\nor a relatable problem statement.\n",
                "threshold": 0.7,
                "weight": 2
              },
              "pass": true,
              "score": 1,
              "reason": "The script opens with the line 'Redis or PostgreSQL for caching? Let's break it down.', which is a clear hook that invites the audience to explore the topic.",
              "tokensUsed": {
                "total": 584,
                "prompt": 534,
                "completion": 50,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"Redis or PostgreSQL for caching? Let's break it down.\\\",\\\"visualDirection\\\":\\\"Split screen with Redis and PostgreSQL logos.\\\",\\\"mood\\\":\\\"Curious and engaging\\\"},{\\\"text\\\":\\\"Redis is lightning fast. It's an in-memory data store.\\\",\\\"visualDirection\\\":\\\"Fast-paced animation showing a rocket blasting off.\\\",\\\"mood\\\":\\\"Energetic\\\"},{\\\"text\\\":\\\"PostgreSQL offers more complex queries. Great for relational data.\\\",\\\"visualDirection\\\":\\\"Database icon with complex query lines appearing.\\\",\\\"mood\\\":\\\"Informative\\\"},{\\\"text\\\":\\\"Need simple caching? Redis is your go-to.\\\",\\\"visualDirection\\\":\\\"Redis logo with a thumbs-up icon.\\\",\\\"mood\\\":\\\"Encouraging\\\"},{\\\"text\\\":\\\"But if you want caching with SQL power, stick with PostgreSQL.\\\",\\\"visualDirection\\\":\\\"PostgreSQL logo with a power-up animation.\\\",\\\"mood\\\":\\\"Confident\\\"},{\\\"text\\\":\\\"So, what's your caching choice?\\\",\\\"visualDirection\\\":\\\"Question mark with Redis and PostgreSQL icons.\\\",\\\"mood\\\":\\\"Interactive\\\"}],\\\"reasoning\\\":\\\"The script provides a balanced comparison by highlighting the strengths of both Redis and PostgreSQL in terms of caching. Redis is known for its speed due to its in-memory capabilities, while PostgreSQL offers the advantage of complex queries and relational data handling. The recommendation is clear: use Redis for simple caching needs, and PostgreSQL when SQL capabilities are required.\\\",\\\"title\\\":\\\"Redis vs PostgreSQL: Which is Best for Caching?\\\",\\\"hook\\\":\\\"Redis or PostgreSQL for caching? Let's break it down.\\\",\\\"cta\\\":\\\"So, what's your caching choice?\\\",\\\"hashtags\\\":[\\\"#Redis\\\",\\\"#PostgreSQL\\\",\\\"#TechTips\\\"]}\\n</Output>\\n<Rubric>\\nThe script opens with an attention-grabbing hook.\\nFor a versus video, this might be a provocative statement like \\\"You're using the wrong database\\\"\\nor a relatable problem statement.\\n\\n</Rubric>\"}]"
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "For a versus archetype, the script should clearly compare both options.\nIt should present pros and cons of each, not just favor one.\nThe comparison should be fair and technically accurate.\n",
                "threshold": 0.8,
                "weight": 2
              },
              "pass": true,
              "score": 1,
              "reason": "The script provides a balanced comparison by highlighting the strengths of both Redis and PostgreSQL, detailing the pros of each without favoring one over the other.",
              "tokensUsed": {
                "total": 583,
                "prompt": 536,
                "completion": 47,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"Redis or PostgreSQL for caching? Let's break it down.\\\",\\\"visualDirection\\\":\\\"Split screen with Redis and PostgreSQL logos.\\\",\\\"mood\\\":\\\"Curious and engaging\\\"},{\\\"text\\\":\\\"Redis is lightning fast. It's an in-memory data store.\\\",\\\"visualDirection\\\":\\\"Fast-paced animation showing a rocket blasting off.\\\",\\\"mood\\\":\\\"Energetic\\\"},{\\\"text\\\":\\\"PostgreSQL offers more complex queries. Great for relational data.\\\",\\\"visualDirection\\\":\\\"Database icon with complex query lines appearing.\\\",\\\"mood\\\":\\\"Informative\\\"},{\\\"text\\\":\\\"Need simple caching? Redis is your go-to.\\\",\\\"visualDirection\\\":\\\"Redis logo with a thumbs-up icon.\\\",\\\"mood\\\":\\\"Encouraging\\\"},{\\\"text\\\":\\\"But if you want caching with SQL power, stick with PostgreSQL.\\\",\\\"visualDirection\\\":\\\"PostgreSQL logo with a power-up animation.\\\",\\\"mood\\\":\\\"Confident\\\"},{\\\"text\\\":\\\"So, what's your caching choice?\\\",\\\"visualDirection\\\":\\\"Question mark with Redis and PostgreSQL icons.\\\",\\\"mood\\\":\\\"Interactive\\\"}],\\\"reasoning\\\":\\\"The script provides a balanced comparison by highlighting the strengths of both Redis and PostgreSQL in terms of caching. Redis is known for its speed due to its in-memory capabilities, while PostgreSQL offers the advantage of complex queries and relational data handling. The recommendation is clear: use Redis for simple caching needs, and PostgreSQL when SQL capabilities are required.\\\",\\\"title\\\":\\\"Redis vs PostgreSQL: Which is Best for Caching?\\\",\\\"hook\\\":\\\"Redis or PostgreSQL for caching? Let's break it down.\\\",\\\"cta\\\":\\\"So, what's your caching choice?\\\",\\\"hashtags\\\":[\\\"#Redis\\\",\\\"#PostgreSQL\\\",\\\"#TechTips\\\"]}\\n</Output>\\n<Rubric>\\nFor a versus archetype, the script should clearly compare both options.\\nIt should present pros and cons of each, not just favor one.\\nThe comparison should be fair and technically accurate.\\n\\n</Rubric>\"}]"
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "The script provides a clear recommendation or decision framework at the end.\nViewers should know when to use each option.\n",
                "threshold": 0.7,
                "weight": 1
              },
              "pass": true,
              "score": 1,
              "reason": "The script clearly recommends using Redis for simple caching needs and PostgreSQL when SQL capabilities are required, providing a decision framework for the audience.",
              "tokensUsed": {
                "total": 566,
                "prompt": 522,
                "completion": 44,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"Redis or PostgreSQL for caching? Let's break it down.\\\",\\\"visualDirection\\\":\\\"Split screen with Redis and PostgreSQL logos.\\\",\\\"mood\\\":\\\"Curious and engaging\\\"},{\\\"text\\\":\\\"Redis is lightning fast. It's an in-memory data store.\\\",\\\"visualDirection\\\":\\\"Fast-paced animation showing a rocket blasting off.\\\",\\\"mood\\\":\\\"Energetic\\\"},{\\\"text\\\":\\\"PostgreSQL offers more complex queries. Great for relational data.\\\",\\\"visualDirection\\\":\\\"Database icon with complex query lines appearing.\\\",\\\"mood\\\":\\\"Informative\\\"},{\\\"text\\\":\\\"Need simple caching? Redis is your go-to.\\\",\\\"visualDirection\\\":\\\"Redis logo with a thumbs-up icon.\\\",\\\"mood\\\":\\\"Encouraging\\\"},{\\\"text\\\":\\\"But if you want caching with SQL power, stick with PostgreSQL.\\\",\\\"visualDirection\\\":\\\"PostgreSQL logo with a power-up animation.\\\",\\\"mood\\\":\\\"Confident\\\"},{\\\"text\\\":\\\"So, what's your caching choice?\\\",\\\"visualDirection\\\":\\\"Question mark with Redis and PostgreSQL icons.\\\",\\\"mood\\\":\\\"Interactive\\\"}],\\\"reasoning\\\":\\\"The script provides a balanced comparison by highlighting the strengths of both Redis and PostgreSQL in terms of caching. Redis is known for its speed due to its in-memory capabilities, while PostgreSQL offers the advantage of complex queries and relational data handling. The recommendation is clear: use Redis for simple caching needs, and PostgreSQL when SQL capabilities are required.\\\",\\\"title\\\":\\\"Redis vs PostgreSQL: Which is Best for Caching?\\\",\\\"hook\\\":\\\"Redis or PostgreSQL for caching? Let's break it down.\\\",\\\"cta\\\":\\\"So, what's your caching choice?\\\",\\\"hashtags\\\":[\\\"#Redis\\\",\\\"#PostgreSQL\\\",\\\"#TechTips\\\"]}\\n</Output>\\n<Rubric>\\nThe script provides a clear recommendation or decision framework at the end.\\nViewers should know when to use each option.\\n\\n</Rubric>\"}]"
              }
            }
          ]
        },
        "id": "01022ac2-2459-4607-a2d7-0e69de473bee",
        "latencyMs": 5341,
        "namedScores": {},
        "prompt": {
          "raw": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"Redis vs PostgreSQL for caching\"\n\nFORMAT: versus\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Use short sentences (<=15 words) and one idea per sentence.\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n\n\n\nPresent a balanced comparison with a clear recommendation at the end.\n\n\n\n\n\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n",
          "label": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"{{ topic }}\"\n\nFORMAT: {{ archetype }}\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Use short sentences (<=15 words) and one idea per sentence.\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n\n{% if archetype == \"listicle\" %}\nStructure as a numbered list with a hook, clear items, and a call-to-action.\n{% endif %}\n{% if archetype == \"versus\" %}\nPresent a balanced comparison with a clear recommendation at the end.\n{% endif %}\n{% if archetype == \"howto\" %}\nGive step-by-step instructions that are easy to follow.\n{% endif %}\n{% if archetype == \"myth\" %}\nStart with the myth, then reveal the reality with evidence.\n{% endif %}\n{% if archetype == \"story\" %}\nUse narrative structure: setup, conflict, resolution.\n{% endif %}\n{% if archetype == \"hot-take\" %}\nLead with a provocative opinion, then back it up with reasoning.\n{% endif %}\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n"
        },
        "promptId": "a3df67e6ef678c5736d74fe2db715f65a7b49b042e23a17fda9e6b7bcc746265",
        "promptIdx": 0,
        "provider": {
          "id": "openai:gpt-4o",
          "label": ""
        },
        "response": {
          "output": "{\n  \"scenes\": [\n    {\n      \"text\": \"Redis or PostgreSQL for caching? Let's break it down.\",\n      \"visualDirection\": \"Split screen with Redis and PostgreSQL logos.\",\n      \"mood\": \"Curious and engaging\"\n    },\n    {\n      \"text\": \"Redis is lightning fast. It's an in-memory data store.\",\n      \"visualDirection\": \"Fast-paced animation showing a rocket blasting off.\",\n      \"mood\": \"Energetic\"\n    },\n    {\n      \"text\": \"PostgreSQL offers more complex queries. Great for relational data.\",\n      \"visualDirection\": \"Database icon with complex query lines appearing.\",\n      \"mood\": \"Informative\"\n    },\n    {\n      \"text\": \"Need simple caching? Redis is your go-to.\",\n      \"visualDirection\": \"Redis logo with a thumbs-up icon.\",\n      \"mood\": \"Encouraging\"\n    },\n    {\n      \"text\": \"But if you want caching with SQL power, stick with PostgreSQL.\",\n      \"visualDirection\": \"PostgreSQL logo with a power-up animation.\",\n      \"mood\": \"Confident\"\n    },\n    {\n      \"text\": \"So, what's your caching choice?\",\n      \"visualDirection\": \"Question mark with Redis and PostgreSQL icons.\",\n      \"mood\": \"Interactive\"\n    }\n  ],\n  \"reasoning\": \"The script provides a balanced comparison by highlighting the strengths of both Redis and PostgreSQL in terms of caching. Redis is known for its speed due to its in-memory capabilities, while PostgreSQL offers the advantage of complex queries and relational data handling. The recommendation is clear: use Redis for simple caching needs, and PostgreSQL when SQL capabilities are required.\",\n  \"title\": \"Redis vs PostgreSQL: Which is Best for Caching?\",\n  \"hook\": \"Redis or PostgreSQL for caching? Let's break it down.\",\n  \"cta\": \"So, what's your caching choice?\",\n  \"hashtags\": [\"#Redis\", \"#PostgreSQL\", \"#TechTips\"]\n}",
          "tokenUsage": {
            "total": 798,
            "prompt": 382,
            "completion": 416,
            "numRequests": 1,
            "completionDetails": {
              "reasoning": 0,
              "acceptedPrediction": 0,
              "rejectedPrediction": 0
            }
          },
          "cached": false,
          "latencyMs": 5341,
          "finishReason": "stop",
          "cost": 0.005115000000000001,
          "guardrails": {
            "flagged": false
          }
        },
        "score": 0.7857142857142857,
        "success": false,
        "testCase": {
          "vars": {
            "topic": "Redis vs PostgreSQL for caching",
            "archetype": "versus"
          },
          "assert": [
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return (\n    Array.isArray(script.scenes) &&\n    script.scenes.length >= 3 &&\n    script.scenes.length <= 7\n  );\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 80 && wordCount <= 200;\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return (script.scenes || []).every((scene) =>\n    typeof scene.visualDirection === 'string' && scene.visualDirection.trim().length > 5\n  );\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean)\n    .join(' ');\n  const hasEmoji = /\\p{Extended_Pictographic}/u.test(spoken);\n  const hasMarkdown = /[`*_]/.test(spoken) || /\\[(.+?)\\]\\((.+?)\\)/.test(spoken);\n  const hasHashtag = /(^|\\s)#\\w+/.test(spoken);\n  return !hasEmoji && !hasMarkdown && !hasHashtag;\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return typeof script.reasoning === 'string' && script.reasoning.trim().length > 10;\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "llm-rubric",
              "value": "The script opens with an attention-grabbing hook.\nFor a versus video, this might be a provocative statement like \"You're using the wrong database\"\nor a relatable problem statement.\n",
              "threshold": 0.7,
              "weight": 2
            },
            {
              "type": "llm-rubric",
              "value": "For a versus archetype, the script should clearly compare both options.\nIt should present pros and cons of each, not just favor one.\nThe comparison should be fair and technically accurate.\n",
              "threshold": 0.8,
              "weight": 2
            },
            {
              "type": "llm-rubric",
              "value": "The script provides a clear recommendation or decision framework at the end.\nViewers should know when to use each option.\n",
              "threshold": 0.7,
              "weight": 1
            }
          ],
          "options": {
            "provider": "openai:gpt-4o-mini"
          },
          "metadata": {}
        },
        "testIdx": 1,
        "vars": {
          "topic": "Redis vs PostgreSQL for caching",
          "archetype": "versus"
        },
        "metadata": {
          "_promptfooFileMetadata": {}
        },
        "failureReason": 1
      },
      {
        "cost": 0.0050750000000000005,
        "error": "Custom function returned false\ntry {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 80 && wordCount <= 200;\n} catch { return false; }",
        "gradingResult": {
          "pass": false,
          "score": 0.9166666666666666,
          "reason": "Custom function returned false\ntry {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 80 && wordCount <= 200;\n} catch { return false; }",
          "namedScores": {},
          "tokensUsed": {
            "total": 1187,
            "prompt": 1071,
            "completion": 116,
            "cached": 0,
            "numRequests": 2
          },
          "componentResults": [
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return (\n    Array.isArray(script.scenes) &&\n    script.scenes.length >= 3 &&\n    script.scenes.length <= 7\n  );\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": false,
              "score": 0,
              "reason": "Custom function returned false\ntry {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 80 && wordCount <= 200;\n} catch { return false; }",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 80 && wordCount <= 200;\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return (script.scenes || []).every((scene) =>\n    typeof scene.visualDirection === 'string' && scene.visualDirection.trim().length > 5\n  );\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean)\n    .join(' ');\n  const hasEmoji = /\\p{Extended_Pictographic}/u.test(spoken);\n  const hasMarkdown = /[`*_]/.test(spoken) || /\\[(.+?)\\]\\((.+?)\\)/.test(spoken);\n  const hasHashtag = /(^|\\s)#\\w+/.test(spoken);\n  return !hasEmoji && !hasMarkdown && !hasHashtag;\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return typeof script.reasoning === 'string' && script.reasoning.trim().length > 10;\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "The script has a narrative arc: setup, challenge, resolution.\nIt should feel like a personal story, not a tutorial.\n",
                "threshold": 0.8,
                "weight": 2
              },
              "pass": true,
              "score": 1,
              "reason": "The script follows a clear narrative arc with a setup (learning React), a challenge (breaking down the basics and building a to-do app), and a resolution (gaining confidence). Additionally, it conveys a personal journey through the use of first-person experiences and emotional reflections.",
              "tokensUsed": {
                "total": 609,
                "prompt": 538,
                "completion": 71,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"I had only 2 weeks to learn React. Sounds crazy, right?\\\",\\\"visualDirection\\\":\\\"Show a calendar flipping to 2 weeks ahead.\\\",\\\"mood\\\":\\\"Excited and a bit anxious.\\\"},{\\\"text\\\":\\\"First, I broke down the basics. Components, state, and props.\\\",\\\"visualDirection\\\":\\\"Quick clips of React documentation and a whiteboard with key terms.\\\",\\\"mood\\\":\\\"Focused and determined.\\\"},{\\\"text\\\":\\\"Next, I joined online communities. Reddit, Discord, theyre goldmines!\\\",\\\"visualDirection\\\":\\\"Screen capture of discussions and helpful tips from forums.\\\",\\\"mood\\\":\\\"Engaged and collaborative.\\\"},{\\\"text\\\":\\\"Then came project time. I built a to-do app. It was tough, but rewarding.\\\",\\\"visualDirection\\\":\\\"Timelapse of coding sessions, ending with a working app.\\\",\\\"mood\\\":\\\"Challenging yet satisfying.\\\"},{\\\"text\\\":\\\"Two weeks later, I was confident. Practice, not perfection, is key.\\\",\\\"visualDirection\\\":\\\"Show a calendar ending on the last day with a thumbs-up.\\\",\\\"mood\\\":\\\"Proud and accomplished.\\\"}],\\\"reasoning\\\":\\\"The script is structured to engage viewers with a relatable challenge and shows a progression from uncertainty to achievement. Each scene builds upon the last, offering tangible steps and a sense of progression in learning React. The mood transitions from anxious to accomplished, reflecting the journey's ups and downs.\\\",\\\"title\\\":\\\"Mastering React in 2 Weeks\\\",\\\"hook\\\":\\\"Can you learn React in just two weeks? Here's how I did it.\\\",\\\"cta\\\":\\\"Think you can do it too? Dive into React now!\\\",\\\"hashtags\\\":[\\\"#ReactJS\\\",\\\"#CodingJourney\\\",\\\"#LearnToCode\\\"]}\\n</Output>\\n<Rubric>\\nThe script has a narrative arc: setup, challenge, resolution.\\nIt should feel like a personal story, not a tutorial.\\n\\n</Rubric>\"}]"
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "The language uses first-person perspective and includes emotional elements.\nThe viewer should feel connected to the storyteller.\n",
                "threshold": 0.7,
                "weight": 1
              },
              "pass": true,
              "score": 1,
              "reason": "The output uses first-person perspective throughout the script, expressing emotions like excitement, anxiety, and accomplishment, which fosters a connection with the viewer.",
              "tokensUsed": {
                "total": 578,
                "prompt": 533,
                "completion": 45,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"I had only 2 weeks to learn React. Sounds crazy, right?\\\",\\\"visualDirection\\\":\\\"Show a calendar flipping to 2 weeks ahead.\\\",\\\"mood\\\":\\\"Excited and a bit anxious.\\\"},{\\\"text\\\":\\\"First, I broke down the basics. Components, state, and props.\\\",\\\"visualDirection\\\":\\\"Quick clips of React documentation and a whiteboard with key terms.\\\",\\\"mood\\\":\\\"Focused and determined.\\\"},{\\\"text\\\":\\\"Next, I joined online communities. Reddit, Discord, theyre goldmines!\\\",\\\"visualDirection\\\":\\\"Screen capture of discussions and helpful tips from forums.\\\",\\\"mood\\\":\\\"Engaged and collaborative.\\\"},{\\\"text\\\":\\\"Then came project time. I built a to-do app. It was tough, but rewarding.\\\",\\\"visualDirection\\\":\\\"Timelapse of coding sessions, ending with a working app.\\\",\\\"mood\\\":\\\"Challenging yet satisfying.\\\"},{\\\"text\\\":\\\"Two weeks later, I was confident. Practice, not perfection, is key.\\\",\\\"visualDirection\\\":\\\"Show a calendar ending on the last day with a thumbs-up.\\\",\\\"mood\\\":\\\"Proud and accomplished.\\\"}],\\\"reasoning\\\":\\\"The script is structured to engage viewers with a relatable challenge and shows a progression from uncertainty to achievement. Each scene builds upon the last, offering tangible steps and a sense of progression in learning React. The mood transitions from anxious to accomplished, reflecting the journey's ups and downs.\\\",\\\"title\\\":\\\"Mastering React in 2 Weeks\\\",\\\"hook\\\":\\\"Can you learn React in just two weeks? Here's how I did it.\\\",\\\"cta\\\":\\\"Think you can do it too? Dive into React now!\\\",\\\"hashtags\\\":[\\\"#ReactJS\\\",\\\"#CodingJourney\\\",\\\"#LearnToCode\\\"]}\\n</Output>\\n<Rubric>\\nThe language uses first-person perspective and includes emotional elements.\\nThe viewer should feel connected to the storyteller.\\n\\n</Rubric>\"}]"
              }
            }
          ]
        },
        "id": "6ba013e7-bea2-4ed4-98cd-e7aea2faed95",
        "latencyMs": 7590,
        "namedScores": {},
        "prompt": {
          "raw": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"How I learned React in 2 weeks\"\n\nFORMAT: story\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Use short sentences (<=15 words) and one idea per sentence.\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n\n\n\n\n\n\nUse narrative structure: setup, conflict, resolution.\n\n\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n",
          "label": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"{{ topic }}\"\n\nFORMAT: {{ archetype }}\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Use short sentences (<=15 words) and one idea per sentence.\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n\n{% if archetype == \"listicle\" %}\nStructure as a numbered list with a hook, clear items, and a call-to-action.\n{% endif %}\n{% if archetype == \"versus\" %}\nPresent a balanced comparison with a clear recommendation at the end.\n{% endif %}\n{% if archetype == \"howto\" %}\nGive step-by-step instructions that are easy to follow.\n{% endif %}\n{% if archetype == \"myth\" %}\nStart with the myth, then reveal the reality with evidence.\n{% endif %}\n{% if archetype == \"story\" %}\nUse narrative structure: setup, conflict, resolution.\n{% endif %}\n{% if archetype == \"hot-take\" %}\nLead with a provocative opinion, then back it up with reasoning.\n{% endif %}\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n"
        },
        "promptId": "a3df67e6ef678c5736d74fe2db715f65a7b49b042e23a17fda9e6b7bcc746265",
        "promptIdx": 0,
        "provider": {
          "id": "openai:gpt-4o",
          "label": ""
        },
        "response": {
          "output": "{\n  \"scenes\": [\n    {\n      \"text\": \"I had only 2 weeks to learn React. Sounds crazy, right?\",\n      \"visualDirection\": \"Show a calendar flipping to 2 weeks ahead.\",\n      \"mood\": \"Excited and a bit anxious.\"\n    },\n    {\n      \"text\": \"First, I broke down the basics. Components, state, and props.\",\n      \"visualDirection\": \"Quick clips of React documentation and a whiteboard with key terms.\",\n      \"mood\": \"Focused and determined.\"\n    },\n    {\n      \"text\": \"Next, I joined online communities. Reddit, Discord, theyre goldmines!\",\n      \"visualDirection\": \"Screen capture of discussions and helpful tips from forums.\",\n      \"mood\": \"Engaged and collaborative.\"\n    },\n    {\n      \"text\": \"Then came project time. I built a to-do app. It was tough, but rewarding.\",\n      \"visualDirection\": \"Timelapse of coding sessions, ending with a working app.\",\n      \"mood\": \"Challenging yet satisfying.\"\n    },\n    {\n      \"text\": \"Two weeks later, I was confident. Practice, not perfection, is key.\",\n      \"visualDirection\": \"Show a calendar ending on the last day with a thumbs-up.\",\n      \"mood\": \"Proud and accomplished.\"\n    }\n  ],\n  \"reasoning\": \"The script is structured to engage viewers with a relatable challenge and shows a progression from uncertainty to achievement. Each scene builds upon the last, offering tangible steps and a sense of progression in learning React. The mood transitions from anxious to accomplished, reflecting the journey's ups and downs.\",\n  \"title\": \"Mastering React in 2 Weeks\",\n  \"hook\": \"Can you learn React in just two weeks? Here's how I did it.\",\n  \"cta\": \"Think you can do it too? Dive into React now!\",\n  \"hashtags\": [\"#ReactJS\", \"#CodingJourney\", \"#LearnToCode\"]\n}",
          "tokenUsage": {
            "total": 794,
            "prompt": 382,
            "completion": 412,
            "numRequests": 1,
            "completionDetails": {
              "reasoning": 0,
              "acceptedPrediction": 0,
              "rejectedPrediction": 0
            }
          },
          "cached": false,
          "latencyMs": 7590,
          "finishReason": "stop",
          "cost": 0.0050750000000000005,
          "guardrails": {
            "flagged": false
          }
        },
        "score": 0.9166666666666666,
        "success": false,
        "testCase": {
          "vars": {
            "topic": "How I learned React in 2 weeks",
            "archetype": "story"
          },
          "assert": [
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return (\n    Array.isArray(script.scenes) &&\n    script.scenes.length >= 3 &&\n    script.scenes.length <= 7\n  );\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 80 && wordCount <= 200;\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return (script.scenes || []).every((scene) =>\n    typeof scene.visualDirection === 'string' && scene.visualDirection.trim().length > 5\n  );\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean)\n    .join(' ');\n  const hasEmoji = /\\p{Extended_Pictographic}/u.test(spoken);\n  const hasMarkdown = /[`*_]/.test(spoken) || /\\[(.+?)\\]\\((.+?)\\)/.test(spoken);\n  const hasHashtag = /(^|\\s)#\\w+/.test(spoken);\n  return !hasEmoji && !hasMarkdown && !hasHashtag;\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return typeof script.reasoning === 'string' && script.reasoning.trim().length > 10;\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "llm-rubric",
              "value": "The script has a narrative arc: setup, challenge, resolution.\nIt should feel like a personal story, not a tutorial.\n",
              "threshold": 0.8,
              "weight": 2
            },
            {
              "type": "llm-rubric",
              "value": "The language uses first-person perspective and includes emotional elements.\nThe viewer should feel connected to the storyteller.\n",
              "threshold": 0.7,
              "weight": 1
            }
          ],
          "options": {
            "provider": "openai:gpt-4o-mini"
          },
          "metadata": {}
        },
        "testIdx": 2,
        "vars": {
          "topic": "How I learned React in 2 weeks",
          "archetype": "story"
        },
        "metadata": {
          "_promptfooFileMetadata": {}
        },
        "failureReason": 1
      },
      {
        "cost": 0.004450000000000001,
        "error": "Custom function returned false\ntry {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 80 && wordCount <= 200;\n} catch { return false; }",
        "gradingResult": {
          "pass": false,
          "score": 0.9230769230769231,
          "reason": "Custom function returned false\ntry {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 80 && wordCount <= 200;\n} catch { return false; }",
          "namedScores": {},
          "tokensUsed": {
            "total": 1033,
            "prompt": 949,
            "completion": 84,
            "cached": 0,
            "numRequests": 2
          },
          "componentResults": [
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return (\n    Array.isArray(script.scenes) &&\n    script.scenes.length >= 3 &&\n    script.scenes.length <= 7\n  );\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": false,
              "score": 0,
              "reason": "Custom function returned false\ntry {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 80 && wordCount <= 200;\n} catch { return false; }",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 80 && wordCount <= 200;\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return (script.scenes || []).every((scene) =>\n    typeof scene.visualDirection === 'string' && scene.visualDirection.trim().length > 5\n  );\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean)\n    .join(' ');\n  const hasEmoji = /\\p{Extended_Pictographic}/u.test(spoken);\n  const hasMarkdown = /[`*_]/.test(spoken) || /\\[(.+?)\\]\\((.+?)\\)/.test(spoken);\n  const hasHashtag = /(^|\\s)#\\w+/.test(spoken);\n  return !hasEmoji && !hasMarkdown && !hasHashtag;\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return typeof script.reasoning === 'string' && script.reasoning.trim().length > 10;\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "The script opens with a bold, controversial statement that will spark debate.\nIt should immediately make viewers want to comment (agree or disagree).\n",
                "threshold": 0.8,
                "weight": 2
              },
              "pass": true,
              "score": 1,
              "reason": "The script opens with 'TypeScript is overrated, and here's why!', which is a bold statement that is likely to provoke a reaction.",
              "tokensUsed": {
                "total": 519,
                "prompt": 474,
                "completion": 45,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"TypeScript is like a fancy dress code for JavaScript, but is it worth it?\\\",\\\"visualDirection\\\":\\\"Close-up of someone coding, then shaking their head in frustration.\\\",\\\"mood\\\":\\\"Curious\\\"},{\\\"text\\\":\\\"It adds complexity. More rules, more headaches, less fun.\\\",\\\"visualDirection\\\":\\\"Quick cuts to a messy code editor and someone sighing.\\\",\\\"mood\\\":\\\"Frustrated\\\"},{\\\"text\\\":\\\"You spend more time fixing type errors than writing actual code.\\\",\\\"visualDirection\\\":\\\"Shot of someone endlessly scrolling through error messages.\\\",\\\"mood\\\":\\\"Annoyed\\\"},{\\\"text\\\":\\\"Plus, JavaScript is already flexible. Why box it in with extra types?\\\",\\\"visualDirection\\\":\\\"Pan over JavaScript code with annotations appearing.\\\",\\\"mood\\\":\\\"Questioning\\\"},{\\\"text\\\":\\\"And, let's be real, not every project needs it.\\\",\\\"visualDirection\\\":\\\"Split screen: one side complex, one side simple and clean.\\\",\\\"mood\\\":\\\"Straightforward\\\"}],\\\"reasoning\\\":\\\"Despite its popularity, TypeScript's added complexity and rigidity often outweigh its benefits, especially for smaller projects.\\\",\\\"title\\\":\\\"Is TypeScript Overrated?\\\",\\\"hook\\\":\\\"TypeScript is overrated, and here's why!\\\",\\\"cta\\\":\\\"Think TypeScript is worth it? Drop your thoughts in the comments!\\\",\\\"hashtags\\\":[\\\"#TypeScript\\\",\\\"#CodingDebate\\\",\\\"#WebDevelopment\\\"]}\\n</Output>\\n<Rubric>\\nThe script opens with a bold, controversial statement that will spark debate.\\nIt should immediately make viewers want to comment (agree or disagree).\\n\\n</Rubric>\"}]"
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "Despite being a hot take, the script provides actual reasoning and evidence.\nIt's not just rage bait; there should be substance behind the opinion.\n",
                "threshold": 0.7,
                "weight": 2
              },
              "pass": true,
              "score": 1,
              "reason": "The output provides clear reasoning regarding TypeScript's added complexity and suggests it may not be necessary for all projects.",
              "tokensUsed": {
                "total": 514,
                "prompt": 475,
                "completion": 39,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"TypeScript is like a fancy dress code for JavaScript, but is it worth it?\\\",\\\"visualDirection\\\":\\\"Close-up of someone coding, then shaking their head in frustration.\\\",\\\"mood\\\":\\\"Curious\\\"},{\\\"text\\\":\\\"It adds complexity. More rules, more headaches, less fun.\\\",\\\"visualDirection\\\":\\\"Quick cuts to a messy code editor and someone sighing.\\\",\\\"mood\\\":\\\"Frustrated\\\"},{\\\"text\\\":\\\"You spend more time fixing type errors than writing actual code.\\\",\\\"visualDirection\\\":\\\"Shot of someone endlessly scrolling through error messages.\\\",\\\"mood\\\":\\\"Annoyed\\\"},{\\\"text\\\":\\\"Plus, JavaScript is already flexible. Why box it in with extra types?\\\",\\\"visualDirection\\\":\\\"Pan over JavaScript code with annotations appearing.\\\",\\\"mood\\\":\\\"Questioning\\\"},{\\\"text\\\":\\\"And, let's be real, not every project needs it.\\\",\\\"visualDirection\\\":\\\"Split screen: one side complex, one side simple and clean.\\\",\\\"mood\\\":\\\"Straightforward\\\"}],\\\"reasoning\\\":\\\"Despite its popularity, TypeScript's added complexity and rigidity often outweigh its benefits, especially for smaller projects.\\\",\\\"title\\\":\\\"Is TypeScript Overrated?\\\",\\\"hook\\\":\\\"TypeScript is overrated, and here's why!\\\",\\\"cta\\\":\\\"Think TypeScript is worth it? Drop your thoughts in the comments!\\\",\\\"hashtags\\\":[\\\"#TypeScript\\\",\\\"#CodingDebate\\\",\\\"#WebDevelopment\\\"]}\\n</Output>\\n<Rubric>\\nDespite being a hot take, the script provides actual reasoning and evidence.\\nIt's not just rage bait; there should be substance behind the opinion.\\n\\n</Rubric>\"}]"
              }
            }
          ]
        },
        "id": "5910a8c8-f22a-4841-95ca-017a0af3c4a8",
        "latencyMs": 5112,
        "namedScores": {},
        "prompt": {
          "raw": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"TypeScript is overrated\"\n\nFORMAT: hot-take\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Use short sentences (<=15 words) and one idea per sentence.\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n\n\n\n\n\n\n\nLead with a provocative opinion, then back it up with reasoning.\n\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n",
          "label": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"{{ topic }}\"\n\nFORMAT: {{ archetype }}\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Use short sentences (<=15 words) and one idea per sentence.\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n\n{% if archetype == \"listicle\" %}\nStructure as a numbered list with a hook, clear items, and a call-to-action.\n{% endif %}\n{% if archetype == \"versus\" %}\nPresent a balanced comparison with a clear recommendation at the end.\n{% endif %}\n{% if archetype == \"howto\" %}\nGive step-by-step instructions that are easy to follow.\n{% endif %}\n{% if archetype == \"myth\" %}\nStart with the myth, then reveal the reality with evidence.\n{% endif %}\n{% if archetype == \"story\" %}\nUse narrative structure: setup, conflict, resolution.\n{% endif %}\n{% if archetype == \"hot-take\" %}\nLead with a provocative opinion, then back it up with reasoning.\n{% endif %}\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n"
        },
        "promptId": "a3df67e6ef678c5736d74fe2db715f65a7b49b042e23a17fda9e6b7bcc746265",
        "promptIdx": 0,
        "provider": {
          "id": "openai:gpt-4o",
          "label": ""
        },
        "response": {
          "output": "{\n  \"scenes\": [\n    {\n      \"text\": \"TypeScript is like a fancy dress code for JavaScript, but is it worth it?\",\n      \"visualDirection\": \"Close-up of someone coding, then shaking their head in frustration.\",\n      \"mood\": \"Curious\"\n    },\n    {\n      \"text\": \"It adds complexity. More rules, more headaches, less fun.\",\n      \"visualDirection\": \"Quick cuts to a messy code editor and someone sighing.\",\n      \"mood\": \"Frustrated\"\n    },\n    {\n      \"text\": \"You spend more time fixing type errors than writing actual code.\",\n      \"visualDirection\": \"Shot of someone endlessly scrolling through error messages.\",\n      \"mood\": \"Annoyed\"\n    },\n    {\n      \"text\": \"Plus, JavaScript is already flexible. Why box it in with extra types?\",\n      \"visualDirection\": \"Pan over JavaScript code with annotations appearing.\",\n      \"mood\": \"Questioning\"\n    },\n    {\n      \"text\": \"And, let's be real, not every project needs it.\",\n      \"visualDirection\": \"Split screen: one side complex, one side simple and clean.\",\n      \"mood\": \"Straightforward\"\n    }\n  ],\n  \"reasoning\": \"Despite its popularity, TypeScript's added complexity and rigidity often outweigh its benefits, especially for smaller projects.\",\n  \"title\": \"Is TypeScript Overrated?\",\n  \"hook\": \"TypeScript is overrated, and here's why!\",\n  \"cta\": \"Think TypeScript is worth it? Drop your thoughts in the comments!\",\n  \"hashtags\": [\"#TypeScript\", \"#CodingDebate\", \"#WebDevelopment\"]\n}",
          "tokenUsage": {
            "total": 733,
            "prompt": 384,
            "completion": 349,
            "numRequests": 1,
            "completionDetails": {
              "reasoning": 0,
              "acceptedPrediction": 0,
              "rejectedPrediction": 0
            }
          },
          "cached": false,
          "latencyMs": 5112,
          "finishReason": "stop",
          "cost": 0.004450000000000001,
          "guardrails": {
            "flagged": false
          }
        },
        "score": 0.9230769230769231,
        "success": false,
        "testCase": {
          "vars": {
            "topic": "TypeScript is overrated",
            "archetype": "hot-take"
          },
          "assert": [
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return (\n    Array.isArray(script.scenes) &&\n    script.scenes.length >= 3 &&\n    script.scenes.length <= 7\n  );\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 80 && wordCount <= 200;\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return (script.scenes || []).every((scene) =>\n    typeof scene.visualDirection === 'string' && scene.visualDirection.trim().length > 5\n  );\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean)\n    .join(' ');\n  const hasEmoji = /\\p{Extended_Pictographic}/u.test(spoken);\n  const hasMarkdown = /[`*_]/.test(spoken) || /\\[(.+?)\\]\\((.+?)\\)/.test(spoken);\n  const hasHashtag = /(^|\\s)#\\w+/.test(spoken);\n  return !hasEmoji && !hasMarkdown && !hasHashtag;\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return typeof script.reasoning === 'string' && script.reasoning.trim().length > 10;\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "llm-rubric",
              "value": "The script opens with a bold, controversial statement that will spark debate.\nIt should immediately make viewers want to comment (agree or disagree).\n",
              "threshold": 0.8,
              "weight": 2
            },
            {
              "type": "llm-rubric",
              "value": "Despite being a hot take, the script provides actual reasoning and evidence.\nIt's not just rage bait; there should be substance behind the opinion.\n",
              "threshold": 0.7,
              "weight": 2
            }
          ],
          "options": {
            "provider": "openai:gpt-4o-mini"
          },
          "metadata": {}
        },
        "testIdx": 3,
        "vars": {
          "topic": "TypeScript is overrated",
          "archetype": "hot-take"
        },
        "metadata": {
          "_promptfooFileMetadata": {}
        },
        "failureReason": 1
      },
      {
        "cost": 0.0052250000000000005,
        "error": "Custom function returned false\ntry {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 80 && wordCount <= 200;\n} catch { return false; }",
        "gradingResult": {
          "pass": false,
          "score": 0.9166666666666666,
          "reason": "Custom function returned false\ntry {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 80 && wordCount <= 200;\n} catch { return false; }",
          "namedScores": {},
          "tokensUsed": {
            "total": 1171,
            "prompt": 1090,
            "completion": 81,
            "cached": 0,
            "numRequests": 2
          },
          "componentResults": [
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return (\n    Array.isArray(script.scenes) &&\n    script.scenes.length >= 3 &&\n    script.scenes.length <= 7\n  );\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": false,
              "score": 0,
              "reason": "Custom function returned false\ntry {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 80 && wordCount <= 200;\n} catch { return false; }",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 80 && wordCount <= 200;\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return (script.scenes || []).every((scene) =>\n    typeof scene.visualDirection === 'string' && scene.visualDirection.trim().length > 5\n  );\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean)\n    .join(' ');\n  const hasEmoji = /\\p{Extended_Pictographic}/u.test(spoken);\n  const hasMarkdown = /[`*_]/.test(spoken) || /\\[(.+?)\\]\\((.+?)\\)/.test(spoken);\n  const hasHashtag = /(^|\\s)#\\w+/.test(spoken);\n  return !hasEmoji && !hasMarkdown && !hasHashtag;\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return typeof script.reasoning === 'string' && script.reasoning.trim().length > 10;\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "The script has clear, sequential steps that are easy to follow.\nEach step should be actionable and specific.\n",
                "threshold": 0.8,
                "weight": 2
              },
              "pass": true,
              "score": 1,
              "reason": "The script contains clear, sequential steps that guide the viewer through the process of deploying a Node.js app, with each step being actionable and specific.",
              "tokensUsed": {
                "total": 588,
                "prompt": 542,
                "completion": 46,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"Step one, make sure your app's ready. Double-check everything's working locally.\\\",\\\"visualDirection\\\":\\\"Show a split screen of a smiling person coding and a Node.js logo.\\\",\\\"mood\\\":\\\"Confident and casual\\\"},{\\\"text\\\":\\\"Next, create a GitHub repository. Push your code up there.\\\",\\\"visualDirection\\\":\\\"Show a screen recording of creating a GitHub repo and pushing code.\\\",\\\"mood\\\":\\\"Energetic and focused\\\"},{\\\"text\\\":\\\"Now, head to Heroku dot com. Sign up, it's quick!\\\",\\\"visualDirection\\\":\\\"Show a screen recording of the Heroku website and sign up process.\\\",\\\"mood\\\":\\\"Encouraging and upbeat\\\"},{\\\"text\\\":\\\"Create a new app in Heroku. Connect it to your GitHub repo.\\\",\\\"visualDirection\\\":\\\"Show the Heroku dashboard, creating an app, and linking GitHub.\\\",\\\"mood\\\":\\\"Clear and instructional\\\"},{\\\"text\\\":\\\"Click deploy and watch the magic! Your app's live.\\\",\\\"visualDirection\\\":\\\"Show the deploy button being clicked and a success animation.\\\",\\\"mood\\\":\\\"Exciting and celebratory\\\"}],\\\"reasoning\\\":\\\"This script provides a quick, step-by-step guide to deploying a Node.js app using GitHub and Heroku. It assumes the viewer has basic knowledge of these platforms. The steps are simplified for clarity and speed, focusing on key actions. The upbeat mood is designed to encourage and engage viewers, making the process seem easy and achievable.\\\",\\\"title\\\":\\\"Deploy a Node.js App in 5 Minutes\\\",\\\"hook\\\":\\\"Wanna deploy your Node.js app in just five minutes?\\\",\\\"cta\\\":\\\"Give it a shot and get your app live today!\\\",\\\"hashtags\\\":[\\\"#NodeJS\\\",\\\"#Heroku\\\",\\\"#WebDevelopment\\\",\\\"#Coding\\\"]}\\n</Output>\\n<Rubric>\\nThe script has clear, sequential steps that are easy to follow.\\nEach step should be actionable and specific.\\n\\n</Rubric>\"}]"
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "The visual directions show what the viewer should be doing at each step.\nThis could include screen recordings, terminal commands, or UI interactions.\n",
                "threshold": 0.8,
                "weight": 1
              },
              "pass": true,
              "score": 1,
              "reason": "The visual directions specify showing screen recordings and interface actions for each step, indicating what the viewer should be doing.",
              "tokensUsed": {
                "total": 583,
                "prompt": 548,
                "completion": 35,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"Step one, make sure your app's ready. Double-check everything's working locally.\\\",\\\"visualDirection\\\":\\\"Show a split screen of a smiling person coding and a Node.js logo.\\\",\\\"mood\\\":\\\"Confident and casual\\\"},{\\\"text\\\":\\\"Next, create a GitHub repository. Push your code up there.\\\",\\\"visualDirection\\\":\\\"Show a screen recording of creating a GitHub repo and pushing code.\\\",\\\"mood\\\":\\\"Energetic and focused\\\"},{\\\"text\\\":\\\"Now, head to Heroku dot com. Sign up, it's quick!\\\",\\\"visualDirection\\\":\\\"Show a screen recording of the Heroku website and sign up process.\\\",\\\"mood\\\":\\\"Encouraging and upbeat\\\"},{\\\"text\\\":\\\"Create a new app in Heroku. Connect it to your GitHub repo.\\\",\\\"visualDirection\\\":\\\"Show the Heroku dashboard, creating an app, and linking GitHub.\\\",\\\"mood\\\":\\\"Clear and instructional\\\"},{\\\"text\\\":\\\"Click deploy and watch the magic! Your app's live.\\\",\\\"visualDirection\\\":\\\"Show the deploy button being clicked and a success animation.\\\",\\\"mood\\\":\\\"Exciting and celebratory\\\"}],\\\"reasoning\\\":\\\"This script provides a quick, step-by-step guide to deploying a Node.js app using GitHub and Heroku. It assumes the viewer has basic knowledge of these platforms. The steps are simplified for clarity and speed, focusing on key actions. The upbeat mood is designed to encourage and engage viewers, making the process seem easy and achievable.\\\",\\\"title\\\":\\\"Deploy a Node.js App in 5 Minutes\\\",\\\"hook\\\":\\\"Wanna deploy your Node.js app in just five minutes?\\\",\\\"cta\\\":\\\"Give it a shot and get your app live today!\\\",\\\"hashtags\\\":[\\\"#NodeJS\\\",\\\"#Heroku\\\",\\\"#WebDevelopment\\\",\\\"#Coding\\\"]}\\n</Output>\\n<Rubric>\\nThe visual directions show what the viewer should be doing at each step.\\nThis could include screen recordings, terminal commands, or UI interactions.\\n\\n</Rubric>\"}]"
              }
            }
          ]
        },
        "id": "e66adc1e-54e4-4b20-a7f9-347a72cf5f9a",
        "latencyMs": 5928,
        "namedScores": {},
        "prompt": {
          "raw": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"How to deploy a Node.js app in 5 minutes\"\n\nFORMAT: howto\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Use short sentences (<=15 words) and one idea per sentence.\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n\n\n\n\nGive step-by-step instructions that are easy to follow.\n\n\n\n\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n",
          "label": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"{{ topic }}\"\n\nFORMAT: {{ archetype }}\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Use short sentences (<=15 words) and one idea per sentence.\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n\n{% if archetype == \"listicle\" %}\nStructure as a numbered list with a hook, clear items, and a call-to-action.\n{% endif %}\n{% if archetype == \"versus\" %}\nPresent a balanced comparison with a clear recommendation at the end.\n{% endif %}\n{% if archetype == \"howto\" %}\nGive step-by-step instructions that are easy to follow.\n{% endif %}\n{% if archetype == \"myth\" %}\nStart with the myth, then reveal the reality with evidence.\n{% endif %}\n{% if archetype == \"story\" %}\nUse narrative structure: setup, conflict, resolution.\n{% endif %}\n{% if archetype == \"hot-take\" %}\nLead with a provocative opinion, then back it up with reasoning.\n{% endif %}\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n"
        },
        "promptId": "a3df67e6ef678c5736d74fe2db715f65a7b49b042e23a17fda9e6b7bcc746265",
        "promptIdx": 0,
        "provider": {
          "id": "openai:gpt-4o",
          "label": ""
        },
        "response": {
          "output": "{\n  \"scenes\": [\n    {\n      \"text\": \"Step one, make sure your app's ready. Double-check everything's working locally.\",\n      \"visualDirection\": \"Show a split screen of a smiling person coding and a Node.js logo.\",\n      \"mood\": \"Confident and casual\"\n    },\n    {\n      \"text\": \"Next, create a GitHub repository. Push your code up there.\",\n      \"visualDirection\": \"Show a screen recording of creating a GitHub repo and pushing code.\",\n      \"mood\": \"Energetic and focused\"\n    },\n    {\n      \"text\": \"Now, head to Heroku dot com. Sign up, it's quick!\",\n      \"visualDirection\": \"Show a screen recording of the Heroku website and sign up process.\",\n      \"mood\": \"Encouraging and upbeat\"\n    },\n    {\n      \"text\": \"Create a new app in Heroku. Connect it to your GitHub repo.\",\n      \"visualDirection\": \"Show the Heroku dashboard, creating an app, and linking GitHub.\",\n      \"mood\": \"Clear and instructional\"\n    },\n    {\n      \"text\": \"Click deploy and watch the magic! Your app's live.\",\n      \"visualDirection\": \"Show the deploy button being clicked and a success animation.\",\n      \"mood\": \"Exciting and celebratory\"\n    }\n  ],\n  \"reasoning\": \"This script provides a quick, step-by-step guide to deploying a Node.js app using GitHub and Heroku. It assumes the viewer has basic knowledge of these platforms. The steps are simplified for clarity and speed, focusing on key actions. The upbeat mood is designed to encourage and engage viewers, making the process seem easy and achievable.\",\n  \"title\": \"Deploy a Node.js App in 5 Minutes\",\n  \"hook\": \"Wanna deploy your Node.js app in just five minutes?\",\n  \"cta\": \"Give it a shot and get your app live today!\",\n  \"hashtags\": [\"#NodeJS\", \"#Heroku\", \"#WebDevelopment\", \"#Coding\"]\n}",
          "tokenUsage": {
            "total": 812,
            "prompt": 386,
            "completion": 426,
            "numRequests": 1,
            "completionDetails": {
              "reasoning": 0,
              "acceptedPrediction": 0,
              "rejectedPrediction": 0
            }
          },
          "cached": false,
          "latencyMs": 5928,
          "finishReason": "stop",
          "cost": 0.0052250000000000005,
          "guardrails": {
            "flagged": false
          }
        },
        "score": 0.9166666666666666,
        "success": false,
        "testCase": {
          "vars": {
            "topic": "How to deploy a Node.js app in 5 minutes",
            "archetype": "howto"
          },
          "assert": [
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return (\n    Array.isArray(script.scenes) &&\n    script.scenes.length >= 3 &&\n    script.scenes.length <= 7\n  );\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 80 && wordCount <= 200;\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return (script.scenes || []).every((scene) =>\n    typeof scene.visualDirection === 'string' && scene.visualDirection.trim().length > 5\n  );\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean)\n    .join(' ');\n  const hasEmoji = /\\p{Extended_Pictographic}/u.test(spoken);\n  const hasMarkdown = /[`*_]/.test(spoken) || /\\[(.+?)\\]\\((.+?)\\)/.test(spoken);\n  const hasHashtag = /(^|\\s)#\\w+/.test(spoken);\n  return !hasEmoji && !hasMarkdown && !hasHashtag;\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return typeof script.reasoning === 'string' && script.reasoning.trim().length > 10;\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "llm-rubric",
              "value": "The script has clear, sequential steps that are easy to follow.\nEach step should be actionable and specific.\n",
              "threshold": 0.8,
              "weight": 2
            },
            {
              "type": "llm-rubric",
              "value": "The visual directions show what the viewer should be doing at each step.\nThis could include screen recordings, terminal commands, or UI interactions.\n",
              "threshold": 0.8,
              "weight": 1
            }
          ],
          "options": {
            "provider": "openai:gpt-4o-mini"
          },
          "metadata": {}
        },
        "testIdx": 4,
        "vars": {
          "topic": "How to deploy a Node.js app in 5 minutes",
          "archetype": "howto"
        },
        "metadata": {
          "_promptfooFileMetadata": {}
        },
        "failureReason": 1
      },
      {
        "cost": 0.004690000000000001,
        "error": "The script introduces the myth about needing a computer science degree and provides evidence and examples to debunk it, but does not use the required structure of 'Myth: X / Reality: Y'.",
        "gradingResult": {
          "pass": false,
          "score": 0.6666666666666666,
          "reason": "The script introduces the myth about needing a computer science degree and provides evidence and examples to debunk it, but does not use the required structure of 'Myth: X / Reality: Y'.",
          "namedScores": {},
          "tokensUsed": {
            "total": 1110,
            "prompt": 996,
            "completion": 114,
            "cached": 0,
            "numRequests": 2
          },
          "componentResults": [
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return (\n    Array.isArray(script.scenes) &&\n    script.scenes.length >= 3 &&\n    script.scenes.length <= 7\n  );\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": false,
              "score": 0,
              "reason": "Custom function returned false\ntry {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 80 && wordCount <= 200;\n} catch { return false; }",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 80 && wordCount <= 200;\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return (script.scenes || []).every((scene) =>\n    typeof scene.visualDirection === 'string' && scene.visualDirection.trim().length > 5\n  );\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean)\n    .join(' ');\n  const hasEmoji = /\\p{Extended_Pictographic}/u.test(spoken);\n  const hasMarkdown = /[`*_]/.test(spoken) || /\\[(.+?)\\]\\((.+?)\\)/.test(spoken);\n  const hasHashtag = /(^|\\s)#\\w+/.test(spoken);\n  return !hasEmoji && !hasMarkdown && !hasHashtag;\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": false,
              "score": 0,
              "reason": "Custom function returned false\ntry {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return typeof script.reasoning === 'string' && script.reasoning.trim().length > 10;\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "The script clearly states the myth, then definitively debunks it.\nThe structure should be \"Myth: X / Reality: Y\" or similar.\n",
                "threshold": 0.8,
                "weight": 2
              },
              "pass": false,
              "score": 0.5,
              "reason": "The script introduces the myth about needing a computer science degree and provides evidence and examples to debunk it, but does not use the required structure of 'Myth: X / Reality: Y'.",
              "tokensUsed": {
                "total": 559,
                "prompt": 502,
                "completion": 57,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"Think you need a computer science degree to code? Let's bust that myth.\\\",\\\"visualDirection\\\":\\\"Start with a close-up of a person looking puzzled at a computer screen.\\\",\\\"mood\\\":\\\"Curious\\\"},{\\\"text\\\":\\\"Meet Alex, self-taught developer, now working at a tech startup!\\\",\\\"visualDirection\\\":\\\"Cut to Alex working confidently on a laptop, with code visible.\\\",\\\"mood\\\":\\\"Inspirational\\\"},{\\\"text\\\":\\\"Alex learned through online courses and hands-on projects.\\\",\\\"visualDirection\\\":\\\"Show quick clips of online tutorials and Alex building projects.\\\",\\\"mood\\\":\\\"Motivational\\\"},{\\\"text\\\":\\\"Many top companies value skills over degrees. Google, Apple, and more!\\\",\\\"visualDirection\\\":\\\"Display logos of top tech companies with emphasis on skills.\\\",\\\"mood\\\":\\\"Empowering\\\"},{\\\"text\\\":\\\"So, are you ready to start your coding journey?\\\",\\\"visualDirection\\\":\\\"End with a shot of a keyboard with fingers ready to type.\\\",\\\"mood\\\":\\\"Encouraging\\\"}],\\\"reasoning\\\":\\\"The video aims to debunk the myth that a computer science degree is necessary to become a developer. By showcasing a real example and mentioning top companies that prioritize skills, it encourages viewers to pursue coding through alternative educational paths.\\\",\\\"title\\\":\\\"Do You Really Need a CS Degree to Code?\\\",\\\"hook\\\":\\\"Think you need a computer science degree to code?\\\",\\\"cta\\\":\\\"Start learning today, no degree needed.\\\",\\\"hashtags\\\":[\\\"#CodingMyth\\\",\\\"#LearnToCode\\\",\\\"#TechCareer\\\"]}\\n</Output>\\n<Rubric>\\nThe script clearly states the myth, then definitively debunks it.\\nThe structure should be \\\"Myth: X / Reality: Y\\\" or similar.\\n\\n</Rubric>\"}]"
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "The debunking includes evidence, examples, or statistics.\nIt's not just opinion; there should be factual backing.\n",
                "threshold": 0.7,
                "weight": 1
              },
              "pass": true,
              "score": 1,
              "reason": "The output provides an example of Alex, a self-taught developer, and mentions top companies like Google and Apple that prioritize skills over degrees, which adds credibility to the claim.",
              "tokensUsed": {
                "total": 551,
                "prompt": 494,
                "completion": 57,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"Think you need a computer science degree to code? Let's bust that myth.\\\",\\\"visualDirection\\\":\\\"Start with a close-up of a person looking puzzled at a computer screen.\\\",\\\"mood\\\":\\\"Curious\\\"},{\\\"text\\\":\\\"Meet Alex, self-taught developer, now working at a tech startup!\\\",\\\"visualDirection\\\":\\\"Cut to Alex working confidently on a laptop, with code visible.\\\",\\\"mood\\\":\\\"Inspirational\\\"},{\\\"text\\\":\\\"Alex learned through online courses and hands-on projects.\\\",\\\"visualDirection\\\":\\\"Show quick clips of online tutorials and Alex building projects.\\\",\\\"mood\\\":\\\"Motivational\\\"},{\\\"text\\\":\\\"Many top companies value skills over degrees. Google, Apple, and more!\\\",\\\"visualDirection\\\":\\\"Display logos of top tech companies with emphasis on skills.\\\",\\\"mood\\\":\\\"Empowering\\\"},{\\\"text\\\":\\\"So, are you ready to start your coding journey?\\\",\\\"visualDirection\\\":\\\"End with a shot of a keyboard with fingers ready to type.\\\",\\\"mood\\\":\\\"Encouraging\\\"}],\\\"reasoning\\\":\\\"The video aims to debunk the myth that a computer science degree is necessary to become a developer. By showcasing a real example and mentioning top companies that prioritize skills, it encourages viewers to pursue coding through alternative educational paths.\\\",\\\"title\\\":\\\"Do You Really Need a CS Degree to Code?\\\",\\\"hook\\\":\\\"Think you need a computer science degree to code?\\\",\\\"cta\\\":\\\"Start learning today, no degree needed.\\\",\\\"hashtags\\\":[\\\"#CodingMyth\\\",\\\"#LearnToCode\\\",\\\"#TechCareer\\\"]}\\n</Output>\\n<Rubric>\\nThe debunking includes evidence, examples, or statistics.\\nIt's not just opinion; there should be factual backing.\\n\\n</Rubric>\"}]"
              }
            }
          ]
        },
        "id": "9b63af2c-ab5e-4393-b907-b3a66c1a0ef0",
        "latencyMs": 6303,
        "namedScores": {},
        "prompt": {
          "raw": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"You need a CS degree to be a developer\"\n\nFORMAT: myth\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Use short sentences (<=15 words) and one idea per sentence.\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n\n\n\n\n\nStart with the myth, then reveal the reality with evidence.\n\n\n\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n",
          "label": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"{{ topic }}\"\n\nFORMAT: {{ archetype }}\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Use short sentences (<=15 words) and one idea per sentence.\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n\n{% if archetype == \"listicle\" %}\nStructure as a numbered list with a hook, clear items, and a call-to-action.\n{% endif %}\n{% if archetype == \"versus\" %}\nPresent a balanced comparison with a clear recommendation at the end.\n{% endif %}\n{% if archetype == \"howto\" %}\nGive step-by-step instructions that are easy to follow.\n{% endif %}\n{% if archetype == \"myth\" %}\nStart with the myth, then reveal the reality with evidence.\n{% endif %}\n{% if archetype == \"story\" %}\nUse narrative structure: setup, conflict, resolution.\n{% endif %}\n{% if archetype == \"hot-take\" %}\nLead with a provocative opinion, then back it up with reasoning.\n{% endif %}\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n"
        },
        "promptId": "a3df67e6ef678c5736d74fe2db715f65a7b49b042e23a17fda9e6b7bcc746265",
        "promptIdx": 0,
        "provider": {
          "id": "openai:gpt-4o",
          "label": ""
        },
        "response": {
          "output": "{\n  \"scenes\": [\n    {\n      \"text\": \"Think you need a computer science degree to code? Let's bust that myth.\",\n      \"visualDirection\": \"Start with a close-up of a person looking puzzled at a computer screen.\",\n      \"mood\": \"Curious\"\n    },\n    {\n      \"text\": \"Meet Alex, self-taught developer, now working at a tech startup!\",\n      \"visualDirection\": \"Cut to Alex working confidently on a laptop, with code visible.\",\n      \"mood\": \"Inspirational\"\n    },\n    {\n      \"text\": \"Alex learned through online courses and hands-on projects.\",\n      \"visualDirection\": \"Show quick clips of online tutorials and Alex building projects.\",\n      \"mood\": \"Motivational\"\n    },\n    {\n      \"text\": \"Many top companies value skills over degrees. Google, Apple, and more!\",\n      \"visualDirection\": \"Display logos of top tech companies with emphasis on skills.\",\n      \"mood\": \"Empowering\"\n    },\n    {\n      \"text\": \"So, are you ready to start your coding journey?\",\n      \"visualDirection\": \"End with a shot of a keyboard with fingers ready to type.\",\n      \"mood\": \"Encouraging\"\n    }\n  ],\n  \"reasoning\": \"The video aims to debunk the myth that a computer science degree is necessary to become a developer. By showcasing a real example and mentioning top companies that prioritize skills, it encourages viewers to pursue coding through alternative educational paths.\",\n  \"title\": \"Do You Really Need a CS Degree to Code?\",\n  \"hook\": \"Think you need a computer science degree to code?\",\n  \"cta\": \"Start learning today, no degree needed.\",\n  \"hashtags\": [\"#CodingMyth\", \"#LearnToCode\", \"#TechCareer\"]\n}",
          "tokenUsage": {
            "total": 757,
            "prompt": 384,
            "completion": 373,
            "numRequests": 1,
            "completionDetails": {
              "reasoning": 0,
              "acceptedPrediction": 0,
              "rejectedPrediction": 0
            }
          },
          "cached": false,
          "latencyMs": 6303,
          "finishReason": "stop",
          "cost": 0.004690000000000001,
          "guardrails": {
            "flagged": false
          }
        },
        "score": 0.6666666666666666,
        "success": false,
        "testCase": {
          "vars": {
            "topic": "You need a CS degree to be a developer",
            "archetype": "myth"
          },
          "assert": [
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return (\n    Array.isArray(script.scenes) &&\n    script.scenes.length >= 3 &&\n    script.scenes.length <= 7\n  );\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 80 && wordCount <= 200;\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return (script.scenes || []).every((scene) =>\n    typeof scene.visualDirection === 'string' && scene.visualDirection.trim().length > 5\n  );\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean)\n    .join(' ');\n  const hasEmoji = /\\p{Extended_Pictographic}/u.test(spoken);\n  const hasMarkdown = /[`*_]/.test(spoken) || /\\[(.+?)\\]\\((.+?)\\)/.test(spoken);\n  const hasHashtag = /(^|\\s)#\\w+/.test(spoken);\n  return !hasEmoji && !hasMarkdown && !hasHashtag;\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return typeof script.reasoning === 'string' && script.reasoning.trim().length > 10;\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "llm-rubric",
              "value": "The script clearly states the myth, then definitively debunks it.\nThe structure should be \"Myth: X / Reality: Y\" or similar.\n",
              "threshold": 0.8,
              "weight": 2
            },
            {
              "type": "llm-rubric",
              "value": "The debunking includes evidence, examples, or statistics.\nIt's not just opinion; there should be factual backing.\n",
              "threshold": 0.7,
              "weight": 1
            }
          ],
          "options": {
            "provider": "openai:gpt-4o-mini"
          },
          "metadata": {}
        },
        "testIdx": 5,
        "vars": {
          "topic": "You need a CS degree to be a developer",
          "archetype": "myth"
        },
        "metadata": {
          "_promptfooFileMetadata": {}
        },
        "failureReason": 1
      }
    ],
    "stats": {
      "successes": 0,
      "failures": 6,
      "errors": 0,
      "tokenUsage": {
        "prompt": 2309,
        "completion": 2386,
        "cached": 0,
        "total": 4695,
        "numRequests": 6,
        "completionDetails": {
          "reasoning": 0,
          "acceptedPrediction": 0,
          "rejectedPrediction": 0
        },
        "assertions": {
          "total": 8676,
          "prompt": 7917,
          "completion": 759,
          "cached": 0,
          "numRequests": 0,
          "completionDetails": {
            "reasoning": 0,
            "acceptedPrediction": 0,
            "rejectedPrediction": 0
          }
        }
      },
      "durationMs": 59413
    }
  },
  "config": {
    "tags": {},
    "description": "content-machine script generation quality evaluation",
    "prompts": [
      "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"{{ topic }}\"\n\nFORMAT: {{ archetype }}\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Use short sentences (<=15 words) and one idea per sentence.\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n\n{% if archetype == \"listicle\" %}\nStructure as a numbered list with a hook, clear items, and a call-to-action.\n{% endif %}\n{% if archetype == \"versus\" %}\nPresent a balanced comparison with a clear recommendation at the end.\n{% endif %}\n{% if archetype == \"howto\" %}\nGive step-by-step instructions that are easy to follow.\n{% endif %}\n{% if archetype == \"myth\" %}\nStart with the myth, then reveal the reality with evidence.\n{% endif %}\n{% if archetype == \"story\" %}\nUse narrative structure: setup, conflict, resolution.\n{% endif %}\n{% if archetype == \"hot-take\" %}\nLead with a provocative opinion, then back it up with reasoning.\n{% endif %}\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n"
    ],
    "providers": [
      {
        "id": "openai:gpt-4o",
        "config": {
          "temperature": 0.7,
          "response_format": {
            "type": "json_object"
          }
        }
      }
    ],
    "tests": [
      {
        "vars": {
          "topic": "5 JavaScript tips every developer should know",
          "archetype": "listicle"
        },
        "assert": [
          {
            "type": "llm-rubric",
            "value": "The script opens with an attention-grabbing hook that would stop a TikTok user from scrolling.\nThe first sentence should be surprising, controversial, or promise immediate value.\nScore 0 if it's a generic introduction like \"In this video...\" or \"Today we'll cover...\".\n",
            "threshold": 0.7,
            "weight": 2
          },
          {
            "type": "llm-rubric",
            "value": "The language is casual, conversational, and suitable for TikTok/Reels/Shorts.\nNo corporate jargon, no formal academic language, no \"as a developer\" phrases.\nShould sound like a friend giving advice, not a textbook.\n",
            "threshold": 0.8,
            "weight": 1
          },
          {
            "type": "llm-rubric",
            "value": "Each scene has a specific, filmable visual description.\nVisual directions should describe what the viewer will SEE on screen.\nAvoid abstract concepts that cannot be filmed (like \"efficiency\" or \"code quality\").\n",
            "threshold": 0.8,
            "weight": 1
          },
          {
            "type": "llm-rubric",
            "value": "For a listicle archetype, the script should have a clear numbered structure.\nEach tip should be distinct and actionable.\nThe list should feel complete, not like it was cut off.\n",
            "threshold": 0.8,
            "weight": 1
          }
        ]
      },
      {
        "vars": {
          "topic": "Redis vs PostgreSQL for caching",
          "archetype": "versus"
        },
        "assert": [
          {
            "type": "llm-rubric",
            "value": "The script opens with an attention-grabbing hook.\nFor a versus video, this might be a provocative statement like \"You're using the wrong database\"\nor a relatable problem statement.\n",
            "threshold": 0.7,
            "weight": 2
          },
          {
            "type": "llm-rubric",
            "value": "For a versus archetype, the script should clearly compare both options.\nIt should present pros and cons of each, not just favor one.\nThe comparison should be fair and technically accurate.\n",
            "threshold": 0.8,
            "weight": 2
          },
          {
            "type": "llm-rubric",
            "value": "The script provides a clear recommendation or decision framework at the end.\nViewers should know when to use each option.\n",
            "threshold": 0.7,
            "weight": 1
          }
        ]
      },
      {
        "vars": {
          "topic": "How I learned React in 2 weeks",
          "archetype": "story"
        },
        "assert": [
          {
            "type": "llm-rubric",
            "value": "The script has a narrative arc: setup, challenge, resolution.\nIt should feel like a personal story, not a tutorial.\n",
            "threshold": 0.8,
            "weight": 2
          },
          {
            "type": "llm-rubric",
            "value": "The language uses first-person perspective and includes emotional elements.\nThe viewer should feel connected to the storyteller.\n",
            "threshold": 0.7,
            "weight": 1
          }
        ]
      },
      {
        "vars": {
          "topic": "TypeScript is overrated",
          "archetype": "hot-take"
        },
        "assert": [
          {
            "type": "llm-rubric",
            "value": "The script opens with a bold, controversial statement that will spark debate.\nIt should immediately make viewers want to comment (agree or disagree).\n",
            "threshold": 0.8,
            "weight": 2
          },
          {
            "type": "llm-rubric",
            "value": "Despite being a hot take, the script provides actual reasoning and evidence.\nIt's not just rage bait; there should be substance behind the opinion.\n",
            "threshold": 0.7,
            "weight": 2
          }
        ]
      },
      {
        "vars": {
          "topic": "How to deploy a Node.js app in 5 minutes",
          "archetype": "howto"
        },
        "assert": [
          {
            "type": "llm-rubric",
            "value": "The script has clear, sequential steps that are easy to follow.\nEach step should be actionable and specific.\n",
            "threshold": 0.8,
            "weight": 2
          },
          {
            "type": "llm-rubric",
            "value": "The visual directions show what the viewer should be doing at each step.\nThis could include screen recordings, terminal commands, or UI interactions.\n",
            "threshold": 0.8,
            "weight": 1
          }
        ]
      },
      {
        "vars": {
          "topic": "You need a CS degree to be a developer",
          "archetype": "myth"
        },
        "assert": [
          {
            "type": "llm-rubric",
            "value": "The script clearly states the myth, then definitively debunks it.\nThe structure should be \"Myth: X / Reality: Y\" or similar.\n",
            "threshold": 0.8,
            "weight": 2
          },
          {
            "type": "llm-rubric",
            "value": "The debunking includes evidence, examples, or statistics.\nIt's not just opinion; there should be factual backing.\n",
            "threshold": 0.7,
            "weight": 1
          }
        ]
      }
    ],
    "scenarios": [],
    "env": {},
    "defaultTest": {
      "options": {
        "provider": "openai:gpt-4o-mini"
      },
      "assert": [
        {
          "type": "javascript",
          "value": "try {\n  const script = JSON.parse(output);\n  return (\n    Array.isArray(script.scenes) &&\n    script.scenes.length >= 3 &&\n    script.scenes.length <= 7\n  );\n} catch { return false; }\n",
          "weight": 2
        },
        {
          "type": "javascript",
          "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 80 && wordCount <= 200;\n} catch { return false; }\n",
          "weight": 1
        },
        {
          "type": "javascript",
          "value": "try {\n  const script = JSON.parse(output);\n  return (script.scenes || []).every((scene) =>\n    typeof scene.visualDirection === 'string' && scene.visualDirection.trim().length > 5\n  );\n} catch { return false; }\n",
          "weight": 1
        },
        {
          "type": "javascript",
          "value": "try {\n  const script = JSON.parse(output);\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean)\n    .join(' ');\n  const hasEmoji = /\\p{Extended_Pictographic}/u.test(spoken);\n  const hasMarkdown = /[`*_]/.test(spoken) || /\\[(.+?)\\]\\((.+?)\\)/.test(spoken);\n  const hasHashtag = /(^|\\s)#\\w+/.test(spoken);\n  return !hasEmoji && !hasMarkdown && !hasHashtag;\n} catch { return false; }\n",
          "weight": 2
        },
        {
          "type": "javascript",
          "value": "try {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }\n",
          "weight": 2
        },
        {
          "type": "javascript",
          "value": "try {\n  const script = JSON.parse(output);\n  return typeof script.reasoning === 'string' && script.reasoning.trim().length > 10;\n} catch { return false; }\n",
          "weight": 1
        }
      ],
      "vars": {},
      "metadata": {}
    },
    "outputPath": [],
    "extensions": [],
    "metadata": {},
    "evaluateOptions": {}
  },
  "shareableUrl": null,
  "metadata": {
    "promptfooVersion": "0.120.11",
    "nodeVersion": "v22.16.0",
    "platform": "win32",
    "arch": "x64",
    "exportedAt": "2026-01-10T08:42:03.537Z",
    "evaluationCreatedAt": "2026-01-10T08:40:08.298Z"
  }
}
