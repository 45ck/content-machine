{
  "evalId": "eval-I4S-2026-01-10T09:30:43",
  "results": {
    "version": 3,
    "timestamp": "2026-01-10T09:30:43.742Z",
    "prompts": [
      {
        "raw": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"{{ topic }}\"\n\nFORMAT: {{ archetype }}\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Total spoken word count must be between 90-150 words.\n- Use short sentences (<=15 words) and one idea per sentence.\n- Each scene should be 2 sentences and ~22-30 words (minimum 20 words per scene).\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n- Scene 1 must continue after the hook with NEW information (no restating or paraphrasing the hook).\n- Each scene text must be at least 20 words.\n- Double-check total word count before responding.\n- Hook must be a statement (no question mark).\n\n{% if archetype == \"listicle\" %}\nStructure as a numbered list with a hook, clear items, and a call-to-action.\nPrefix each point with an explicit number label (e.g., \"Tip 1:\", \"2)\", \"Number 3:\").\n{% endif %}\n{% if archetype == \"versus\" %}\nPresent a balanced comparison with a clear recommendation at the end.\nThe hook should be a bold statement, not a question.\n{% endif %}\n{% if archetype == \"howto\" %}\nGive step-by-step instructions that are easy to follow.\n{% endif %}\n{% if archetype == \"myth\" %}\nStart with the myth, then reveal the reality with evidence.\nUse explicit \"Myth: X\" and \"Reality: Y\" phrasing in scene text.\n{% endif %}\n{% if archetype == \"story\" %}\nUse narrative structure: setup, conflict, resolution.\n{% endif %}\n{% if archetype == \"hot-take\" %}\nLead with a provocative opinion, then back it up with reasoning.\n{% endif %}\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n- Each scene text must be at least 20 words.\n- Hook must be a statement (no question mark).\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n",
        "label": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"{{ topic }}\"\n\nFORMAT: {{ archetype }}\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Total spoken word count must be between 90-150 words.\n- Use short sentences (<=15 words) and one idea per sentence.\n- Each scene should be 2 sentences and ~22-30 words (minimum 20 words per scene).\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n- Scene 1 must continue after the hook with NEW information (no restating or paraphrasing the hook).\n- Each scene text must be at least 20 words.\n- Double-check total word count before responding.\n- Hook must be a statement (no question mark).\n\n{% if archetype == \"listicle\" %}\nStructure as a numbered list with a hook, clear items, and a call-to-action.\nPrefix each point with an explicit number label (e.g., \"Tip 1:\", \"2)\", \"Number 3:\").\n{% endif %}\n{% if archetype == \"versus\" %}\nPresent a balanced comparison with a clear recommendation at the end.\nThe hook should be a bold statement, not a question.\n{% endif %}\n{% if archetype == \"howto\" %}\nGive step-by-step instructions that are easy to follow.\n{% endif %}\n{% if archetype == \"myth\" %}\nStart with the myth, then reveal the reality with evidence.\nUse explicit \"Myth: X\" and \"Reality: Y\" phrasing in scene text.\n{% endif %}\n{% if archetype == \"story\" %}\nUse narrative structure: setup, conflict, resolution.\n{% endif %}\n{% if archetype == \"hot-take\" %}\nLead with a provocative opinion, then back it up with reasoning.\n{% endif %}\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n- Each scene text must be at least 20 words.\n- Hook must be a statement (no question mark).\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n",
        "id": "3a2330721e33f906bebc9d49df16221c36cfd3cebbbc91ec115733487d847736",
        "provider": "openai:gpt-4o",
        "metrics": {
          "score": 5.785714285714286,
          "testPassCount": 4,
          "testFailCount": 2,
          "testErrorCount": 0,
          "assertPassCount": 49,
          "assertFailCount": 2,
          "totalLatencyMs": 38309,
          "tokenUsage": {
            "prompt": 3054,
            "completion": 2606,
            "cached": 0,
            "total": 5660,
            "numRequests": 6,
            "completionDetails": {
              "reasoning": 0,
              "acceptedPrediction": 0,
              "rejectedPrediction": 0
            },
            "assertions": {
              "total": 9110,
              "prompt": 8389,
              "completion": 721,
              "cached": 0,
              "numRequests": 0,
              "completionDetails": {
                "reasoning": 0,
                "acceptedPrediction": 0,
                "rejectedPrediction": 0
              }
            }
          },
          "namedScores": {},
          "namedScoresCount": {},
          "cost": 0.033695
        }
      }
    ],
    "results": [
      {
        "cost": 0.0052875000000000005,
        "error": "Custom function returned false\ntry {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 90 && wordCount <= 150;\n} catch { return false; }",
        "gradingResult": {
          "pass": false,
          "score": 0.9285714285714286,
          "reason": "Custom function returned false\ntry {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 90 && wordCount <= 150;\n} catch { return false; }",
          "namedScores": {},
          "tokensUsed": {
            "total": 2328,
            "prompt": 2131,
            "completion": 197,
            "cached": 0,
            "numRequests": 4
          },
          "componentResults": [
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return (\n    Array.isArray(script.scenes) &&\n    script.scenes.length >= 3 &&\n    script.scenes.length <= 7\n  );\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": false,
              "score": 0,
              "reason": "Custom function returned false\ntry {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 90 && wordCount <= 150;\n} catch { return false; }",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 90 && wordCount <= 150;\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return (script.scenes || []).every((scene) =>\n    typeof scene.visualDirection === 'string' && scene.visualDirection.trim().length > 5\n  );\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean)\n    .join(' ');\n  const hasEmoji = /\\p{Extended_Pictographic}/u.test(spoken);\n  const hasMarkdown = /[`*_]/.test(spoken) || /\\[(.+?)\\]\\((.+?)\\)/.test(spoken);\n  const hasHashtag = /(^|\\s)#\\w+/.test(spoken);\n  return !hasEmoji && !hasMarkdown && !hasHashtag;\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return typeof script.reasoning === 'string' && script.reasoning.trim().length > 10;\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "The script opens with an attention-grabbing hook that would stop a TikTok user from scrolling.\nThe first sentence should be surprising, controversial, or promise immediate value.\nScore 0 if it's a generic introduction like \"In this video...\" or \"Today we'll cover...\".\n",
                "threshold": 0.7,
                "weight": 2
              },
              "pass": true,
              "score": 1,
              "reason": "The hook 'These five JavaScript tips will change the way you code.' is an attention-grabbing statement that promises immediate value to the viewer.",
              "tokensUsed": {
                "total": 588,
                "prompt": 542,
                "completion": 46,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"Tip number one: Use 'const' and 'let' instead of 'var'. 'Const' for constants, 'let' for variables.\\\",\\\"visualDirection\\\":\\\"Show 'const' and 'let' replacing 'var' in code editor.\\\",\\\"mood\\\":\\\"informative\\\"},{\\\"text\\\":\\\"Number two: Arrow functions simplify code. They're shorter and automatically bind 'this'.\\\",\\\"visualDirection\\\":\\\"Show transformation from traditional function to arrow function.\\\",\\\"mood\\\":\\\"energetic\\\"},{\\\"text\\\":\\\"Tip three: Use template literals for strings. They're cleaner and support multi-line without hassle.\\\",\\\"visualDirection\\\":\\\"Display a multi-line string with template literals.\\\",\\\"mood\\\":\\\"relaxed\\\"},{\\\"text\\\":\\\"Four: Destructuring makes extracting values from arrays and objects super easy.\\\",\\\"visualDirection\\\":\\\"Show destructuring of an array and an object.\\\",\\\"mood\\\":\\\"engaging\\\"},{\\\"text\\\":\\\"Finally, use async/await for cleaner asynchronous code. It's easier to read and write.\\\",\\\"visualDirection\\\":\\\"Show async/await replacing promise chaining.\\\",\\\"mood\\\":\\\"uplifting\\\"}],\\\"reasoning\\\":\\\"This script provides a quick and engaging overview of essential JavaScript tips for developers using a listicle format. Each tip is concise, easy to understand, and visually supported to enhance learning. The mood varies to maintain viewer interest and engagement.\\\",\\\"title\\\":\\\"5 JavaScript Tips Every Developer Should Know\\\",\\\"hook\\\":\\\"These five JavaScript tips will change the way you code.\\\",\\\"cta\\\":\\\"Follow for more coding tips and tricks.\\\",\\\"hashtags\\\":[\\\"#JavaScript\\\",\\\"#Coding\\\",\\\"#WebDevelopment\\\",\\\"#Programming\\\"]}\\n</Output>\\n<Rubric>\\nThe script opens with an attention-grabbing hook that would stop a TikTok user from scrolling.\\nThe first sentence should be surprising, controversial, or promise immediate value.\\nScore 0 if it's a generic introduction like \\\"In this video...\\\" or \\\"Today we'll cover...\\\".\\n\\n</Rubric>\"}]"
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "The language is casual, conversational, and suitable for TikTok/Reels/Shorts.\nNo corporate jargon, no formal academic language, no \"as a developer\" phrases.\nShould sound like a friend giving advice, not a textbook.\n",
                "threshold": 0.8,
                "weight": 1
              },
              "pass": true,
              "score": 1,
              "reason": "The language used is informal, with phrases like 'super easy' and 'change the way you code', which are conversational and suitable for TikTok/Reels/Shorts.",
              "tokensUsed": {
                "total": 587,
                "prompt": 535,
                "completion": 52,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"Tip number one: Use 'const' and 'let' instead of 'var'. 'Const' for constants, 'let' for variables.\\\",\\\"visualDirection\\\":\\\"Show 'const' and 'let' replacing 'var' in code editor.\\\",\\\"mood\\\":\\\"informative\\\"},{\\\"text\\\":\\\"Number two: Arrow functions simplify code. They're shorter and automatically bind 'this'.\\\",\\\"visualDirection\\\":\\\"Show transformation from traditional function to arrow function.\\\",\\\"mood\\\":\\\"energetic\\\"},{\\\"text\\\":\\\"Tip three: Use template literals for strings. They're cleaner and support multi-line without hassle.\\\",\\\"visualDirection\\\":\\\"Display a multi-line string with template literals.\\\",\\\"mood\\\":\\\"relaxed\\\"},{\\\"text\\\":\\\"Four: Destructuring makes extracting values from arrays and objects super easy.\\\",\\\"visualDirection\\\":\\\"Show destructuring of an array and an object.\\\",\\\"mood\\\":\\\"engaging\\\"},{\\\"text\\\":\\\"Finally, use async/await for cleaner asynchronous code. It's easier to read and write.\\\",\\\"visualDirection\\\":\\\"Show async/await replacing promise chaining.\\\",\\\"mood\\\":\\\"uplifting\\\"}],\\\"reasoning\\\":\\\"This script provides a quick and engaging overview of essential JavaScript tips for developers using a listicle format. Each tip is concise, easy to understand, and visually supported to enhance learning. The mood varies to maintain viewer interest and engagement.\\\",\\\"title\\\":\\\"5 JavaScript Tips Every Developer Should Know\\\",\\\"hook\\\":\\\"These five JavaScript tips will change the way you code.\\\",\\\"cta\\\":\\\"Follow for more coding tips and tricks.\\\",\\\"hashtags\\\":[\\\"#JavaScript\\\",\\\"#Coding\\\",\\\"#WebDevelopment\\\",\\\"#Programming\\\"]}\\n</Output>\\n<Rubric>\\nThe language is casual, conversational, and suitable for TikTok/Reels/Shorts.\\nNo corporate jargon, no formal academic language, no \\\"as a developer\\\" phrases.\\nShould sound like a friend giving advice, not a textbook.\\n\\n</Rubric>\"}]"
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "Each scene has a specific, filmable visual description.\nVisual directions should describe what the viewer will SEE on screen.\nAvoid abstract concepts that cannot be filmed (like \"efficiency\" or \"code quality\").\n",
                "threshold": 0.8,
                "weight": 1
              },
              "pass": true,
              "score": 1,
              "reason": "Each scene contains a clear visual direction that specifies what will be shown on screen, such as code transformations, display of strings, and illustrations of destructuring.",
              "tokensUsed": {
                "total": 577,
                "prompt": 529,
                "completion": 48,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"Tip number one: Use 'const' and 'let' instead of 'var'. 'Const' for constants, 'let' for variables.\\\",\\\"visualDirection\\\":\\\"Show 'const' and 'let' replacing 'var' in code editor.\\\",\\\"mood\\\":\\\"informative\\\"},{\\\"text\\\":\\\"Number two: Arrow functions simplify code. They're shorter and automatically bind 'this'.\\\",\\\"visualDirection\\\":\\\"Show transformation from traditional function to arrow function.\\\",\\\"mood\\\":\\\"energetic\\\"},{\\\"text\\\":\\\"Tip three: Use template literals for strings. They're cleaner and support multi-line without hassle.\\\",\\\"visualDirection\\\":\\\"Display a multi-line string with template literals.\\\",\\\"mood\\\":\\\"relaxed\\\"},{\\\"text\\\":\\\"Four: Destructuring makes extracting values from arrays and objects super easy.\\\",\\\"visualDirection\\\":\\\"Show destructuring of an array and an object.\\\",\\\"mood\\\":\\\"engaging\\\"},{\\\"text\\\":\\\"Finally, use async/await for cleaner asynchronous code. It's easier to read and write.\\\",\\\"visualDirection\\\":\\\"Show async/await replacing promise chaining.\\\",\\\"mood\\\":\\\"uplifting\\\"}],\\\"reasoning\\\":\\\"This script provides a quick and engaging overview of essential JavaScript tips for developers using a listicle format. Each tip is concise, easy to understand, and visually supported to enhance learning. The mood varies to maintain viewer interest and engagement.\\\",\\\"title\\\":\\\"5 JavaScript Tips Every Developer Should Know\\\",\\\"hook\\\":\\\"These five JavaScript tips will change the way you code.\\\",\\\"cta\\\":\\\"Follow for more coding tips and tricks.\\\",\\\"hashtags\\\":[\\\"#JavaScript\\\",\\\"#Coding\\\",\\\"#WebDevelopment\\\",\\\"#Programming\\\"]}\\n</Output>\\n<Rubric>\\nEach scene has a specific, filmable visual description.\\nVisual directions should describe what the viewer will SEE on screen.\\nAvoid abstract concepts that cannot be filmed (like \\\"efficiency\\\" or \\\"code quality\\\").\\n\\n</Rubric>\"}]"
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "For a listicle archetype, the script should have a clear numbered structure.\nEach tip should be distinct and actionable.\nThe list should feel complete, not like it was cut off.\n",
                "threshold": 0.8,
                "weight": 1
              },
              "pass": true,
              "score": 1,
              "reason": "The output presents five distinct tips in a clear numbered format, ensuring each tip is distinct and actionable. The structure follows a listicle archetype, making it feel complete.",
              "tokensUsed": {
                "total": 576,
                "prompt": 525,
                "completion": 51,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"Tip number one: Use 'const' and 'let' instead of 'var'. 'Const' for constants, 'let' for variables.\\\",\\\"visualDirection\\\":\\\"Show 'const' and 'let' replacing 'var' in code editor.\\\",\\\"mood\\\":\\\"informative\\\"},{\\\"text\\\":\\\"Number two: Arrow functions simplify code. They're shorter and automatically bind 'this'.\\\",\\\"visualDirection\\\":\\\"Show transformation from traditional function to arrow function.\\\",\\\"mood\\\":\\\"energetic\\\"},{\\\"text\\\":\\\"Tip three: Use template literals for strings. They're cleaner and support multi-line without hassle.\\\",\\\"visualDirection\\\":\\\"Display a multi-line string with template literals.\\\",\\\"mood\\\":\\\"relaxed\\\"},{\\\"text\\\":\\\"Four: Destructuring makes extracting values from arrays and objects super easy.\\\",\\\"visualDirection\\\":\\\"Show destructuring of an array and an object.\\\",\\\"mood\\\":\\\"engaging\\\"},{\\\"text\\\":\\\"Finally, use async/await for cleaner asynchronous code. It's easier to read and write.\\\",\\\"visualDirection\\\":\\\"Show async/await replacing promise chaining.\\\",\\\"mood\\\":\\\"uplifting\\\"}],\\\"reasoning\\\":\\\"This script provides a quick and engaging overview of essential JavaScript tips for developers using a listicle format. Each tip is concise, easy to understand, and visually supported to enhance learning. The mood varies to maintain viewer interest and engagement.\\\",\\\"title\\\":\\\"5 JavaScript Tips Every Developer Should Know\\\",\\\"hook\\\":\\\"These five JavaScript tips will change the way you code.\\\",\\\"cta\\\":\\\"Follow for more coding tips and tricks.\\\",\\\"hashtags\\\":[\\\"#JavaScript\\\",\\\"#Coding\\\",\\\"#WebDevelopment\\\",\\\"#Programming\\\"]}\\n</Output>\\n<Rubric>\\nFor a listicle archetype, the script should have a clear numbered structure.\\nEach tip should be distinct and actionable.\\nThe list should feel complete, not like it was cut off.\\n\\n</Rubric>\"}]"
              }
            }
          ]
        },
        "id": "9e835df1-3d3e-42d2-b423-c8feed5d905e",
        "latencyMs": 4702,
        "namedScores": {},
        "prompt": {
          "raw": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"5 JavaScript tips every developer should know\"\n\nFORMAT: listicle\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Total spoken word count must be between 90-150 words.\n- Use short sentences (<=15 words) and one idea per sentence.\n- Each scene should be 2 sentences and ~22-30 words (minimum 20 words per scene).\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n- Scene 1 must continue after the hook with NEW information (no restating or paraphrasing the hook).\n- Each scene text must be at least 20 words.\n- Double-check total word count before responding.\n- Hook must be a statement (no question mark).\n\n\nStructure as a numbered list with a hook, clear items, and a call-to-action.\nPrefix each point with an explicit number label (e.g., \"Tip 1:\", \"2)\", \"Number 3:\").\n\n\n\n\n\n\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n- Each scene text must be at least 20 words.\n- Hook must be a statement (no question mark).\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n",
          "label": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"{{ topic }}\"\n\nFORMAT: {{ archetype }}\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Total spoken word count must be between 90-150 words.\n- Use short sentences (<=15 words) and one idea per sentence.\n- Each scene should be 2 sentences and ~22-30 words (minimum 20 words per scene).\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n- Scene 1 must continue after the hook with NEW information (no restating or paraphrasing the hook).\n- Each scene text must be at least 20 words.\n- Double-check total word count before responding.\n- Hook must be a statement (no question mark).\n\n{% if archetype == \"listicle\" %}\nStructure as a numbered list with a hook, clear items, and a call-to-action.\nPrefix each point with an explicit number label (e.g., \"Tip 1:\", \"2)\", \"Number 3:\").\n{% endif %}\n{% if archetype == \"versus\" %}\nPresent a balanced comparison with a clear recommendation at the end.\nThe hook should be a bold statement, not a question.\n{% endif %}\n{% if archetype == \"howto\" %}\nGive step-by-step instructions that are easy to follow.\n{% endif %}\n{% if archetype == \"myth\" %}\nStart with the myth, then reveal the reality with evidence.\nUse explicit \"Myth: X\" and \"Reality: Y\" phrasing in scene text.\n{% endif %}\n{% if archetype == \"story\" %}\nUse narrative structure: setup, conflict, resolution.\n{% endif %}\n{% if archetype == \"hot-take\" %}\nLead with a provocative opinion, then back it up with reasoning.\n{% endif %}\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n- Each scene text must be at least 20 words.\n- Hook must be a statement (no question mark).\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n"
        },
        "promptId": "3a2330721e33f906bebc9d49df16221c36cfd3cebbbc91ec115733487d847736",
        "promptIdx": 0,
        "provider": {
          "id": "openai:gpt-4o",
          "label": ""
        },
        "response": {
          "output": "{\n  \"scenes\": [\n    {\n      \"text\": \"Tip number one: Use 'const' and 'let' instead of 'var'. 'Const' for constants, 'let' for variables.\",\n      \"visualDirection\": \"Show 'const' and 'let' replacing 'var' in code editor.\",\n      \"mood\": \"informative\"\n    },\n    {\n      \"text\": \"Number two: Arrow functions simplify code. They're shorter and automatically bind 'this'.\",\n      \"visualDirection\": \"Show transformation from traditional function to arrow function.\",\n      \"mood\": \"energetic\"\n    },\n    {\n      \"text\": \"Tip three: Use template literals for strings. They're cleaner and support multi-line without hassle.\",\n      \"visualDirection\": \"Display a multi-line string with template literals.\",\n      \"mood\": \"relaxed\"\n    },\n    {\n      \"text\": \"Four: Destructuring makes extracting values from arrays and objects super easy.\",\n      \"visualDirection\": \"Show destructuring of an array and an object.\",\n      \"mood\": \"engaging\"\n    },\n    {\n      \"text\": \"Finally, use async/await for cleaner asynchronous code. It's easier to read and write.\",\n      \"visualDirection\": \"Show async/await replacing promise chaining.\",\n      \"mood\": \"uplifting\"\n    }\n  ],\n  \"reasoning\": \"This script provides a quick and engaging overview of essential JavaScript tips for developers using a listicle format. Each tip is concise, easy to understand, and visually supported to enhance learning. The mood varies to maintain viewer interest and engagement.\",\n  \"title\": \"5 JavaScript Tips Every Developer Should Know\",\n  \"hook\": \"These five JavaScript tips will change the way you code.\",\n  \"cta\": \"Follow for more coding tips and tricks.\",\n  \"hashtags\": [\"#JavaScript\", \"#Coding\", \"#WebDevelopment\", \"#Programming\"]\n}",
          "tokenUsage": {
            "total": 927,
            "prompt": 531,
            "completion": 396,
            "numRequests": 1,
            "completionDetails": {
              "reasoning": 0,
              "acceptedPrediction": 0,
              "rejectedPrediction": 0
            }
          },
          "cached": false,
          "latencyMs": 4702,
          "finishReason": "stop",
          "cost": 0.0052875000000000005,
          "guardrails": {
            "flagged": false
          }
        },
        "score": 0.9285714285714286,
        "success": false,
        "testCase": {
          "vars": {
            "topic": "5 JavaScript tips every developer should know",
            "archetype": "listicle"
          },
          "assert": [
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return (\n    Array.isArray(script.scenes) &&\n    script.scenes.length >= 3 &&\n    script.scenes.length <= 7\n  );\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 90 && wordCount <= 150;\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return (script.scenes || []).every((scene) =>\n    typeof scene.visualDirection === 'string' && scene.visualDirection.trim().length > 5\n  );\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean)\n    .join(' ');\n  const hasEmoji = /\\p{Extended_Pictographic}/u.test(spoken);\n  const hasMarkdown = /[`*_]/.test(spoken) || /\\[(.+?)\\]\\((.+?)\\)/.test(spoken);\n  const hasHashtag = /(^|\\s)#\\w+/.test(spoken);\n  return !hasEmoji && !hasMarkdown && !hasHashtag;\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return typeof script.reasoning === 'string' && script.reasoning.trim().length > 10;\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "llm-rubric",
              "value": "The script opens with an attention-grabbing hook that would stop a TikTok user from scrolling.\nThe first sentence should be surprising, controversial, or promise immediate value.\nScore 0 if it's a generic introduction like \"In this video...\" or \"Today we'll cover...\".\n",
              "threshold": 0.7,
              "weight": 2
            },
            {
              "type": "llm-rubric",
              "value": "The language is casual, conversational, and suitable for TikTok/Reels/Shorts.\nNo corporate jargon, no formal academic language, no \"as a developer\" phrases.\nShould sound like a friend giving advice, not a textbook.\n",
              "threshold": 0.8,
              "weight": 1
            },
            {
              "type": "llm-rubric",
              "value": "Each scene has a specific, filmable visual description.\nVisual directions should describe what the viewer will SEE on screen.\nAvoid abstract concepts that cannot be filmed (like \"efficiency\" or \"code quality\").\n",
              "threshold": 0.8,
              "weight": 1
            },
            {
              "type": "llm-rubric",
              "value": "For a listicle archetype, the script should have a clear numbered structure.\nEach tip should be distinct and actionable.\nThe list should feel complete, not like it was cut off.\n",
              "threshold": 0.8,
              "weight": 1
            }
          ],
          "options": {
            "provider": "openai:gpt-4o-mini"
          },
          "metadata": {}
        },
        "testIdx": 0,
        "vars": {
          "topic": "5 JavaScript tips every developer should know",
          "archetype": "listicle"
        },
        "metadata": {
          "_promptfooFileMetadata": {}
        },
        "failureReason": 1
      },
      {
        "cost": 0.006042500000000001,
        "error": "The hook does not present a provocative statement or relatable problem, but rather introduces the video's topic more neutrally.",
        "gradingResult": {
          "pass": false,
          "score": 0.8571428571428571,
          "reason": "The hook does not present a provocative statement or relatable problem, but rather introduces the video's topic more neutrally.",
          "namedScores": {},
          "tokensUsed": {
            "total": 1950,
            "prompt": 1802,
            "completion": 148,
            "cached": 0,
            "numRequests": 3
          },
          "componentResults": [
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return (\n    Array.isArray(script.scenes) &&\n    script.scenes.length >= 3 &&\n    script.scenes.length <= 7\n  );\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 90 && wordCount <= 150;\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return (script.scenes || []).every((scene) =>\n    typeof scene.visualDirection === 'string' && scene.visualDirection.trim().length > 5\n  );\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean)\n    .join(' ');\n  const hasEmoji = /\\p{Extended_Pictographic}/u.test(spoken);\n  const hasMarkdown = /[`*_]/.test(spoken) || /\\[(.+?)\\]\\((.+?)\\)/.test(spoken);\n  const hasHashtag = /(^|\\s)#\\w+/.test(spoken);\n  return !hasEmoji && !hasMarkdown && !hasHashtag;\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return typeof script.reasoning === 'string' && script.reasoning.trim().length > 10;\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "The script opens with an attention-grabbing hook.\nFor a versus video, this might be a provocative statement like \"You're using the wrong database\"\nor a relatable problem statement.\n",
                "threshold": 0.7,
                "weight": 2
              },
              "pass": false,
              "score": 0,
              "reason": "The hook does not present a provocative statement or relatable problem, but rather introduces the video's topic more neutrally.",
              "tokensUsed": {
                "total": 643,
                "prompt": 604,
                "completion": 39,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"Redis is lightning fast for caching, storing data in memory for quick access. It's perfect for real-time applications that need speed, like leaderboards or live chats.\\\",\\\"visualDirection\\\":\\\"Show Redis logo with animations of data moving quickly, speedometer graphic indicating fast speed.\\\",\\\"mood\\\":\\\"Energetic and fast-paced\\\"},{\\\"text\\\":\\\"PostgreSQL, on the other hand, offers complex queries and data persistence. It's great when you need advanced analytics and durability alongside caching.\\\",\\\"visualDirection\\\":\\\"Display PostgreSQL logo with animations of data being queried and stored securely.\\\",\\\"mood\\\":\\\"Informative and steady\\\"},{\\\"text\\\":\\\"Redis is simpler to set up and scales easily for distributed systems. If your app scales fast, Redis can handle the load without missing a beat.\\\",\\\"visualDirection\\\":\\\"Show Redis setup process in a few simple steps, then expand to multiple servers.\\\",\\\"mood\\\":\\\"Confident and straightforward\\\"},{\\\"text\\\":\\\"PostgreSQL can handle more complex transactions and integrity checks. If your caching needs involve complex operations, PostgreSQL's got your back.\\\",\\\"visualDirection\\\":\\\"Display transactions and data integrity checks in action with PostgreSQL.\\\",\\\"mood\\\":\\\"Trustworthy and robust\\\"},{\\\"text\\\":\\\"For pure caching, go with Redis. For caching plus complex data needs, PostgreSQL's your choice. Choose wisely based on your needs.\\\",\\\"visualDirection\\\":\\\"Split screen with Redis and PostgreSQL logos, transition to a decision graphic.\\\",\\\"mood\\\":\\\"Decisive and clear\\\"}],\\\"reasoning\\\":\\\"The video provides a balanced comparison of Redis and PostgreSQL for caching, highlighting their strengths. Redis is recommended for pure speed, while PostgreSQL is better for complex data needs.\\\",\\\"title\\\":\\\"Redis vs PostgreSQL: The Caching Showdown\\\",\\\"hook\\\":\\\"Choosing between Redis and PostgreSQL for caching is crucial for your app's performance.\\\",\\\"cta\\\":\\\"Decide on the right tool and supercharge your app today.\\\",\\\"hashtags\\\":[\\\"#Redis\\\",\\\"#PostgreSQL\\\",\\\"#Caching\\\",\\\"#TechTips\\\"]}\\n</Output>\\n<Rubric>\\nThe script opens with an attention-grabbing hook.\\nFor a versus video, this might be a provocative statement like \\\"You're using the wrong database\\\"\\nor a relatable problem statement.\\n\\n</Rubric>\"}]"
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "For a versus archetype, the script should clearly compare both options.\nIt should present pros and cons of each, not just favor one.\nThe comparison should be fair and technically accurate.\n",
                "threshold": 0.8,
                "weight": 2
              },
              "pass": true,
              "score": 1,
              "reason": "The output presents a clear comparison between Redis and PostgreSQL, detailing their pros and cons while maintaining a balanced view. It specifically highlights Redis's strengths in speed for caching and PostgreSQL's capabilities for complex queries and data persistence, fulfilling the requirements for a fair and technically accurate comparison.",
              "tokensUsed": {
                "total": 675,
                "prompt": 606,
                "completion": 69,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"Redis is lightning fast for caching, storing data in memory for quick access. It's perfect for real-time applications that need speed, like leaderboards or live chats.\\\",\\\"visualDirection\\\":\\\"Show Redis logo with animations of data moving quickly, speedometer graphic indicating fast speed.\\\",\\\"mood\\\":\\\"Energetic and fast-paced\\\"},{\\\"text\\\":\\\"PostgreSQL, on the other hand, offers complex queries and data persistence. It's great when you need advanced analytics and durability alongside caching.\\\",\\\"visualDirection\\\":\\\"Display PostgreSQL logo with animations of data being queried and stored securely.\\\",\\\"mood\\\":\\\"Informative and steady\\\"},{\\\"text\\\":\\\"Redis is simpler to set up and scales easily for distributed systems. If your app scales fast, Redis can handle the load without missing a beat.\\\",\\\"visualDirection\\\":\\\"Show Redis setup process in a few simple steps, then expand to multiple servers.\\\",\\\"mood\\\":\\\"Confident and straightforward\\\"},{\\\"text\\\":\\\"PostgreSQL can handle more complex transactions and integrity checks. If your caching needs involve complex operations, PostgreSQL's got your back.\\\",\\\"visualDirection\\\":\\\"Display transactions and data integrity checks in action with PostgreSQL.\\\",\\\"mood\\\":\\\"Trustworthy and robust\\\"},{\\\"text\\\":\\\"For pure caching, go with Redis. For caching plus complex data needs, PostgreSQL's your choice. Choose wisely based on your needs.\\\",\\\"visualDirection\\\":\\\"Split screen with Redis and PostgreSQL logos, transition to a decision graphic.\\\",\\\"mood\\\":\\\"Decisive and clear\\\"}],\\\"reasoning\\\":\\\"The video provides a balanced comparison of Redis and PostgreSQL for caching, highlighting their strengths. Redis is recommended for pure speed, while PostgreSQL is better for complex data needs.\\\",\\\"title\\\":\\\"Redis vs PostgreSQL: The Caching Showdown\\\",\\\"hook\\\":\\\"Choosing between Redis and PostgreSQL for caching is crucial for your app's performance.\\\",\\\"cta\\\":\\\"Decide on the right tool and supercharge your app today.\\\",\\\"hashtags\\\":[\\\"#Redis\\\",\\\"#PostgreSQL\\\",\\\"#Caching\\\",\\\"#TechTips\\\"]}\\n</Output>\\n<Rubric>\\nFor a versus archetype, the script should clearly compare both options.\\nIt should present pros and cons of each, not just favor one.\\nThe comparison should be fair and technically accurate.\\n\\n</Rubric>\"}]"
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "The script provides a clear recommendation or decision framework at the end.\nViewers should know when to use each option.\n",
                "threshold": 0.7,
                "weight": 1
              },
              "pass": true,
              "score": 1,
              "reason": "The script clearly states to choose Redis for pure caching and PostgreSQL for complex data needs, providing a decision framework.",
              "tokensUsed": {
                "total": 632,
                "prompt": 592,
                "completion": 40,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"Redis is lightning fast for caching, storing data in memory for quick access. It's perfect for real-time applications that need speed, like leaderboards or live chats.\\\",\\\"visualDirection\\\":\\\"Show Redis logo with animations of data moving quickly, speedometer graphic indicating fast speed.\\\",\\\"mood\\\":\\\"Energetic and fast-paced\\\"},{\\\"text\\\":\\\"PostgreSQL, on the other hand, offers complex queries and data persistence. It's great when you need advanced analytics and durability alongside caching.\\\",\\\"visualDirection\\\":\\\"Display PostgreSQL logo with animations of data being queried and stored securely.\\\",\\\"mood\\\":\\\"Informative and steady\\\"},{\\\"text\\\":\\\"Redis is simpler to set up and scales easily for distributed systems. If your app scales fast, Redis can handle the load without missing a beat.\\\",\\\"visualDirection\\\":\\\"Show Redis setup process in a few simple steps, then expand to multiple servers.\\\",\\\"mood\\\":\\\"Confident and straightforward\\\"},{\\\"text\\\":\\\"PostgreSQL can handle more complex transactions and integrity checks. If your caching needs involve complex operations, PostgreSQL's got your back.\\\",\\\"visualDirection\\\":\\\"Display transactions and data integrity checks in action with PostgreSQL.\\\",\\\"mood\\\":\\\"Trustworthy and robust\\\"},{\\\"text\\\":\\\"For pure caching, go with Redis. For caching plus complex data needs, PostgreSQL's your choice. Choose wisely based on your needs.\\\",\\\"visualDirection\\\":\\\"Split screen with Redis and PostgreSQL logos, transition to a decision graphic.\\\",\\\"mood\\\":\\\"Decisive and clear\\\"}],\\\"reasoning\\\":\\\"The video provides a balanced comparison of Redis and PostgreSQL for caching, highlighting their strengths. Redis is recommended for pure speed, while PostgreSQL is better for complex data needs.\\\",\\\"title\\\":\\\"Redis vs PostgreSQL: The Caching Showdown\\\",\\\"hook\\\":\\\"Choosing between Redis and PostgreSQL for caching is crucial for your app's performance.\\\",\\\"cta\\\":\\\"Decide on the right tool and supercharge your app today.\\\",\\\"hashtags\\\":[\\\"#Redis\\\",\\\"#PostgreSQL\\\",\\\"#Caching\\\",\\\"#TechTips\\\"]}\\n</Output>\\n<Rubric>\\nThe script provides a clear recommendation or decision framework at the end.\\nViewers should know when to use each option.\\n\\n</Rubric>\"}]"
              }
            }
          ]
        },
        "id": "6f496a21-9dd9-42ea-b935-20b6466c1790",
        "latencyMs": 5815,
        "namedScores": {},
        "prompt": {
          "raw": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"Redis vs PostgreSQL for caching\"\n\nFORMAT: versus\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Total spoken word count must be between 90-150 words.\n- Use short sentences (<=15 words) and one idea per sentence.\n- Each scene should be 2 sentences and ~22-30 words (minimum 20 words per scene).\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n- Scene 1 must continue after the hook with NEW information (no restating or paraphrasing the hook).\n- Each scene text must be at least 20 words.\n- Double-check total word count before responding.\n- Hook must be a statement (no question mark).\n\n\n\nPresent a balanced comparison with a clear recommendation at the end.\nThe hook should be a bold statement, not a question.\n\n\n\n\n\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n- Each scene text must be at least 20 words.\n- Hook must be a statement (no question mark).\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n",
          "label": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"{{ topic }}\"\n\nFORMAT: {{ archetype }}\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Total spoken word count must be between 90-150 words.\n- Use short sentences (<=15 words) and one idea per sentence.\n- Each scene should be 2 sentences and ~22-30 words (minimum 20 words per scene).\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n- Scene 1 must continue after the hook with NEW information (no restating or paraphrasing the hook).\n- Each scene text must be at least 20 words.\n- Double-check total word count before responding.\n- Hook must be a statement (no question mark).\n\n{% if archetype == \"listicle\" %}\nStructure as a numbered list with a hook, clear items, and a call-to-action.\nPrefix each point with an explicit number label (e.g., \"Tip 1:\", \"2)\", \"Number 3:\").\n{% endif %}\n{% if archetype == \"versus\" %}\nPresent a balanced comparison with a clear recommendation at the end.\nThe hook should be a bold statement, not a question.\n{% endif %}\n{% if archetype == \"howto\" %}\nGive step-by-step instructions that are easy to follow.\n{% endif %}\n{% if archetype == \"myth\" %}\nStart with the myth, then reveal the reality with evidence.\nUse explicit \"Myth: X\" and \"Reality: Y\" phrasing in scene text.\n{% endif %}\n{% if archetype == \"story\" %}\nUse narrative structure: setup, conflict, resolution.\n{% endif %}\n{% if archetype == \"hot-take\" %}\nLead with a provocative opinion, then back it up with reasoning.\n{% endif %}\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n- Each scene text must be at least 20 words.\n- Hook must be a statement (no question mark).\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n"
        },
        "promptId": "3a2330721e33f906bebc9d49df16221c36cfd3cebbbc91ec115733487d847736",
        "promptIdx": 0,
        "provider": {
          "id": "openai:gpt-4o",
          "label": ""
        },
        "response": {
          "output": "{\n  \"scenes\": [\n    {\n      \"text\": \"Redis is lightning fast for caching, storing data in memory for quick access. It's perfect for real-time applications that need speed, like leaderboards or live chats.\",\n      \"visualDirection\": \"Show Redis logo with animations of data moving quickly, speedometer graphic indicating fast speed.\",\n      \"mood\": \"Energetic and fast-paced\"\n    },\n    {\n      \"text\": \"PostgreSQL, on the other hand, offers complex queries and data persistence. It's great when you need advanced analytics and durability alongside caching.\",\n      \"visualDirection\": \"Display PostgreSQL logo with animations of data being queried and stored securely.\",\n      \"mood\": \"Informative and steady\"\n    },\n    {\n      \"text\": \"Redis is simpler to set up and scales easily for distributed systems. If your app scales fast, Redis can handle the load without missing a beat.\",\n      \"visualDirection\": \"Show Redis setup process in a few simple steps, then expand to multiple servers.\",\n      \"mood\": \"Confident and straightforward\"\n    },\n    {\n      \"text\": \"PostgreSQL can handle more complex transactions and integrity checks. If your caching needs involve complex operations, PostgreSQL's got your back.\",\n      \"visualDirection\": \"Display transactions and data integrity checks in action with PostgreSQL.\",\n      \"mood\": \"Trustworthy and robust\"\n    },\n    {\n      \"text\": \"For pure caching, go with Redis. For caching plus complex data needs, PostgreSQL's your choice. Choose wisely based on your needs.\",\n      \"visualDirection\": \"Split screen with Redis and PostgreSQL logos, transition to a decision graphic.\",\n      \"mood\": \"Decisive and clear\"\n    }\n  ],\n  \"reasoning\": \"The video provides a balanced comparison of Redis and PostgreSQL for caching, highlighting their strengths. Redis is recommended for pure speed, while PostgreSQL is better for complex data needs.\",\n  \"title\": \"Redis vs PostgreSQL: The Caching Showdown\",\n  \"hook\": \"Choosing between Redis and PostgreSQL for caching is crucial for your app's performance.\",\n  \"cta\": \"Decide on the right tool and supercharge your app today.\",\n  \"hashtags\": [\"#Redis\", \"#PostgreSQL\", \"#Caching\", \"#TechTips\"]\n}",
          "tokenUsage": {
            "total": 986,
            "prompt": 509,
            "completion": 477,
            "numRequests": 1,
            "completionDetails": {
              "reasoning": 0,
              "acceptedPrediction": 0,
              "rejectedPrediction": 0
            }
          },
          "cached": false,
          "latencyMs": 5815,
          "finishReason": "stop",
          "cost": 0.006042500000000001,
          "guardrails": {
            "flagged": false
          }
        },
        "score": 0.8571428571428571,
        "success": false,
        "testCase": {
          "vars": {
            "topic": "Redis vs PostgreSQL for caching",
            "archetype": "versus"
          },
          "assert": [
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return (\n    Array.isArray(script.scenes) &&\n    script.scenes.length >= 3 &&\n    script.scenes.length <= 7\n  );\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 90 && wordCount <= 150;\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return (script.scenes || []).every((scene) =>\n    typeof scene.visualDirection === 'string' && scene.visualDirection.trim().length > 5\n  );\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean)\n    .join(' ');\n  const hasEmoji = /\\p{Extended_Pictographic}/u.test(spoken);\n  const hasMarkdown = /[`*_]/.test(spoken) || /\\[(.+?)\\]\\((.+?)\\)/.test(spoken);\n  const hasHashtag = /(^|\\s)#\\w+/.test(spoken);\n  return !hasEmoji && !hasMarkdown && !hasHashtag;\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return typeof script.reasoning === 'string' && script.reasoning.trim().length > 10;\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "llm-rubric",
              "value": "The script opens with an attention-grabbing hook.\nFor a versus video, this might be a provocative statement like \"You're using the wrong database\"\nor a relatable problem statement.\n",
              "threshold": 0.7,
              "weight": 2
            },
            {
              "type": "llm-rubric",
              "value": "For a versus archetype, the script should clearly compare both options.\nIt should present pros and cons of each, not just favor one.\nThe comparison should be fair and technically accurate.\n",
              "threshold": 0.8,
              "weight": 2
            },
            {
              "type": "llm-rubric",
              "value": "The script provides a clear recommendation or decision framework at the end.\nViewers should know when to use each option.\n",
              "threshold": 0.7,
              "weight": 1
            }
          ],
          "options": {
            "provider": "openai:gpt-4o-mini"
          },
          "metadata": {}
        },
        "testIdx": 1,
        "vars": {
          "topic": "Redis vs PostgreSQL for caching",
          "archetype": "versus"
        },
        "metadata": {
          "_promptfooFileMetadata": {}
        },
        "failureReason": 1
      },
      {
        "cost": 0.00581,
        "gradingResult": {
          "pass": true,
          "score": 1,
          "reason": "All assertions passed",
          "namedScores": {},
          "tokensUsed": {
            "total": 1250,
            "prompt": 1149,
            "completion": 101,
            "cached": 0,
            "numRequests": 2
          },
          "componentResults": [
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return (\n    Array.isArray(script.scenes) &&\n    script.scenes.length >= 3 &&\n    script.scenes.length <= 7\n  );\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 90 && wordCount <= 150;\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return (script.scenes || []).every((scene) =>\n    typeof scene.visualDirection === 'string' && scene.visualDirection.trim().length > 5\n  );\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean)\n    .join(' ');\n  const hasEmoji = /\\p{Extended_Pictographic}/u.test(spoken);\n  const hasMarkdown = /[`*_]/.test(spoken) || /\\[(.+?)\\]\\((.+?)\\)/.test(spoken);\n  const hasHashtag = /(^|\\s)#\\w+/.test(spoken);\n  return !hasEmoji && !hasMarkdown && !hasHashtag;\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return typeof script.reasoning === 'string' && script.reasoning.trim().length > 10;\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "The script has a narrative arc: setup, challenge, resolution.\nIt should feel like a personal story, not a tutorial.\n",
                "threshold": 0.8,
                "weight": 2
              },
              "pass": true,
              "score": 1,
              "reason": "The script starts with a setup of a study schedule, presents challenges faced while learning, and concludes with successful project completion, following a clear narrative arc. It also conveys a personal journey rather than a tutorial format.",
              "tokensUsed": {
                "total": 636,
                "prompt": 577,
                "completion": 59,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"I dove into React with no coding experience and came out a pro in two weeks. First things first, I set a strict study schedule.\\\",\\\"visualDirection\\\":\\\"Show a calendar with 'React Study Plan' written on it and checkmarks on each day.\\\",\\\"mood\\\":\\\"Determined\\\"},{\\\"text\\\":\\\"I watched countless tutorials on 1.5x speed, pausing to take notes. Speed was key. I learned by doing, not just watching.\\\",\\\"visualDirection\\\":\\\"Speed up footage of videos playing and notes being scribbled.\\\",\\\"mood\\\":\\\"Focused\\\"},{\\\"text\\\":\\\"I built small projects like a to-do list app. These projects helped me apply what I learned. It was challenging, but rewarding.\\\",\\\"visualDirection\\\":\\\"Show snippets of code and a simple to-do list app in action.\\\",\\\"mood\\\":\\\"Engaged\\\"},{\\\"text\\\":\\\"Whenever I got stuck, I turned to online forums. The community support was amazing and kept me motivated.\\\",\\\"visualDirection\\\":\\\"Show a computer screen with a forum discussion and helpful replies.\\\",\\\"mood\\\":\\\"Supported\\\"},{\\\"text\\\":\\\"By the end of two weeks, I could create dynamic web apps confidently. It was tough, but I made it!\\\",\\\"visualDirection\\\":\\\"Show a celebratory montage of completed projects and a thumbs up.\\\",\\\"mood\\\":\\\"Accomplished\\\"}],\\\"reasoning\\\":\\\"The script follows a narrative structure, starting with the setup of a strict study schedule, followed by the conflict of learning challenges, and resolving with successful project completion. It maintains a conversational tone suitable for TikTok and ends with a call-to-action to inspire viewers to start learning React.\\\",\\\"title\\\":\\\"Mastering React in Two Weeks\\\",\\\"hook\\\":\\\"I mastered React in just two weeks and here's how.\\\",\\\"cta\\\":\\\"Ready to start your React journey? Dive in and code your heart out!\\\",\\\"hashtags\\\":[\\\"#React\\\",\\\"#CodingJourney\\\",\\\"#LearnToCode\\\"]}\\n</Output>\\n<Rubric>\\nThe script has a narrative arc: setup, challenge, resolution.\\nIt should feel like a personal story, not a tutorial.\\n\\n</Rubric>\"}]"
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "The language uses first-person perspective and includes emotional elements.\nThe viewer should feel connected to the storyteller.\n",
                "threshold": 0.7,
                "weight": 1
              },
              "pass": true,
              "score": 1,
              "reason": "The output uses first-person perspective throughout the narrative and includes emotional elements like determination, focus, engagement, support, and accomplishment.",
              "tokensUsed": {
                "total": 614,
                "prompt": 572,
                "completion": 42,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"I dove into React with no coding experience and came out a pro in two weeks. First things first, I set a strict study schedule.\\\",\\\"visualDirection\\\":\\\"Show a calendar with 'React Study Plan' written on it and checkmarks on each day.\\\",\\\"mood\\\":\\\"Determined\\\"},{\\\"text\\\":\\\"I watched countless tutorials on 1.5x speed, pausing to take notes. Speed was key. I learned by doing, not just watching.\\\",\\\"visualDirection\\\":\\\"Speed up footage of videos playing and notes being scribbled.\\\",\\\"mood\\\":\\\"Focused\\\"},{\\\"text\\\":\\\"I built small projects like a to-do list app. These projects helped me apply what I learned. It was challenging, but rewarding.\\\",\\\"visualDirection\\\":\\\"Show snippets of code and a simple to-do list app in action.\\\",\\\"mood\\\":\\\"Engaged\\\"},{\\\"text\\\":\\\"Whenever I got stuck, I turned to online forums. The community support was amazing and kept me motivated.\\\",\\\"visualDirection\\\":\\\"Show a computer screen with a forum discussion and helpful replies.\\\",\\\"mood\\\":\\\"Supported\\\"},{\\\"text\\\":\\\"By the end of two weeks, I could create dynamic web apps confidently. It was tough, but I made it!\\\",\\\"visualDirection\\\":\\\"Show a celebratory montage of completed projects and a thumbs up.\\\",\\\"mood\\\":\\\"Accomplished\\\"}],\\\"reasoning\\\":\\\"The script follows a narrative structure, starting with the setup of a strict study schedule, followed by the conflict of learning challenges, and resolving with successful project completion. It maintains a conversational tone suitable for TikTok and ends with a call-to-action to inspire viewers to start learning React.\\\",\\\"title\\\":\\\"Mastering React in Two Weeks\\\",\\\"hook\\\":\\\"I mastered React in just two weeks and here's how.\\\",\\\"cta\\\":\\\"Ready to start your React journey? Dive in and code your heart out!\\\",\\\"hashtags\\\":[\\\"#React\\\",\\\"#CodingJourney\\\",\\\"#LearnToCode\\\"]}\\n</Output>\\n<Rubric>\\nThe language uses first-person perspective and includes emotional elements.\\nThe viewer should feel connected to the storyteller.\\n\\n</Rubric>\"}]"
              }
            }
          ]
        },
        "id": "cfab1024-ef06-4696-80e9-cf8507ba8047",
        "latencyMs": 9553,
        "namedScores": {},
        "prompt": {
          "raw": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"How I learned React in 2 weeks\"\n\nFORMAT: story\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Total spoken word count must be between 90-150 words.\n- Use short sentences (<=15 words) and one idea per sentence.\n- Each scene should be 2 sentences and ~22-30 words (minimum 20 words per scene).\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n- Scene 1 must continue after the hook with NEW information (no restating or paraphrasing the hook).\n- Each scene text must be at least 20 words.\n- Double-check total word count before responding.\n- Hook must be a statement (no question mark).\n\n\n\n\n\n\nUse narrative structure: setup, conflict, resolution.\n\n\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n- Each scene text must be at least 20 words.\n- Hook must be a statement (no question mark).\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n",
          "label": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"{{ topic }}\"\n\nFORMAT: {{ archetype }}\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Total spoken word count must be between 90-150 words.\n- Use short sentences (<=15 words) and one idea per sentence.\n- Each scene should be 2 sentences and ~22-30 words (minimum 20 words per scene).\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n- Scene 1 must continue after the hook with NEW information (no restating or paraphrasing the hook).\n- Each scene text must be at least 20 words.\n- Double-check total word count before responding.\n- Hook must be a statement (no question mark).\n\n{% if archetype == \"listicle\" %}\nStructure as a numbered list with a hook, clear items, and a call-to-action.\nPrefix each point with an explicit number label (e.g., \"Tip 1:\", \"2)\", \"Number 3:\").\n{% endif %}\n{% if archetype == \"versus\" %}\nPresent a balanced comparison with a clear recommendation at the end.\nThe hook should be a bold statement, not a question.\n{% endif %}\n{% if archetype == \"howto\" %}\nGive step-by-step instructions that are easy to follow.\n{% endif %}\n{% if archetype == \"myth\" %}\nStart with the myth, then reveal the reality with evidence.\nUse explicit \"Myth: X\" and \"Reality: Y\" phrasing in scene text.\n{% endif %}\n{% if archetype == \"story\" %}\nUse narrative structure: setup, conflict, resolution.\n{% endif %}\n{% if archetype == \"hot-take\" %}\nLead with a provocative opinion, then back it up with reasoning.\n{% endif %}\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n- Each scene text must be at least 20 words.\n- Hook must be a statement (no question mark).\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n"
        },
        "promptId": "3a2330721e33f906bebc9d49df16221c36cfd3cebbbc91ec115733487d847736",
        "promptIdx": 0,
        "provider": {
          "id": "openai:gpt-4o",
          "label": ""
        },
        "response": {
          "output": "{\n  \"scenes\": [\n    {\n      \"text\": \"I dove into React with no coding experience and came out a pro in two weeks. First things first, I set a strict study schedule.\",\n      \"visualDirection\": \"Show a calendar with 'React Study Plan' written on it and checkmarks on each day.\",\n      \"mood\": \"Determined\"\n    },\n    {\n      \"text\": \"I watched countless tutorials on 1.5x speed, pausing to take notes. Speed was key. I learned by doing, not just watching.\",\n      \"visualDirection\": \"Speed up footage of videos playing and notes being scribbled.\",\n      \"mood\": \"Focused\"\n    },\n    {\n      \"text\": \"I built small projects like a to-do list app. These projects helped me apply what I learned. It was challenging, but rewarding.\",\n      \"visualDirection\": \"Show snippets of code and a simple to-do list app in action.\",\n      \"mood\": \"Engaged\"\n    },\n    {\n      \"text\": \"Whenever I got stuck, I turned to online forums. The community support was amazing and kept me motivated.\",\n      \"visualDirection\": \"Show a computer screen with a forum discussion and helpful replies.\",\n      \"mood\": \"Supported\"\n    },\n    {\n      \"text\": \"By the end of two weeks, I could create dynamic web apps confidently. It was tough, but I made it!\",\n      \"visualDirection\": \"Show a celebratory montage of completed projects and a thumbs up.\",\n      \"mood\": \"Accomplished\"\n    }\n  ],\n  \"reasoning\": \"The script follows a narrative structure, starting with the setup of a strict study schedule, followed by the conflict of learning challenges, and resolving with successful project completion. It maintains a conversational tone suitable for TikTok and ends with a call-to-action to inspire viewers to start learning React.\",\n  \"title\": \"Mastering React in Two Weeks\",\n  \"hook\": \"I mastered React in just two weeks and here's how.\",\n  \"cta\": \"Ready to start your React journey? Dive in and code your heart out!\",\n  \"hashtags\": [\"#React\", \"#CodingJourney\", \"#LearnToCode\"]\n}",
          "tokenUsage": {
            "total": 953,
            "prompt": 496,
            "completion": 457,
            "numRequests": 1,
            "completionDetails": {
              "reasoning": 0,
              "acceptedPrediction": 0,
              "rejectedPrediction": 0
            }
          },
          "cached": false,
          "latencyMs": 9553,
          "finishReason": "stop",
          "cost": 0.00581,
          "guardrails": {
            "flagged": false
          }
        },
        "score": 1,
        "success": true,
        "testCase": {
          "vars": {
            "topic": "How I learned React in 2 weeks",
            "archetype": "story"
          },
          "assert": [
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return (\n    Array.isArray(script.scenes) &&\n    script.scenes.length >= 3 &&\n    script.scenes.length <= 7\n  );\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 90 && wordCount <= 150;\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return (script.scenes || []).every((scene) =>\n    typeof scene.visualDirection === 'string' && scene.visualDirection.trim().length > 5\n  );\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean)\n    .join(' ');\n  const hasEmoji = /\\p{Extended_Pictographic}/u.test(spoken);\n  const hasMarkdown = /[`*_]/.test(spoken) || /\\[(.+?)\\]\\((.+?)\\)/.test(spoken);\n  const hasHashtag = /(^|\\s)#\\w+/.test(spoken);\n  return !hasEmoji && !hasMarkdown && !hasHashtag;\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return typeof script.reasoning === 'string' && script.reasoning.trim().length > 10;\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "llm-rubric",
              "value": "The script has a narrative arc: setup, challenge, resolution.\nIt should feel like a personal story, not a tutorial.\n",
              "threshold": 0.8,
              "weight": 2
            },
            {
              "type": "llm-rubric",
              "value": "The language uses first-person perspective and includes emotional elements.\nThe viewer should feel connected to the storyteller.\n",
              "threshold": 0.7,
              "weight": 1
            }
          ],
          "options": {
            "provider": "openai:gpt-4o-mini"
          },
          "metadata": {}
        },
        "testIdx": 2,
        "vars": {
          "topic": "How I learned React in 2 weeks",
          "archetype": "story"
        },
        "metadata": {
          "_promptfooFileMetadata": {}
        },
        "failureReason": 0
      },
      {
        "cost": 0.005585,
        "gradingResult": {
          "pass": true,
          "score": 1,
          "reason": "All assertions passed",
          "namedScores": {},
          "tokensUsed": {
            "total": 1214,
            "prompt": 1119,
            "completion": 95,
            "cached": 0,
            "numRequests": 2
          },
          "componentResults": [
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return (\n    Array.isArray(script.scenes) &&\n    script.scenes.length >= 3 &&\n    script.scenes.length <= 7\n  );\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 90 && wordCount <= 150;\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return (script.scenes || []).every((scene) =>\n    typeof scene.visualDirection === 'string' && scene.visualDirection.trim().length > 5\n  );\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean)\n    .join(' ');\n  const hasEmoji = /\\p{Extended_Pictographic}/u.test(spoken);\n  const hasMarkdown = /[`*_]/.test(spoken) || /\\[(.+?)\\]\\((.+?)\\)/.test(spoken);\n  const hasHashtag = /(^|\\s)#\\w+/.test(spoken);\n  return !hasEmoji && !hasMarkdown && !hasHashtag;\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return typeof script.reasoning === 'string' && script.reasoning.trim().length > 10;\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "The script opens with a bold, controversial statement that will spark debate.\nIt should immediately make viewers want to comment (agree or disagree).\n",
                "threshold": 0.8,
                "weight": 2
              },
              "pass": true,
              "score": 1,
              "reason": "The script opens with the statement 'TypeScript is kinda overrated for small projects,' which is bold and likely to provoke differing opinions among viewers.",
              "tokensUsed": {
                "total": 605,
                "prompt": 559,
                "completion": 46,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"You know, TypeScript's like the trendy coffee everyone raves about, but not everyone needs it. Sure, it adds type safety, but is it always necessary?\\\",\\\"visualDirection\\\":\\\"Close-up of someone holding a cup of coffee, looking skeptical.\\\",\\\"mood\\\":\\\"Curious\\\"},{\\\"text\\\":\\\"For small projects, plain JavaScript is often quicker and just as effective. Why complicate it with TypeScript when you don't have to?\\\",\\\"visualDirection\\\":\\\"Fast cuts between a small project on a laptop and a person shrugging.\\\",\\\"mood\\\":\\\"Pragmatic\\\"},{\\\"text\\\":\\\"And let's be real, TypeScript can slow you down with its learning curve. Not everyone has time for that!\\\",\\\"visualDirection\\\":\\\"Show someone overwhelmed with books and tutorials.\\\",\\\"mood\\\":\\\"Relatable\\\"},{\\\"text\\\":\\\"Don't get me wrong, TypeScript's great for big projects with large teams. But for solo devs, it might just be overkill.\\\",\\\"visualDirection\\\":\\\"Split screen: one side a solo developer, the other a large team working.\\\",\\\"mood\\\":\\\"Balanced\\\"},{\\\"text\\\":\\\"So, before jumping on the TypeScript bandwagon, ask yourself: Do you really need it? Sometimes, simpler is better.\\\",\\\"visualDirection\\\":\\\"Person pondering with a thought bubble showing JavaScript and TypeScript logos.\\\",\\\"mood\\\":\\\"Thought-provoking\\\"}],\\\"reasoning\\\":\\\"TypeScript is often seen as essential, but for small projects, its complexity can be unnecessary. Simplicity and speed are sometimes more beneficial.\\\",\\\"title\\\":\\\"Is TypeScript Overrated?\\\",\\\"hook\\\":\\\"TypeScript is kinda overrated for small projects.\\\",\\\"cta\\\":\\\"What's your take on TypeScript? Let me know in the comments!\\\",\\\"hashtags\\\":[\\\"#TypeScript\\\",\\\"#JavaScript\\\",\\\"#CodingOpinions\\\"]}\\n</Output>\\n<Rubric>\\nThe script opens with a bold, controversial statement that will spark debate.\\nIt should immediately make viewers want to comment (agree or disagree).\\n\\n</Rubric>\"}]"
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "Despite being a hot take, the script provides actual reasoning and evidence.\nIt's not just rage bait; there should be substance behind the opinion.\n",
                "threshold": 0.7,
                "weight": 2
              },
              "pass": true,
              "score": 1,
              "reason": "The script discusses the pros and cons of TypeScript, providing reasoning about its necessity for small projects versus larger ones, and emphasizes the importance of simplicity and speed.",
              "tokensUsed": {
                "total": 609,
                "prompt": 560,
                "completion": 49,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"You know, TypeScript's like the trendy coffee everyone raves about, but not everyone needs it. Sure, it adds type safety, but is it always necessary?\\\",\\\"visualDirection\\\":\\\"Close-up of someone holding a cup of coffee, looking skeptical.\\\",\\\"mood\\\":\\\"Curious\\\"},{\\\"text\\\":\\\"For small projects, plain JavaScript is often quicker and just as effective. Why complicate it with TypeScript when you don't have to?\\\",\\\"visualDirection\\\":\\\"Fast cuts between a small project on a laptop and a person shrugging.\\\",\\\"mood\\\":\\\"Pragmatic\\\"},{\\\"text\\\":\\\"And let's be real, TypeScript can slow you down with its learning curve. Not everyone has time for that!\\\",\\\"visualDirection\\\":\\\"Show someone overwhelmed with books and tutorials.\\\",\\\"mood\\\":\\\"Relatable\\\"},{\\\"text\\\":\\\"Don't get me wrong, TypeScript's great for big projects with large teams. But for solo devs, it might just be overkill.\\\",\\\"visualDirection\\\":\\\"Split screen: one side a solo developer, the other a large team working.\\\",\\\"mood\\\":\\\"Balanced\\\"},{\\\"text\\\":\\\"So, before jumping on the TypeScript bandwagon, ask yourself: Do you really need it? Sometimes, simpler is better.\\\",\\\"visualDirection\\\":\\\"Person pondering with a thought bubble showing JavaScript and TypeScript logos.\\\",\\\"mood\\\":\\\"Thought-provoking\\\"}],\\\"reasoning\\\":\\\"TypeScript is often seen as essential, but for small projects, its complexity can be unnecessary. Simplicity and speed are sometimes more beneficial.\\\",\\\"title\\\":\\\"Is TypeScript Overrated?\\\",\\\"hook\\\":\\\"TypeScript is kinda overrated for small projects.\\\",\\\"cta\\\":\\\"What's your take on TypeScript? Let me know in the comments!\\\",\\\"hashtags\\\":[\\\"#TypeScript\\\",\\\"#JavaScript\\\",\\\"#CodingOpinions\\\"]}\\n</Output>\\n<Rubric>\\nDespite being a hot take, the script provides actual reasoning and evidence.\\nIt's not just rage bait; there should be substance behind the opinion.\\n\\n</Rubric>\"}]"
              }
            }
          ]
        },
        "id": "ef1c26a9-8064-4a0c-958f-f7727cde491c",
        "latencyMs": 5808,
        "namedScores": {},
        "prompt": {
          "raw": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"TypeScript is overrated\"\n\nFORMAT: hot-take\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Total spoken word count must be between 90-150 words.\n- Use short sentences (<=15 words) and one idea per sentence.\n- Each scene should be 2 sentences and ~22-30 words (minimum 20 words per scene).\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n- Scene 1 must continue after the hook with NEW information (no restating or paraphrasing the hook).\n- Each scene text must be at least 20 words.\n- Double-check total word count before responding.\n- Hook must be a statement (no question mark).\n\n\n\n\n\n\n\nLead with a provocative opinion, then back it up with reasoning.\n\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n- Each scene text must be at least 20 words.\n- Hook must be a statement (no question mark).\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n",
          "label": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"{{ topic }}\"\n\nFORMAT: {{ archetype }}\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Total spoken word count must be between 90-150 words.\n- Use short sentences (<=15 words) and one idea per sentence.\n- Each scene should be 2 sentences and ~22-30 words (minimum 20 words per scene).\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n- Scene 1 must continue after the hook with NEW information (no restating or paraphrasing the hook).\n- Each scene text must be at least 20 words.\n- Double-check total word count before responding.\n- Hook must be a statement (no question mark).\n\n{% if archetype == \"listicle\" %}\nStructure as a numbered list with a hook, clear items, and a call-to-action.\nPrefix each point with an explicit number label (e.g., \"Tip 1:\", \"2)\", \"Number 3:\").\n{% endif %}\n{% if archetype == \"versus\" %}\nPresent a balanced comparison with a clear recommendation at the end.\nThe hook should be a bold statement, not a question.\n{% endif %}\n{% if archetype == \"howto\" %}\nGive step-by-step instructions that are easy to follow.\n{% endif %}\n{% if archetype == \"myth\" %}\nStart with the myth, then reveal the reality with evidence.\nUse explicit \"Myth: X\" and \"Reality: Y\" phrasing in scene text.\n{% endif %}\n{% if archetype == \"story\" %}\nUse narrative structure: setup, conflict, resolution.\n{% endif %}\n{% if archetype == \"hot-take\" %}\nLead with a provocative opinion, then back it up with reasoning.\n{% endif %}\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n- Each scene text must be at least 20 words.\n- Hook must be a statement (no question mark).\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n"
        },
        "promptId": "3a2330721e33f906bebc9d49df16221c36cfd3cebbbc91ec115733487d847736",
        "promptIdx": 0,
        "provider": {
          "id": "openai:gpt-4o",
          "label": ""
        },
        "response": {
          "output": "{\n  \"scenes\": [\n    {\n      \"text\": \"You know, TypeScript's like the trendy coffee everyone raves about, but not everyone needs it. Sure, it adds type safety, but is it always necessary?\",\n      \"visualDirection\": \"Close-up of someone holding a cup of coffee, looking skeptical.\",\n      \"mood\": \"Curious\"\n    },\n    {\n      \"text\": \"For small projects, plain JavaScript is often quicker and just as effective. Why complicate it with TypeScript when you don't have to?\",\n      \"visualDirection\": \"Fast cuts between a small project on a laptop and a person shrugging.\",\n      \"mood\": \"Pragmatic\"\n    },\n    {\n      \"text\": \"And let's be real, TypeScript can slow you down with its learning curve. Not everyone has time for that!\",\n      \"visualDirection\": \"Show someone overwhelmed with books and tutorials.\",\n      \"mood\": \"Relatable\"\n    },\n    {\n      \"text\": \"Don't get me wrong, TypeScript's great for big projects with large teams. But for solo devs, it might just be overkill.\",\n      \"visualDirection\": \"Split screen: one side a solo developer, the other a large team working.\",\n      \"mood\": \"Balanced\"\n    },\n    {\n      \"text\": \"So, before jumping on the TypeScript bandwagon, ask yourself: Do you really need it? Sometimes, simpler is better.\",\n      \"visualDirection\": \"Person pondering with a thought bubble showing JavaScript and TypeScript logos.\",\n      \"mood\": \"Thought-provoking\"\n    }\n  ],\n  \"reasoning\": \"TypeScript is often seen as essential, but for small projects, its complexity can be unnecessary. Simplicity and speed are sometimes more beneficial.\",\n  \"title\": \"Is TypeScript Overrated?\",\n  \"hook\": \"TypeScript is kinda overrated for small projects.\",\n  \"cta\": \"What's your take on TypeScript? Let me know in the comments!\",\n  \"hashtags\": [\"#TypeScript\", \"#JavaScript\", \"#CodingOpinions\"]\n}",
          "tokenUsage": {
            "total": 932,
            "prompt": 498,
            "completion": 434,
            "numRequests": 1,
            "completionDetails": {
              "reasoning": 0,
              "acceptedPrediction": 0,
              "rejectedPrediction": 0
            }
          },
          "cached": false,
          "latencyMs": 5808,
          "finishReason": "stop",
          "cost": 0.005585,
          "guardrails": {
            "flagged": false
          }
        },
        "score": 1,
        "success": true,
        "testCase": {
          "vars": {
            "topic": "TypeScript is overrated",
            "archetype": "hot-take"
          },
          "assert": [
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return (\n    Array.isArray(script.scenes) &&\n    script.scenes.length >= 3 &&\n    script.scenes.length <= 7\n  );\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 90 && wordCount <= 150;\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return (script.scenes || []).every((scene) =>\n    typeof scene.visualDirection === 'string' && scene.visualDirection.trim().length > 5\n  );\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean)\n    .join(' ');\n  const hasEmoji = /\\p{Extended_Pictographic}/u.test(spoken);\n  const hasMarkdown = /[`*_]/.test(spoken) || /\\[(.+?)\\]\\((.+?)\\)/.test(spoken);\n  const hasHashtag = /(^|\\s)#\\w+/.test(spoken);\n  return !hasEmoji && !hasMarkdown && !hasHashtag;\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return typeof script.reasoning === 'string' && script.reasoning.trim().length > 10;\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "llm-rubric",
              "value": "The script opens with a bold, controversial statement that will spark debate.\nIt should immediately make viewers want to comment (agree or disagree).\n",
              "threshold": 0.8,
              "weight": 2
            },
            {
              "type": "llm-rubric",
              "value": "Despite being a hot take, the script provides actual reasoning and evidence.\nIt's not just rage bait; there should be substance behind the opinion.\n",
              "threshold": 0.7,
              "weight": 2
            }
          ],
          "options": {
            "provider": "openai:gpt-4o-mini"
          },
          "metadata": {}
        },
        "testIdx": 3,
        "vars": {
          "topic": "TypeScript is overrated",
          "archetype": "hot-take"
        },
        "metadata": {
          "_promptfooFileMetadata": {}
        },
        "failureReason": 0
      },
      {
        "cost": 0.006022500000000001,
        "gradingResult": {
          "pass": true,
          "score": 1,
          "reason": "All assertions passed",
          "namedScores": {},
          "tokensUsed": {
            "total": 1278,
            "prompt": 1190,
            "completion": 88,
            "cached": 0,
            "numRequests": 2
          },
          "componentResults": [
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return (\n    Array.isArray(script.scenes) &&\n    script.scenes.length >= 3 &&\n    script.scenes.length <= 7\n  );\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 90 && wordCount <= 150;\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return (script.scenes || []).every((scene) =>\n    typeof scene.visualDirection === 'string' && scene.visualDirection.trim().length > 5\n  );\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean)\n    .join(' ');\n  const hasEmoji = /\\p{Extended_Pictographic}/u.test(spoken);\n  const hasMarkdown = /[`*_]/.test(spoken) || /\\[(.+?)\\]\\((.+?)\\)/.test(spoken);\n  const hasHashtag = /(^|\\s)#\\w+/.test(spoken);\n  return !hasEmoji && !hasMarkdown && !hasHashtag;\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return typeof script.reasoning === 'string' && script.reasoning.trim().length > 10;\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "The script has clear, sequential steps that are easy to follow.\nEach step should be actionable and specific.\n",
                "threshold": 0.8,
                "weight": 2
              },
              "pass": true,
              "score": 1,
              "reason": "The script outlines clear, sequential steps for deploying a Node.js app with specific commands, making it easy to follow and actionable.",
              "tokensUsed": {
                "total": 634,
                "prompt": 592,
                "completion": 42,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"Got a Node.js app ready? Let's deploy it fast with Heroku and Git. Start by creating an account on Heroku, if you don't have one yet.\\\",\\\"visualDirection\\\":\\\"Show a computer screen with Heroku's homepage and the sign-up process.\\\",\\\"mood\\\":\\\"Exciting and fast-paced\\\"},{\\\"text\\\":\\\"Next, install the Heroku CLI on your machine. Open your terminal, and run the command to log in to Heroku.\\\",\\\"visualDirection\\\":\\\"Display terminal window with Heroku CLI installation and login commands being executed.\\\",\\\"mood\\\":\\\"Straightforward and instructional\\\"},{\\\"text\\\":\\\"Navigate to your app's directory in the terminal. Run 'git init', then 'heroku create', to prepare for deployment.\\\",\\\"visualDirection\\\":\\\"Terminal showing 'git init' and 'heroku create' commands with success messages.\\\",\\\"mood\\\":\\\"Empowering and step-by-step\\\"},{\\\"text\\\":\\\"Add all your files with 'git add dot'. Commit them with a quick message. You're almost there, just hang on.\\\",\\\"visualDirection\\\":\\\"Terminal showing 'git add .' and 'git commit -m' commands with a progress animation.\\\",\\\"mood\\\":\\\"Motivational and encouraging\\\"},{\\\"text\\\":\\\"Finally, deploy with 'git push heroku main'. In seconds, your app is live. Test by opening the Heroku app URL.\\\",\\\"visualDirection\\\":\\\"Terminal showing 'git push heroku main' followed by a browser opening the app URL.\\\",\\\"mood\\\":\\\"Triumphant and satisfying\\\"}],\\\"reasoning\\\":\\\"The script provides a concise and engaging step-by-step guide to deploying a Node.js app using Heroku. It also maintains a conversational tone suitable for TikTok-style videos.\\\",\\\"title\\\":\\\"Deploy a Node.js App in 5 Minutes\\\",\\\"hook\\\":\\\"Want to deploy your Node.js app super fast? Here's how in just five minutes.\\\",\\\"cta\\\":\\\"Deploy your app now and share your results in the comments!\\\",\\\"hashtags\\\":[\\\"#NodeJS\\\",\\\"#Heroku\\\",\\\"#AppDeployment\\\"]}\\n</Output>\\n<Rubric>\\nThe script has clear, sequential steps that are easy to follow.\\nEach step should be actionable and specific.\\n\\n</Rubric>\"}]"
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "The visual directions show what the viewer should be doing at each step.\nThis could include screen recordings, terminal commands, or UI interactions.\n",
                "threshold": 0.8,
                "weight": 1
              },
              "pass": true,
              "score": 1,
              "reason": "The visual directions describe specific actions the viewer should take at each step, such as showing terminal commands and UI interactions with Heroku, which aligns with the rubric criteria.",
              "tokensUsed": {
                "total": 644,
                "prompt": 598,
                "completion": 46,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"Got a Node.js app ready? Let's deploy it fast with Heroku and Git. Start by creating an account on Heroku, if you don't have one yet.\\\",\\\"visualDirection\\\":\\\"Show a computer screen with Heroku's homepage and the sign-up process.\\\",\\\"mood\\\":\\\"Exciting and fast-paced\\\"},{\\\"text\\\":\\\"Next, install the Heroku CLI on your machine. Open your terminal, and run the command to log in to Heroku.\\\",\\\"visualDirection\\\":\\\"Display terminal window with Heroku CLI installation and login commands being executed.\\\",\\\"mood\\\":\\\"Straightforward and instructional\\\"},{\\\"text\\\":\\\"Navigate to your app's directory in the terminal. Run 'git init', then 'heroku create', to prepare for deployment.\\\",\\\"visualDirection\\\":\\\"Terminal showing 'git init' and 'heroku create' commands with success messages.\\\",\\\"mood\\\":\\\"Empowering and step-by-step\\\"},{\\\"text\\\":\\\"Add all your files with 'git add dot'. Commit them with a quick message. You're almost there, just hang on.\\\",\\\"visualDirection\\\":\\\"Terminal showing 'git add .' and 'git commit -m' commands with a progress animation.\\\",\\\"mood\\\":\\\"Motivational and encouraging\\\"},{\\\"text\\\":\\\"Finally, deploy with 'git push heroku main'. In seconds, your app is live. Test by opening the Heroku app URL.\\\",\\\"visualDirection\\\":\\\"Terminal showing 'git push heroku main' followed by a browser opening the app URL.\\\",\\\"mood\\\":\\\"Triumphant and satisfying\\\"}],\\\"reasoning\\\":\\\"The script provides a concise and engaging step-by-step guide to deploying a Node.js app using Heroku. It also maintains a conversational tone suitable for TikTok-style videos.\\\",\\\"title\\\":\\\"Deploy a Node.js App in 5 Minutes\\\",\\\"hook\\\":\\\"Want to deploy your Node.js app super fast? Here's how in just five minutes.\\\",\\\"cta\\\":\\\"Deploy your app now and share your results in the comments!\\\",\\\"hashtags\\\":[\\\"#NodeJS\\\",\\\"#Heroku\\\",\\\"#AppDeployment\\\"]}\\n</Output>\\n<Rubric>\\nThe visual directions show what the viewer should be doing at each step.\\nThis could include screen recordings, terminal commands, or UI interactions.\\n\\n</Rubric>\"}]"
              }
            }
          ]
        },
        "id": "347f8c84-45b6-4966-861e-d5e578c3f721",
        "latencyMs": 5784,
        "namedScores": {},
        "prompt": {
          "raw": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"How to deploy a Node.js app in 5 minutes\"\n\nFORMAT: howto\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Total spoken word count must be between 90-150 words.\n- Use short sentences (<=15 words) and one idea per sentence.\n- Each scene should be 2 sentences and ~22-30 words (minimum 20 words per scene).\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n- Scene 1 must continue after the hook with NEW information (no restating or paraphrasing the hook).\n- Each scene text must be at least 20 words.\n- Double-check total word count before responding.\n- Hook must be a statement (no question mark).\n\n\n\n\nGive step-by-step instructions that are easy to follow.\n\n\n\n\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n- Each scene text must be at least 20 words.\n- Hook must be a statement (no question mark).\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n",
          "label": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"{{ topic }}\"\n\nFORMAT: {{ archetype }}\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Total spoken word count must be between 90-150 words.\n- Use short sentences (<=15 words) and one idea per sentence.\n- Each scene should be 2 sentences and ~22-30 words (minimum 20 words per scene).\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n- Scene 1 must continue after the hook with NEW information (no restating or paraphrasing the hook).\n- Each scene text must be at least 20 words.\n- Double-check total word count before responding.\n- Hook must be a statement (no question mark).\n\n{% if archetype == \"listicle\" %}\nStructure as a numbered list with a hook, clear items, and a call-to-action.\nPrefix each point with an explicit number label (e.g., \"Tip 1:\", \"2)\", \"Number 3:\").\n{% endif %}\n{% if archetype == \"versus\" %}\nPresent a balanced comparison with a clear recommendation at the end.\nThe hook should be a bold statement, not a question.\n{% endif %}\n{% if archetype == \"howto\" %}\nGive step-by-step instructions that are easy to follow.\n{% endif %}\n{% if archetype == \"myth\" %}\nStart with the myth, then reveal the reality with evidence.\nUse explicit \"Myth: X\" and \"Reality: Y\" phrasing in scene text.\n{% endif %}\n{% if archetype == \"story\" %}\nUse narrative structure: setup, conflict, resolution.\n{% endif %}\n{% if archetype == \"hot-take\" %}\nLead with a provocative opinion, then back it up with reasoning.\n{% endif %}\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n- Each scene text must be at least 20 words.\n- Hook must be a statement (no question mark).\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n"
        },
        "promptId": "3a2330721e33f906bebc9d49df16221c36cfd3cebbbc91ec115733487d847736",
        "promptIdx": 0,
        "provider": {
          "id": "openai:gpt-4o",
          "label": ""
        },
        "response": {
          "output": "{\n  \"scenes\": [\n    {\n      \"text\": \"Got a Node.js app ready? Let's deploy it fast with Heroku and Git. Start by creating an account on Heroku, if you don't have one yet.\",\n      \"visualDirection\": \"Show a computer screen with Heroku's homepage and the sign-up process.\",\n      \"mood\": \"Exciting and fast-paced\"\n    },\n    {\n      \"text\": \"Next, install the Heroku CLI on your machine. Open your terminal, and run the command to log in to Heroku.\",\n      \"visualDirection\": \"Display terminal window with Heroku CLI installation and login commands being executed.\",\n      \"mood\": \"Straightforward and instructional\"\n    },\n    {\n      \"text\": \"Navigate to your app's directory in the terminal. Run 'git init', then 'heroku create', to prepare for deployment.\",\n      \"visualDirection\": \"Terminal showing 'git init' and 'heroku create' commands with success messages.\",\n      \"mood\": \"Empowering and step-by-step\"\n    },\n    {\n      \"text\": \"Add all your files with 'git add dot'. Commit them with a quick message. You're almost there, just hang on.\",\n      \"visualDirection\": \"Terminal showing 'git add .' and 'git commit -m' commands with a progress animation.\",\n      \"mood\": \"Motivational and encouraging\"\n    },\n    {\n      \"text\": \"Finally, deploy with 'git push heroku main'. In seconds, your app is live. Test by opening the Heroku app URL.\",\n      \"visualDirection\": \"Terminal showing 'git push heroku main' followed by a browser opening the app URL.\",\n      \"mood\": \"Triumphant and satisfying\"\n    }\n  ],\n  \"reasoning\": \"The script provides a concise and engaging step-by-step guide to deploying a Node.js app using Heroku. It also maintains a conversational tone suitable for TikTok-style videos.\",\n  \"title\": \"Deploy a Node.js App in 5 Minutes\",\n  \"hook\": \"Want to deploy your Node.js app super fast? Here's how in just five minutes.\",\n  \"cta\": \"Deploy your app now and share your results in the comments!\",\n  \"hashtags\": [\"#NodeJS\", \"#Heroku\", \"#AppDeployment\"]\n}",
          "tokenUsage": {
            "total": 978,
            "prompt": 501,
            "completion": 477,
            "numRequests": 1,
            "completionDetails": {
              "reasoning": 0,
              "acceptedPrediction": 0,
              "rejectedPrediction": 0
            }
          },
          "cached": false,
          "latencyMs": 5784,
          "finishReason": "stop",
          "cost": 0.006022500000000001,
          "guardrails": {
            "flagged": false
          }
        },
        "score": 1,
        "success": true,
        "testCase": {
          "vars": {
            "topic": "How to deploy a Node.js app in 5 minutes",
            "archetype": "howto"
          },
          "assert": [
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return (\n    Array.isArray(script.scenes) &&\n    script.scenes.length >= 3 &&\n    script.scenes.length <= 7\n  );\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 90 && wordCount <= 150;\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return (script.scenes || []).every((scene) =>\n    typeof scene.visualDirection === 'string' && scene.visualDirection.trim().length > 5\n  );\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean)\n    .join(' ');\n  const hasEmoji = /\\p{Extended_Pictographic}/u.test(spoken);\n  const hasMarkdown = /[`*_]/.test(spoken) || /\\[(.+?)\\]\\((.+?)\\)/.test(spoken);\n  const hasHashtag = /(^|\\s)#\\w+/.test(spoken);\n  return !hasEmoji && !hasMarkdown && !hasHashtag;\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return typeof script.reasoning === 'string' && script.reasoning.trim().length > 10;\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "llm-rubric",
              "value": "The script has clear, sequential steps that are easy to follow.\nEach step should be actionable and specific.\n",
              "threshold": 0.8,
              "weight": 2
            },
            {
              "type": "llm-rubric",
              "value": "The visual directions show what the viewer should be doing at each step.\nThis could include screen recordings, terminal commands, or UI interactions.\n",
              "threshold": 0.8,
              "weight": 1
            }
          ],
          "options": {
            "provider": "openai:gpt-4o-mini"
          },
          "metadata": {}
        },
        "testIdx": 4,
        "vars": {
          "topic": "How to deploy a Node.js app in 5 minutes",
          "archetype": "howto"
        },
        "metadata": {
          "_promptfooFileMetadata": {}
        },
        "failureReason": 0
      },
      {
        "cost": 0.0049475000000000005,
        "gradingResult": {
          "pass": true,
          "score": 1,
          "reason": "All assertions passed",
          "namedScores": {},
          "tokensUsed": {
            "total": 1090,
            "prompt": 998,
            "completion": 92,
            "cached": 0,
            "numRequests": 2
          },
          "componentResults": [
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return (\n    Array.isArray(script.scenes) &&\n    script.scenes.length >= 3 &&\n    script.scenes.length <= 7\n  );\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 90 && wordCount <= 150;\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return (script.scenes || []).every((scene) =>\n    typeof scene.visualDirection === 'string' && scene.visualDirection.trim().length > 5\n  );\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean)\n    .join(' ');\n  const hasEmoji = /\\p{Extended_Pictographic}/u.test(spoken);\n  const hasMarkdown = /[`*_]/.test(spoken) || /\\[(.+?)\\]\\((.+?)\\)/.test(spoken);\n  const hasHashtag = /(^|\\s)#\\w+/.test(spoken);\n  return !hasEmoji && !hasMarkdown && !hasHashtag;\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return typeof script.reasoning === 'string' && script.reasoning.trim().length > 10;\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "The script clearly states the myth, then definitively debunks it.\nThe structure should be \"Myth: X / Reality: Y\" or similar.\n",
                "threshold": 0.8,
                "weight": 2
              },
              "pass": true,
              "score": 1,
              "reason": "The script clearly states the myth in the hook and then provides a reality that debunks the myth in subsequent scenes, following the required structure.",
              "tokensUsed": {
                "total": 548,
                "prompt": 503,
                "completion": 45,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"Myth: You need a computer science degree to be a developer. Think coding bootcamps and online courses aren't enough? Let's bust that.\\\",\\\"visualDirection\\\":\\\"Show a split screen: one side a diploma, the other a laptop with coding bootcamp logos.\\\",\\\"mood\\\":\\\"Intriguing\\\"},{\\\"text\\\":\\\"Reality: Many successful developers don't have a CS degree. Companies like Google hire based on skills, not just diplomas.\\\",\\\"visualDirection\\\":\\\"Show screenshots of corporate websites with headlines about non-degree hires.\\\",\\\"mood\\\":\\\"Revealing\\\"},{\\\"text\\\":\\\"Coding bootcamps and self-study can get you there. They teach practical skills that employers value, fast.\\\",\\\"visualDirection\\\":\\\"Show someone coding on a laptop, with certificates from online courses around them.\\\",\\\"mood\\\":\\\"Empowering\\\"},{\\\"text\\\":\\\"Real skills matter more than paper. Focus on building projects, contributing to open source, and networking.\\\",\\\"visualDirection\\\":\\\"Show a montage of coding projects and network events.\\\",\\\"mood\\\":\\\"Motivational\\\"}],\\\"reasoning\\\":\\\"The script dispels the myth that a CS degree is necessary for a career in development by highlighting alternative learning paths and industry trends.\\\",\\\"title\\\":\\\"Do You Really Need a CS Degree to Code?\\\",\\\"hook\\\":\\\"Myth: You need a CS degree to be a developer.\\\",\\\"cta\\\":\\\"Don't wait for a degree. Start coding today and level up your skills.\\\",\\\"hashtags\\\":[\\\"#CodingMyths\\\",\\\"#DeveloperLife\\\",\\\"#LearnToCode\\\"]}\\n</Output>\\n<Rubric>\\nThe script clearly states the myth, then definitively debunks it.\\nThe structure should be \\\"Myth: X / Reality: Y\\\" or similar.\\n\\n</Rubric>\"}]"
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "The debunking includes evidence, examples, or statistics.\nIt's not just opinion; there should be factual backing.\n",
                "threshold": 0.7,
                "weight": 1
              },
              "pass": true,
              "score": 1,
              "reason": "The output includes references to successful developers without a CS degree and mentions companies like Google hiring based on skills, which acts as factual backing for the argument.",
              "tokensUsed": {
                "total": 542,
                "prompt": 495,
                "completion": 47,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"Myth: You need a computer science degree to be a developer. Think coding bootcamps and online courses aren't enough? Let's bust that.\\\",\\\"visualDirection\\\":\\\"Show a split screen: one side a diploma, the other a laptop with coding bootcamp logos.\\\",\\\"mood\\\":\\\"Intriguing\\\"},{\\\"text\\\":\\\"Reality: Many successful developers don't have a CS degree. Companies like Google hire based on skills, not just diplomas.\\\",\\\"visualDirection\\\":\\\"Show screenshots of corporate websites with headlines about non-degree hires.\\\",\\\"mood\\\":\\\"Revealing\\\"},{\\\"text\\\":\\\"Coding bootcamps and self-study can get you there. They teach practical skills that employers value, fast.\\\",\\\"visualDirection\\\":\\\"Show someone coding on a laptop, with certificates from online courses around them.\\\",\\\"mood\\\":\\\"Empowering\\\"},{\\\"text\\\":\\\"Real skills matter more than paper. Focus on building projects, contributing to open source, and networking.\\\",\\\"visualDirection\\\":\\\"Show a montage of coding projects and network events.\\\",\\\"mood\\\":\\\"Motivational\\\"}],\\\"reasoning\\\":\\\"The script dispels the myth that a CS degree is necessary for a career in development by highlighting alternative learning paths and industry trends.\\\",\\\"title\\\":\\\"Do You Really Need a CS Degree to Code?\\\",\\\"hook\\\":\\\"Myth: You need a CS degree to be a developer.\\\",\\\"cta\\\":\\\"Don't wait for a degree. Start coding today and level up your skills.\\\",\\\"hashtags\\\":[\\\"#CodingMyths\\\",\\\"#DeveloperLife\\\",\\\"#LearnToCode\\\"]}\\n</Output>\\n<Rubric>\\nThe debunking includes evidence, examples, or statistics.\\nIt's not just opinion; there should be factual backing.\\n\\n</Rubric>\"}]"
              }
            }
          ]
        },
        "id": "bd602c55-ac81-4d40-a204-169ffd37ae49",
        "latencyMs": 6647,
        "namedScores": {},
        "prompt": {
          "raw": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"You need a CS degree to be a developer\"\n\nFORMAT: myth\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Total spoken word count must be between 90-150 words.\n- Use short sentences (<=15 words) and one idea per sentence.\n- Each scene should be 2 sentences and ~22-30 words (minimum 20 words per scene).\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n- Scene 1 must continue after the hook with NEW information (no restating or paraphrasing the hook).\n- Each scene text must be at least 20 words.\n- Double-check total word count before responding.\n- Hook must be a statement (no question mark).\n\n\n\n\n\nStart with the myth, then reveal the reality with evidence.\nUse explicit \"Myth: X\" and \"Reality: Y\" phrasing in scene text.\n\n\n\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n- Each scene text must be at least 20 words.\n- Hook must be a statement (no question mark).\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n",
          "label": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"{{ topic }}\"\n\nFORMAT: {{ archetype }}\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Total spoken word count must be between 90-150 words.\n- Use short sentences (<=15 words) and one idea per sentence.\n- Each scene should be 2 sentences and ~22-30 words (minimum 20 words per scene).\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n- Scene 1 must continue after the hook with NEW information (no restating or paraphrasing the hook).\n- Each scene text must be at least 20 words.\n- Double-check total word count before responding.\n- Hook must be a statement (no question mark).\n\n{% if archetype == \"listicle\" %}\nStructure as a numbered list with a hook, clear items, and a call-to-action.\nPrefix each point with an explicit number label (e.g., \"Tip 1:\", \"2)\", \"Number 3:\").\n{% endif %}\n{% if archetype == \"versus\" %}\nPresent a balanced comparison with a clear recommendation at the end.\nThe hook should be a bold statement, not a question.\n{% endif %}\n{% if archetype == \"howto\" %}\nGive step-by-step instructions that are easy to follow.\n{% endif %}\n{% if archetype == \"myth\" %}\nStart with the myth, then reveal the reality with evidence.\nUse explicit \"Myth: X\" and \"Reality: Y\" phrasing in scene text.\n{% endif %}\n{% if archetype == \"story\" %}\nUse narrative structure: setup, conflict, resolution.\n{% endif %}\n{% if archetype == \"hot-take\" %}\nLead with a provocative opinion, then back it up with reasoning.\n{% endif %}\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n- Each scene text must be at least 20 words.\n- Hook must be a statement (no question mark).\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n"
        },
        "promptId": "3a2330721e33f906bebc9d49df16221c36cfd3cebbbc91ec115733487d847736",
        "promptIdx": 0,
        "provider": {
          "id": "openai:gpt-4o",
          "label": ""
        },
        "response": {
          "output": "{\n  \"scenes\": [\n    {\n      \"text\": \"Myth: You need a computer science degree to be a developer. Think coding bootcamps and online courses aren't enough? Let's bust that.\",\n      \"visualDirection\": \"Show a split screen: one side a diploma, the other a laptop with coding bootcamp logos.\",\n      \"mood\": \"Intriguing\"\n    },\n    {\n      \"text\": \"Reality: Many successful developers don't have a CS degree. Companies like Google hire based on skills, not just diplomas.\",\n      \"visualDirection\": \"Show screenshots of corporate websites with headlines about non-degree hires.\",\n      \"mood\": \"Revealing\"\n    },\n    {\n      \"text\": \"Coding bootcamps and self-study can get you there. They teach practical skills that employers value, fast.\",\n      \"visualDirection\": \"Show someone coding on a laptop, with certificates from online courses around them.\",\n      \"mood\": \"Empowering\"\n    },\n    {\n      \"text\": \"Real skills matter more than paper. Focus on building projects, contributing to open source, and networking.\",\n      \"visualDirection\": \"Show a montage of coding projects and network events.\",\n      \"mood\": \"Motivational\"\n    }\n  ],\n  \"reasoning\": \"The script dispels the myth that a CS degree is necessary for a career in development by highlighting alternative learning paths and industry trends.\",\n  \"title\": \"Do You Really Need a CS Degree to Code?\",\n  \"hook\": \"Myth: You need a CS degree to be a developer.\",\n  \"cta\": \"Don't wait for a degree. Start coding today and level up your skills.\",\n  \"hashtags\": [\"#CodingMyths\", \"#DeveloperLife\", \"#LearnToCode\"]\n}",
          "tokenUsage": {
            "total": 884,
            "prompt": 519,
            "completion": 365,
            "numRequests": 1,
            "completionDetails": {
              "reasoning": 0,
              "acceptedPrediction": 0,
              "rejectedPrediction": 0
            }
          },
          "cached": false,
          "latencyMs": 6647,
          "finishReason": "stop",
          "cost": 0.0049475000000000005,
          "guardrails": {
            "flagged": false
          }
        },
        "score": 1,
        "success": true,
        "testCase": {
          "vars": {
            "topic": "You need a CS degree to be a developer",
            "archetype": "myth"
          },
          "assert": [
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return (\n    Array.isArray(script.scenes) &&\n    script.scenes.length >= 3 &&\n    script.scenes.length <= 7\n  );\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 90 && wordCount <= 150;\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return (script.scenes || []).every((scene) =>\n    typeof scene.visualDirection === 'string' && scene.visualDirection.trim().length > 5\n  );\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean)\n    .join(' ');\n  const hasEmoji = /\\p{Extended_Pictographic}/u.test(spoken);\n  const hasMarkdown = /[`*_]/.test(spoken) || /\\[(.+?)\\]\\((.+?)\\)/.test(spoken);\n  const hasHashtag = /(^|\\s)#\\w+/.test(spoken);\n  return !hasEmoji && !hasMarkdown && !hasHashtag;\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return typeof script.reasoning === 'string' && script.reasoning.trim().length > 10;\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "llm-rubric",
              "value": "The script clearly states the myth, then definitively debunks it.\nThe structure should be \"Myth: X / Reality: Y\" or similar.\n",
              "threshold": 0.8,
              "weight": 2
            },
            {
              "type": "llm-rubric",
              "value": "The debunking includes evidence, examples, or statistics.\nIt's not just opinion; there should be factual backing.\n",
              "threshold": 0.7,
              "weight": 1
            }
          ],
          "options": {
            "provider": "openai:gpt-4o-mini"
          },
          "metadata": {}
        },
        "testIdx": 5,
        "vars": {
          "topic": "You need a CS degree to be a developer",
          "archetype": "myth"
        },
        "metadata": {
          "_promptfooFileMetadata": {}
        },
        "failureReason": 0
      }
    ],
    "stats": {
      "successes": 4,
      "failures": 2,
      "errors": 0,
      "tokenUsage": {
        "prompt": 3054,
        "completion": 2606,
        "cached": 0,
        "total": 5660,
        "numRequests": 6,
        "completionDetails": {
          "reasoning": 0,
          "acceptedPrediction": 0,
          "rejectedPrediction": 0
        },
        "assertions": {
          "total": 9110,
          "prompt": 8389,
          "completion": 721,
          "cached": 0,
          "numRequests": 0,
          "completionDetails": {
            "reasoning": 0,
            "acceptedPrediction": 0,
            "rejectedPrediction": 0
          }
        }
      },
      "durationMs": 62767
    }
  },
  "config": {
    "tags": {},
    "description": "content-machine script generation quality evaluation",
    "prompts": [
      "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"{{ topic }}\"\n\nFORMAT: {{ archetype }}\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Total spoken word count must be between 90-150 words.\n- Use short sentences (<=15 words) and one idea per sentence.\n- Each scene should be 2 sentences and ~22-30 words (minimum 20 words per scene).\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n- Scene 1 must continue after the hook with NEW information (no restating or paraphrasing the hook).\n- Each scene text must be at least 20 words.\n- Double-check total word count before responding.\n- Hook must be a statement (no question mark).\n\n{% if archetype == \"listicle\" %}\nStructure as a numbered list with a hook, clear items, and a call-to-action.\nPrefix each point with an explicit number label (e.g., \"Tip 1:\", \"2)\", \"Number 3:\").\n{% endif %}\n{% if archetype == \"versus\" %}\nPresent a balanced comparison with a clear recommendation at the end.\nThe hook should be a bold statement, not a question.\n{% endif %}\n{% if archetype == \"howto\" %}\nGive step-by-step instructions that are easy to follow.\n{% endif %}\n{% if archetype == \"myth\" %}\nStart with the myth, then reveal the reality with evidence.\nUse explicit \"Myth: X\" and \"Reality: Y\" phrasing in scene text.\n{% endif %}\n{% if archetype == \"story\" %}\nUse narrative structure: setup, conflict, resolution.\n{% endif %}\n{% if archetype == \"hot-take\" %}\nLead with a provocative opinion, then back it up with reasoning.\n{% endif %}\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n- Each scene text must be at least 20 words.\n- Hook must be a statement (no question mark).\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n"
    ],
    "providers": [
      {
        "id": "openai:gpt-4o",
        "config": {
          "temperature": 0.7,
          "response_format": {
            "type": "json_object"
          }
        }
      }
    ],
    "tests": [
      {
        "vars": {
          "topic": "5 JavaScript tips every developer should know",
          "archetype": "listicle"
        },
        "assert": [
          {
            "type": "llm-rubric",
            "value": "The script opens with an attention-grabbing hook that would stop a TikTok user from scrolling.\nThe first sentence should be surprising, controversial, or promise immediate value.\nScore 0 if it's a generic introduction like \"In this video...\" or \"Today we'll cover...\".\n",
            "threshold": 0.7,
            "weight": 2
          },
          {
            "type": "llm-rubric",
            "value": "The language is casual, conversational, and suitable for TikTok/Reels/Shorts.\nNo corporate jargon, no formal academic language, no \"as a developer\" phrases.\nShould sound like a friend giving advice, not a textbook.\n",
            "threshold": 0.8,
            "weight": 1
          },
          {
            "type": "llm-rubric",
            "value": "Each scene has a specific, filmable visual description.\nVisual directions should describe what the viewer will SEE on screen.\nAvoid abstract concepts that cannot be filmed (like \"efficiency\" or \"code quality\").\n",
            "threshold": 0.8,
            "weight": 1
          },
          {
            "type": "llm-rubric",
            "value": "For a listicle archetype, the script should have a clear numbered structure.\nEach tip should be distinct and actionable.\nThe list should feel complete, not like it was cut off.\n",
            "threshold": 0.8,
            "weight": 1
          }
        ]
      },
      {
        "vars": {
          "topic": "Redis vs PostgreSQL for caching",
          "archetype": "versus"
        },
        "assert": [
          {
            "type": "llm-rubric",
            "value": "The script opens with an attention-grabbing hook.\nFor a versus video, this might be a provocative statement like \"You're using the wrong database\"\nor a relatable problem statement.\n",
            "threshold": 0.7,
            "weight": 2
          },
          {
            "type": "llm-rubric",
            "value": "For a versus archetype, the script should clearly compare both options.\nIt should present pros and cons of each, not just favor one.\nThe comparison should be fair and technically accurate.\n",
            "threshold": 0.8,
            "weight": 2
          },
          {
            "type": "llm-rubric",
            "value": "The script provides a clear recommendation or decision framework at the end.\nViewers should know when to use each option.\n",
            "threshold": 0.7,
            "weight": 1
          }
        ]
      },
      {
        "vars": {
          "topic": "How I learned React in 2 weeks",
          "archetype": "story"
        },
        "assert": [
          {
            "type": "llm-rubric",
            "value": "The script has a narrative arc: setup, challenge, resolution.\nIt should feel like a personal story, not a tutorial.\n",
            "threshold": 0.8,
            "weight": 2
          },
          {
            "type": "llm-rubric",
            "value": "The language uses first-person perspective and includes emotional elements.\nThe viewer should feel connected to the storyteller.\n",
            "threshold": 0.7,
            "weight": 1
          }
        ]
      },
      {
        "vars": {
          "topic": "TypeScript is overrated",
          "archetype": "hot-take"
        },
        "assert": [
          {
            "type": "llm-rubric",
            "value": "The script opens with a bold, controversial statement that will spark debate.\nIt should immediately make viewers want to comment (agree or disagree).\n",
            "threshold": 0.8,
            "weight": 2
          },
          {
            "type": "llm-rubric",
            "value": "Despite being a hot take, the script provides actual reasoning and evidence.\nIt's not just rage bait; there should be substance behind the opinion.\n",
            "threshold": 0.7,
            "weight": 2
          }
        ]
      },
      {
        "vars": {
          "topic": "How to deploy a Node.js app in 5 minutes",
          "archetype": "howto"
        },
        "assert": [
          {
            "type": "llm-rubric",
            "value": "The script has clear, sequential steps that are easy to follow.\nEach step should be actionable and specific.\n",
            "threshold": 0.8,
            "weight": 2
          },
          {
            "type": "llm-rubric",
            "value": "The visual directions show what the viewer should be doing at each step.\nThis could include screen recordings, terminal commands, or UI interactions.\n",
            "threshold": 0.8,
            "weight": 1
          }
        ]
      },
      {
        "vars": {
          "topic": "You need a CS degree to be a developer",
          "archetype": "myth"
        },
        "assert": [
          {
            "type": "llm-rubric",
            "value": "The script clearly states the myth, then definitively debunks it.\nThe structure should be \"Myth: X / Reality: Y\" or similar.\n",
            "threshold": 0.8,
            "weight": 2
          },
          {
            "type": "llm-rubric",
            "value": "The debunking includes evidence, examples, or statistics.\nIt's not just opinion; there should be factual backing.\n",
            "threshold": 0.7,
            "weight": 1
          }
        ]
      }
    ],
    "scenarios": [],
    "env": {},
    "defaultTest": {
      "options": {
        "provider": "openai:gpt-4o-mini"
      },
      "assert": [
        {
          "type": "javascript",
          "value": "try {\n  const script = JSON.parse(output);\n  return (\n    Array.isArray(script.scenes) &&\n    script.scenes.length >= 3 &&\n    script.scenes.length <= 7\n  );\n} catch { return false; }\n",
          "weight": 2
        },
        {
          "type": "javascript",
          "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 90 && wordCount <= 150;\n} catch { return false; }\n",
          "weight": 1
        },
        {
          "type": "javascript",
          "value": "try {\n  const script = JSON.parse(output);\n  return (script.scenes || []).every((scene) =>\n    typeof scene.visualDirection === 'string' && scene.visualDirection.trim().length > 5\n  );\n} catch { return false; }\n",
          "weight": 1
        },
        {
          "type": "javascript",
          "value": "try {\n  const script = JSON.parse(output);\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean)\n    .join(' ');\n  const hasEmoji = /\\p{Extended_Pictographic}/u.test(spoken);\n  const hasMarkdown = /[`*_]/.test(spoken) || /\\[(.+?)\\]\\((.+?)\\)/.test(spoken);\n  const hasHashtag = /(^|\\s)#\\w+/.test(spoken);\n  return !hasEmoji && !hasMarkdown && !hasHashtag;\n} catch { return false; }\n",
          "weight": 2
        },
        {
          "type": "javascript",
          "value": "try {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }\n",
          "weight": 2
        },
        {
          "type": "javascript",
          "value": "try {\n  const script = JSON.parse(output);\n  return typeof script.reasoning === 'string' && script.reasoning.trim().length > 10;\n} catch { return false; }\n",
          "weight": 1
        }
      ],
      "vars": {},
      "metadata": {}
    },
    "outputPath": [],
    "extensions": [],
    "metadata": {},
    "evaluateOptions": {}
  },
  "shareableUrl": null,
  "metadata": {
    "promptfooVersion": "0.120.11",
    "nodeVersion": "v22.16.0",
    "platform": "win32",
    "arch": "x64",
    "exportedAt": "2026-01-10T09:32:32.588Z",
    "evaluationCreatedAt": "2026-01-10T09:30:43.742Z"
  }
}