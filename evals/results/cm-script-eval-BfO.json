{
  "evalId": "eval-BfO-2026-01-10T09:12:36",
  "results": {
    "version": 3,
    "timestamp": "2026-01-10T09:12:36.668Z",
    "prompts": [
      {
        "raw": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"{{ topic }}\"\n\nFORMAT: {{ archetype }}\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Total spoken word count must be between 90-150 words.\n- Use short sentences (<=15 words) and one idea per sentence.\n- Each scene should be 2 sentences and ~22-30 words (minimum 20 words per scene).\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n- Scene 1 must continue after the hook with NEW information (no restating or paraphrasing the hook).\n- Each scene text must be at least 20 words.\n- Double-check total word count before responding.\n\n{% if archetype == \"listicle\" %}\nStructure as a numbered list with a hook, clear items, and a call-to-action.\nPrefix each point with an explicit number label (e.g., \"Tip 1:\", \"2)\", \"Number 3:\").\n{% endif %}\n{% if archetype == \"versus\" %}\nPresent a balanced comparison with a clear recommendation at the end.\nThe hook should be a bold statement, not a question.\n{% endif %}\n{% if archetype == \"howto\" %}\nGive step-by-step instructions that are easy to follow.\n{% endif %}\n{% if archetype == \"myth\" %}\nStart with the myth, then reveal the reality with evidence.\nUse explicit \"Myth: X\" and \"Reality: Y\" phrasing in scene text.\n{% endif %}\n{% if archetype == \"story\" %}\nUse narrative structure: setup, conflict, resolution.\n{% endif %}\n{% if archetype == \"hot-take\" %}\nLead with a provocative opinion, then back it up with reasoning.\n{% endif %}\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n- Each scene text must be at least 20 words.\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n",
        "label": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"{{ topic }}\"\n\nFORMAT: {{ archetype }}\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Total spoken word count must be between 90-150 words.\n- Use short sentences (<=15 words) and one idea per sentence.\n- Each scene should be 2 sentences and ~22-30 words (minimum 20 words per scene).\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n- Scene 1 must continue after the hook with NEW information (no restating or paraphrasing the hook).\n- Each scene text must be at least 20 words.\n- Double-check total word count before responding.\n\n{% if archetype == \"listicle\" %}\nStructure as a numbered list with a hook, clear items, and a call-to-action.\nPrefix each point with an explicit number label (e.g., \"Tip 1:\", \"2)\", \"Number 3:\").\n{% endif %}\n{% if archetype == \"versus\" %}\nPresent a balanced comparison with a clear recommendation at the end.\nThe hook should be a bold statement, not a question.\n{% endif %}\n{% if archetype == \"howto\" %}\nGive step-by-step instructions that are easy to follow.\n{% endif %}\n{% if archetype == \"myth\" %}\nStart with the myth, then reveal the reality with evidence.\nUse explicit \"Myth: X\" and \"Reality: Y\" phrasing in scene text.\n{% endif %}\n{% if archetype == \"story\" %}\nUse narrative structure: setup, conflict, resolution.\n{% endif %}\n{% if archetype == \"hot-take\" %}\nLead with a provocative opinion, then back it up with reasoning.\n{% endif %}\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n- Each scene text must be at least 20 words.\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n",
        "id": "d06ca5ffe45d88de94b47be11ed6547ff6c739ca21958980b959177eed65db1b",
        "provider": "openai:gpt-4o",
        "metrics": {
          "score": 5.712820512820513,
          "testPassCount": 2,
          "testFailCount": 4,
          "testErrorCount": 0,
          "assertPassCount": 53,
          "assertFailCount": 4,
          "totalLatencyMs": 39038,
          "tokenUsage": {
            "prompt": 2919,
            "completion": 2632,
            "cached": 0,
            "total": 5551,
            "numRequests": 6,
            "completionDetails": {
              "reasoning": 0,
              "acceptedPrediction": 0,
              "rejectedPrediction": 0
            },
            "assertions": {
              "total": 9316,
              "prompt": 8538,
              "completion": 778,
              "cached": 0,
              "numRequests": 0,
              "completionDetails": {
                "reasoning": 0,
                "acceptedPrediction": 0,
                "rejectedPrediction": 0
              }
            }
          },
          "namedScores": {},
          "namedScoresCount": {},
          "cost": 0.0336175
        }
      }
    ],
    "results": [
      {
        "cost": 0.005682500000000001,
        "error": "Custom function returned false\ntry {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  return (script.scenes || []).every((scene) => countWords(scene.text) >= 20);\n} catch { return false; }",
        "gradingResult": {
          "pass": false,
          "score": 0.9333333333333333,
          "reason": "Custom function returned false\ntry {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  return (script.scenes || []).every((scene) => countWords(scene.text) >= 20);\n} catch { return false; }",
          "namedScores": {},
          "tokensUsed": {
            "total": 2524,
            "prompt": 2343,
            "completion": 181,
            "cached": 0,
            "numRequests": 4
          },
          "componentResults": [
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return (\n    Array.isArray(script.scenes) &&\n    script.scenes.length >= 3 &&\n    script.scenes.length <= 7\n  );\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 90 && wordCount <= 150;\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return (script.scenes || []).every((scene) =>\n    typeof scene.visualDirection === 'string' && scene.visualDirection.trim().length > 5\n  );\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": false,
              "score": 0,
              "reason": "Custom function returned false\ntry {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  return (script.scenes || []).every((scene) => countWords(scene.text) >= 20);\n} catch { return false; }",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  return (script.scenes || []).every((scene) => countWords(scene.text) >= 20);\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean)\n    .join(' ');\n  const hasEmoji = /\\p{Extended_Pictographic}/u.test(spoken);\n  const hasMarkdown = /[`*_]/.test(spoken) || /\\[(.+?)\\]\\((.+?)\\)/.test(spoken);\n  const hasHashtag = /(^|\\s)#\\w+/.test(spoken);\n  return !hasEmoji && !hasMarkdown && !hasHashtag;\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return typeof script.reasoning === 'string' && script.reasoning.trim().length > 10;\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "The script opens with an attention-grabbing hook that would stop a TikTok user from scrolling.\nThe first sentence should be surprising, controversial, or promise immediate value.\nScore 0 if it's a generic introduction like \"In this video...\" or \"Today we'll cover...\".\n",
                "threshold": 0.7,
                "weight": 2
              },
              "pass": true,
              "score": 1,
              "reason": "The hook 'Want to level up your JavaScript game? Check out these five killer tips!' is attention-grabbing and promises immediate value to the viewer.",
              "tokensUsed": {
                "total": 643,
                "prompt": 595,
                "completion": 48,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"Tip 1: Use 'const' and 'let' instead of 'var'. It helps prevent scope issues, making your code safer and cleaner.\\\",\\\"visualDirection\\\":\\\"Show code snippets with 'var', 'let', and 'const' highlighted.\\\",\\\"mood\\\":\\\"Informative and engaging.\\\"},{\\\"text\\\":\\\"Tip 2: Master the arrow functions. They're more concise and maintain the 'this' context, unlike regular functions.\\\",\\\"visualDirection\\\":\\\"Display code comparison between arrow functions and traditional functions.\\\",\\\"mood\\\":\\\"Enlightening and modern.\\\"},{\\\"text\\\":\\\"Tip 3: Destructure objects for cleaner syntax. It simplifies accessing multiple properties at once, reducing clutter.\\\",\\\"visualDirection\\\":\\\"Illustrate object destructuring with before and after code examples.\\\",\\\"mood\\\":\\\"Simplifying and efficient.\\\"},{\\\"text\\\":\\\"Tip 4: Use template literals for strings. They're perfect for multi-line strings and embedding variables easily.\\\",\\\"visualDirection\\\":\\\"Show examples of template literals with embedded expressions and multi-line strings.\\\",\\\"mood\\\":\\\"Practical and modern.\\\"},{\\\"text\\\":\\\"Tip 5: Use 'map', 'filter', and 'reduce' for array tasks. They offer powerful methods to handle arrays efficiently.\\\",\\\"visualDirection\\\":\\\"Demonstrate array methods in action with visual step-by-step execution.\\\",\\\"mood\\\":\\\"Empowering and dynamic.\\\"}],\\\"reasoning\\\":\\\"The script provides five essential JavaScript tips, presented in a concise and engaging way suitable for short-form videos. Each tip is paired with visual examples to enhance understanding.\\\",\\\"title\\\":\\\"5 JavaScript Tips Every Developer Should Know\\\",\\\"hook\\\":\\\"Want to level up your JavaScript game? Check out these five killer tips!\\\",\\\"cta\\\":\\\"Try these tips in your next project and watch your coding skills soar!\\\",\\\"hashtags\\\":[\\\"#JavaScript\\\",\\\"#CodingTips\\\",\\\"#WebDevelopment\\\"]}\\n</Output>\\n<Rubric>\\nThe script opens with an attention-grabbing hook that would stop a TikTok user from scrolling.\\nThe first sentence should be surprising, controversial, or promise immediate value.\\nScore 0 if it's a generic introduction like \\\"In this video...\\\" or \\\"Today we'll cover...\\\".\\n\\n</Rubric>\"}]"
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "The language is casual, conversational, and suitable for TikTok/Reels/Shorts.\nNo corporate jargon, no formal academic language, no \"as a developer\" phrases.\nShould sound like a friend giving advice, not a textbook.\n",
                "threshold": 0.8,
                "weight": 1
              },
              "pass": true,
              "score": 1,
              "reason": "The language used is friendly and informal, making it suitable for a casual social media format without corporate jargon or formal academic language.",
              "tokensUsed": {
                "total": 630,
                "prompt": 588,
                "completion": 42,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"Tip 1: Use 'const' and 'let' instead of 'var'. It helps prevent scope issues, making your code safer and cleaner.\\\",\\\"visualDirection\\\":\\\"Show code snippets with 'var', 'let', and 'const' highlighted.\\\",\\\"mood\\\":\\\"Informative and engaging.\\\"},{\\\"text\\\":\\\"Tip 2: Master the arrow functions. They're more concise and maintain the 'this' context, unlike regular functions.\\\",\\\"visualDirection\\\":\\\"Display code comparison between arrow functions and traditional functions.\\\",\\\"mood\\\":\\\"Enlightening and modern.\\\"},{\\\"text\\\":\\\"Tip 3: Destructure objects for cleaner syntax. It simplifies accessing multiple properties at once, reducing clutter.\\\",\\\"visualDirection\\\":\\\"Illustrate object destructuring with before and after code examples.\\\",\\\"mood\\\":\\\"Simplifying and efficient.\\\"},{\\\"text\\\":\\\"Tip 4: Use template literals for strings. They're perfect for multi-line strings and embedding variables easily.\\\",\\\"visualDirection\\\":\\\"Show examples of template literals with embedded expressions and multi-line strings.\\\",\\\"mood\\\":\\\"Practical and modern.\\\"},{\\\"text\\\":\\\"Tip 5: Use 'map', 'filter', and 'reduce' for array tasks. They offer powerful methods to handle arrays efficiently.\\\",\\\"visualDirection\\\":\\\"Demonstrate array methods in action with visual step-by-step execution.\\\",\\\"mood\\\":\\\"Empowering and dynamic.\\\"}],\\\"reasoning\\\":\\\"The script provides five essential JavaScript tips, presented in a concise and engaging way suitable for short-form videos. Each tip is paired with visual examples to enhance understanding.\\\",\\\"title\\\":\\\"5 JavaScript Tips Every Developer Should Know\\\",\\\"hook\\\":\\\"Want to level up your JavaScript game? Check out these five killer tips!\\\",\\\"cta\\\":\\\"Try these tips in your next project and watch your coding skills soar!\\\",\\\"hashtags\\\":[\\\"#JavaScript\\\",\\\"#CodingTips\\\",\\\"#WebDevelopment\\\"]}\\n</Output>\\n<Rubric>\\nThe language is casual, conversational, and suitable for TikTok/Reels/Shorts.\\nNo corporate jargon, no formal academic language, no \\\"as a developer\\\" phrases.\\nShould sound like a friend giving advice, not a textbook.\\n\\n</Rubric>\"}]"
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "Each scene has a specific, filmable visual description.\nVisual directions should describe what the viewer will SEE on screen.\nAvoid abstract concepts that cannot be filmed (like \"efficiency\" or \"code quality\").\n",
                "threshold": 0.8,
                "weight": 1
              },
              "pass": true,
              "score": 1,
              "reason": "Each scene includes specific visual directions that describe what will be shown on screen, focusing on concrete examples such as code snippets and visual comparisons.",
              "tokensUsed": {
                "total": 622,
                "prompt": 582,
                "completion": 40,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"Tip 1: Use 'const' and 'let' instead of 'var'. It helps prevent scope issues, making your code safer and cleaner.\\\",\\\"visualDirection\\\":\\\"Show code snippets with 'var', 'let', and 'const' highlighted.\\\",\\\"mood\\\":\\\"Informative and engaging.\\\"},{\\\"text\\\":\\\"Tip 2: Master the arrow functions. They're more concise and maintain the 'this' context, unlike regular functions.\\\",\\\"visualDirection\\\":\\\"Display code comparison between arrow functions and traditional functions.\\\",\\\"mood\\\":\\\"Enlightening and modern.\\\"},{\\\"text\\\":\\\"Tip 3: Destructure objects for cleaner syntax. It simplifies accessing multiple properties at once, reducing clutter.\\\",\\\"visualDirection\\\":\\\"Illustrate object destructuring with before and after code examples.\\\",\\\"mood\\\":\\\"Simplifying and efficient.\\\"},{\\\"text\\\":\\\"Tip 4: Use template literals for strings. They're perfect for multi-line strings and embedding variables easily.\\\",\\\"visualDirection\\\":\\\"Show examples of template literals with embedded expressions and multi-line strings.\\\",\\\"mood\\\":\\\"Practical and modern.\\\"},{\\\"text\\\":\\\"Tip 5: Use 'map', 'filter', and 'reduce' for array tasks. They offer powerful methods to handle arrays efficiently.\\\",\\\"visualDirection\\\":\\\"Demonstrate array methods in action with visual step-by-step execution.\\\",\\\"mood\\\":\\\"Empowering and dynamic.\\\"}],\\\"reasoning\\\":\\\"The script provides five essential JavaScript tips, presented in a concise and engaging way suitable for short-form videos. Each tip is paired with visual examples to enhance understanding.\\\",\\\"title\\\":\\\"5 JavaScript Tips Every Developer Should Know\\\",\\\"hook\\\":\\\"Want to level up your JavaScript game? Check out these five killer tips!\\\",\\\"cta\\\":\\\"Try these tips in your next project and watch your coding skills soar!\\\",\\\"hashtags\\\":[\\\"#JavaScript\\\",\\\"#CodingTips\\\",\\\"#WebDevelopment\\\"]}\\n</Output>\\n<Rubric>\\nEach scene has a specific, filmable visual description.\\nVisual directions should describe what the viewer will SEE on screen.\\nAvoid abstract concepts that cannot be filmed (like \\\"efficiency\\\" or \\\"code quality\\\").\\n\\n</Rubric>\"}]"
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "For a listicle archetype, the script should have a clear numbered structure.\nEach tip should be distinct and actionable.\nThe list should feel complete, not like it was cut off.\n",
                "threshold": 0.8,
                "weight": 1
              },
              "pass": true,
              "score": 1,
              "reason": "The script presents five distinct and actionable JavaScript tips in a clear numbered structure, fulfilling the listicle archetype requirements. The content is complete and not abruptly cut off.",
              "tokensUsed": {
                "total": 629,
                "prompt": 578,
                "completion": 51,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"Tip 1: Use 'const' and 'let' instead of 'var'. It helps prevent scope issues, making your code safer and cleaner.\\\",\\\"visualDirection\\\":\\\"Show code snippets with 'var', 'let', and 'const' highlighted.\\\",\\\"mood\\\":\\\"Informative and engaging.\\\"},{\\\"text\\\":\\\"Tip 2: Master the arrow functions. They're more concise and maintain the 'this' context, unlike regular functions.\\\",\\\"visualDirection\\\":\\\"Display code comparison between arrow functions and traditional functions.\\\",\\\"mood\\\":\\\"Enlightening and modern.\\\"},{\\\"text\\\":\\\"Tip 3: Destructure objects for cleaner syntax. It simplifies accessing multiple properties at once, reducing clutter.\\\",\\\"visualDirection\\\":\\\"Illustrate object destructuring with before and after code examples.\\\",\\\"mood\\\":\\\"Simplifying and efficient.\\\"},{\\\"text\\\":\\\"Tip 4: Use template literals for strings. They're perfect for multi-line strings and embedding variables easily.\\\",\\\"visualDirection\\\":\\\"Show examples of template literals with embedded expressions and multi-line strings.\\\",\\\"mood\\\":\\\"Practical and modern.\\\"},{\\\"text\\\":\\\"Tip 5: Use 'map', 'filter', and 'reduce' for array tasks. They offer powerful methods to handle arrays efficiently.\\\",\\\"visualDirection\\\":\\\"Demonstrate array methods in action with visual step-by-step execution.\\\",\\\"mood\\\":\\\"Empowering and dynamic.\\\"}],\\\"reasoning\\\":\\\"The script provides five essential JavaScript tips, presented in a concise and engaging way suitable for short-form videos. Each tip is paired with visual examples to enhance understanding.\\\",\\\"title\\\":\\\"5 JavaScript Tips Every Developer Should Know\\\",\\\"hook\\\":\\\"Want to level up your JavaScript game? Check out these five killer tips!\\\",\\\"cta\\\":\\\"Try these tips in your next project and watch your coding skills soar!\\\",\\\"hashtags\\\":[\\\"#JavaScript\\\",\\\"#CodingTips\\\",\\\"#WebDevelopment\\\"]}\\n</Output>\\n<Rubric>\\nFor a listicle archetype, the script should have a clear numbered structure.\\nEach tip should be distinct and actionable.\\nThe list should feel complete, not like it was cut off.\\n\\n</Rubric>\"}]"
              }
            }
          ]
        },
        "id": "a52caa47-c929-40e9-9f00-352f25ea30a6",
        "latencyMs": 5377,
        "namedScores": {},
        "prompt": {
          "raw": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"5 JavaScript tips every developer should know\"\n\nFORMAT: listicle\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Total spoken word count must be between 90-150 words.\n- Use short sentences (<=15 words) and one idea per sentence.\n- Each scene should be 2 sentences and ~22-30 words (minimum 20 words per scene).\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n- Scene 1 must continue after the hook with NEW information (no restating or paraphrasing the hook).\n- Each scene text must be at least 20 words.\n- Double-check total word count before responding.\n\n\nStructure as a numbered list with a hook, clear items, and a call-to-action.\nPrefix each point with an explicit number label (e.g., \"Tip 1:\", \"2)\", \"Number 3:\").\n\n\n\n\n\n\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n- Each scene text must be at least 20 words.\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n",
          "label": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"{{ topic }}\"\n\nFORMAT: {{ archetype }}\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Total spoken word count must be between 90-150 words.\n- Use short sentences (<=15 words) and one idea per sentence.\n- Each scene should be 2 sentences and ~22-30 words (minimum 20 words per scene).\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n- Scene 1 must continue after the hook with NEW information (no restating or paraphrasing the hook).\n- Each scene text must be at least 20 words.\n- Double-check total word count before responding.\n\n{% if archetype == \"listicle\" %}\nStructure as a numbered list with a hook, clear items, and a call-to-action.\nPrefix each point with an explicit number label (e.g., \"Tip 1:\", \"2)\", \"Number 3:\").\n{% endif %}\n{% if archetype == \"versus\" %}\nPresent a balanced comparison with a clear recommendation at the end.\nThe hook should be a bold statement, not a question.\n{% endif %}\n{% if archetype == \"howto\" %}\nGive step-by-step instructions that are easy to follow.\n{% endif %}\n{% if archetype == \"myth\" %}\nStart with the myth, then reveal the reality with evidence.\nUse explicit \"Myth: X\" and \"Reality: Y\" phrasing in scene text.\n{% endif %}\n{% if archetype == \"story\" %}\nUse narrative structure: setup, conflict, resolution.\n{% endif %}\n{% if archetype == \"hot-take\" %}\nLead with a provocative opinion, then back it up with reasoning.\n{% endif %}\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n- Each scene text must be at least 20 words.\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n"
        },
        "promptId": "d06ca5ffe45d88de94b47be11ed6547ff6c739ca21958980b959177eed65db1b",
        "promptIdx": 0,
        "provider": {
          "id": "openai:gpt-4o",
          "label": ""
        },
        "response": {
          "output": "{\n  \"scenes\": [\n    {\n      \"text\": \"Tip 1: Use 'const' and 'let' instead of 'var'. It helps prevent scope issues, making your code safer and cleaner.\",\n      \"visualDirection\": \"Show code snippets with 'var', 'let', and 'const' highlighted.\",\n      \"mood\": \"Informative and engaging.\"\n    },\n    {\n      \"text\": \"Tip 2: Master the arrow functions. They're more concise and maintain the 'this' context, unlike regular functions.\",\n      \"visualDirection\": \"Display code comparison between arrow functions and traditional functions.\",\n      \"mood\": \"Enlightening and modern.\"\n    },\n    {\n      \"text\": \"Tip 3: Destructure objects for cleaner syntax. It simplifies accessing multiple properties at once, reducing clutter.\",\n      \"visualDirection\": \"Illustrate object destructuring with before and after code examples.\",\n      \"mood\": \"Simplifying and efficient.\"\n    },\n    {\n      \"text\": \"Tip 4: Use template literals for strings. They're perfect for multi-line strings and embedding variables easily.\",\n      \"visualDirection\": \"Show examples of template literals with embedded expressions and multi-line strings.\",\n      \"mood\": \"Practical and modern.\"\n    },\n    {\n      \"text\": \"Tip 5: Use 'map', 'filter', and 'reduce' for array tasks. They offer powerful methods to handle arrays efficiently.\",\n      \"visualDirection\": \"Demonstrate array methods in action with visual step-by-step execution.\",\n      \"mood\": \"Empowering and dynamic.\"\n    }\n  ],\n  \"reasoning\": \"The script provides five essential JavaScript tips, presented in a concise and engaging way suitable for short-form videos. Each tip is paired with visual examples to enhance understanding.\",\n  \"title\": \"5 JavaScript Tips Every Developer Should Know\",\n  \"hook\": \"Want to level up your JavaScript game? Check out these five killer tips!\",\n  \"cta\": \"Try these tips in your next project and watch your coding skills soar!\",\n  \"hashtags\": [\"#JavaScript\", \"#CodingTips\", \"#WebDevelopment\"]\n}",
          "tokenUsage": {
            "total": 950,
            "prompt": 509,
            "completion": 441,
            "numRequests": 1,
            "completionDetails": {
              "reasoning": 0,
              "acceptedPrediction": 0,
              "rejectedPrediction": 0
            }
          },
          "cached": false,
          "latencyMs": 5377,
          "finishReason": "stop",
          "cost": 0.005682500000000001,
          "guardrails": {
            "flagged": false
          }
        },
        "score": 0.9333333333333333,
        "success": false,
        "testCase": {
          "vars": {
            "topic": "5 JavaScript tips every developer should know",
            "archetype": "listicle"
          },
          "assert": [
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return (\n    Array.isArray(script.scenes) &&\n    script.scenes.length >= 3 &&\n    script.scenes.length <= 7\n  );\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 90 && wordCount <= 150;\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return (script.scenes || []).every((scene) =>\n    typeof scene.visualDirection === 'string' && scene.visualDirection.trim().length > 5\n  );\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  return (script.scenes || []).every((scene) => countWords(scene.text) >= 20);\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean)\n    .join(' ');\n  const hasEmoji = /\\p{Extended_Pictographic}/u.test(spoken);\n  const hasMarkdown = /[`*_]/.test(spoken) || /\\[(.+?)\\]\\((.+?)\\)/.test(spoken);\n  const hasHashtag = /(^|\\s)#\\w+/.test(spoken);\n  return !hasEmoji && !hasMarkdown && !hasHashtag;\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return typeof script.reasoning === 'string' && script.reasoning.trim().length > 10;\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "llm-rubric",
              "value": "The script opens with an attention-grabbing hook that would stop a TikTok user from scrolling.\nThe first sentence should be surprising, controversial, or promise immediate value.\nScore 0 if it's a generic introduction like \"In this video...\" or \"Today we'll cover...\".\n",
              "threshold": 0.7,
              "weight": 2
            },
            {
              "type": "llm-rubric",
              "value": "The language is casual, conversational, and suitable for TikTok/Reels/Shorts.\nNo corporate jargon, no formal academic language, no \"as a developer\" phrases.\nShould sound like a friend giving advice, not a textbook.\n",
              "threshold": 0.8,
              "weight": 1
            },
            {
              "type": "llm-rubric",
              "value": "Each scene has a specific, filmable visual description.\nVisual directions should describe what the viewer will SEE on screen.\nAvoid abstract concepts that cannot be filmed (like \"efficiency\" or \"code quality\").\n",
              "threshold": 0.8,
              "weight": 1
            },
            {
              "type": "llm-rubric",
              "value": "For a listicle archetype, the script should have a clear numbered structure.\nEach tip should be distinct and actionable.\nThe list should feel complete, not like it was cut off.\n",
              "threshold": 0.8,
              "weight": 1
            }
          ],
          "options": {
            "provider": "openai:gpt-4o-mini"
          },
          "metadata": {}
        },
        "testIdx": 0,
        "vars": {
          "topic": "5 JavaScript tips every developer should know",
          "archetype": "listicle"
        },
        "metadata": {
          "_promptfooFileMetadata": {}
        },
        "failureReason": 1
      },
      {
        "cost": 0.005805,
        "error": "Custom function returned false\ntry {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  return (script.scenes || []).every((scene) => countWords(scene.text) >= 20);\n} catch { return false; }",
        "gradingResult": {
          "pass": false,
          "score": 0.9333333333333333,
          "reason": "Custom function returned false\ntry {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  return (script.scenes || []).every((scene) => countWords(scene.text) >= 20);\n} catch { return false; }",
          "namedScores": {},
          "tokensUsed": {
            "total": 1909,
            "prompt": 1751,
            "completion": 158,
            "cached": 0,
            "numRequests": 3
          },
          "componentResults": [
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return (\n    Array.isArray(script.scenes) &&\n    script.scenes.length >= 3 &&\n    script.scenes.length <= 7\n  );\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 90 && wordCount <= 150;\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return (script.scenes || []).every((scene) =>\n    typeof scene.visualDirection === 'string' && scene.visualDirection.trim().length > 5\n  );\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": false,
              "score": 0,
              "reason": "Custom function returned false\ntry {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  return (script.scenes || []).every((scene) => countWords(scene.text) >= 20);\n} catch { return false; }",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  return (script.scenes || []).every((scene) => countWords(scene.text) >= 20);\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean)\n    .join(' ');\n  const hasEmoji = /\\p{Extended_Pictographic}/u.test(spoken);\n  const hasMarkdown = /[`*_]/.test(spoken) || /\\[(.+?)\\]\\((.+?)\\)/.test(spoken);\n  const hasHashtag = /(^|\\s)#\\w+/.test(spoken);\n  return !hasEmoji && !hasMarkdown && !hasHashtag;\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return typeof script.reasoning === 'string' && script.reasoning.trim().length > 10;\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "The script opens with an attention-grabbing hook.\nFor a versus video, this might be a provocative statement like \"You're using the wrong database\"\nor a relatable problem statement.\n",
                "threshold": 0.7,
                "weight": 2
              },
              "pass": true,
              "score": 1,
              "reason": "The script opens with the hook 'Choosing between Redis and PostgreSQL for caching? Let's break it down!', which grabs attention by prompting a choice.",
              "tokensUsed": {
                "total": 633,
                "prompt": 587,
                "completion": 46,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"Redis is lightning-fast because it keeps everything in memory. It's perfect for real-time apps, but remember, you'll need enough RAM.\\\",\\\"visualDirection\\\":\\\"Show a fast-paced montage of a lightning bolt, RAM chips, and real-time app usage.\\\",\\\"mood\\\":\\\"Energetic and exciting\\\"},{\\\"text\\\":\\\"PostgreSQL offers caching with more durability. It writes data to disk, giving you peace of mind if the server crashes.\\\",\\\"visualDirection\\\":\\\"Show a calm, stable scene with a computer, server room, and data backups.\\\",\\\"mood\\\":\\\"Reassuring and stable\\\"},{\\\"text\\\":\\\"Redis is super simple to set up and use. Perfect if you're looking for quick configuration and easy management.\\\",\\\"visualDirection\\\":\\\"Show a person easily setting up Redis, smiling and nodding with satisfaction.\\\",\\\"mood\\\":\\\"Simple and straightforward\\\"},{\\\"text\\\":\\\"PostgreSQL is more complex but offers versatile data handling and more features. Its like having a Swiss army knife for data.\\\",\\\"visualDirection\\\":\\\"Show someone using a Swiss army knife, then cut to a screen full of data options.\\\",\\\"mood\\\":\\\"Complex yet powerful\\\"},{\\\"text\\\":\\\"For pure speed and simplicity, go with Redis. For more features and reliability, PostgreSQL is your best bet.\\\",\\\"visualDirection\\\":\\\"Split screen showing Redis on one side, PostgreSQL on the other, with a scale balancing between them.\\\",\\\"mood\\\":\\\"Balanced and informative\\\"}],\\\"reasoning\\\":\\\"The video compares Redis and PostgreSQL for caching, highlighting the speed and simplicity of Redis versus the feature-rich, reliable nature of PostgreSQL.\\\",\\\"title\\\":\\\"Redis vs PostgreSQL: Which is Best for Caching?\\\",\\\"hook\\\":\\\"Choosing between Redis and PostgreSQL for caching? Let's break it down!\\\",\\\"cta\\\":\\\"Choose your caching champion! Comment below with your pick.\\\",\\\"hashtags\\\":[\\\"#Redis\\\",\\\"#PostgreSQL\\\",\\\"#Caching\\\",\\\"#TechTalk\\\",\\\"#Database\\\"]}\\n</Output>\\n<Rubric>\\nThe script opens with an attention-grabbing hook.\\nFor a versus video, this might be a provocative statement like \\\"You're using the wrong database\\\"\\nor a relatable problem statement.\\n\\n</Rubric>\"}]"
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "For a versus archetype, the script should clearly compare both options.\nIt should present pros and cons of each, not just favor one.\nThe comparison should be fair and technically accurate.\n",
                "threshold": 0.8,
                "weight": 2
              },
              "pass": true,
              "score": 1,
              "reason": "The output includes a clear comparison of Redis and PostgreSQL, presenting their respective pros and cons fairly and technically, such as speed and simplicity for Redis and versatility and durability for PostgreSQL.",
              "tokensUsed": {
                "total": 643,
                "prompt": 589,
                "completion": 54,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"Redis is lightning-fast because it keeps everything in memory. It's perfect for real-time apps, but remember, you'll need enough RAM.\\\",\\\"visualDirection\\\":\\\"Show a fast-paced montage of a lightning bolt, RAM chips, and real-time app usage.\\\",\\\"mood\\\":\\\"Energetic and exciting\\\"},{\\\"text\\\":\\\"PostgreSQL offers caching with more durability. It writes data to disk, giving you peace of mind if the server crashes.\\\",\\\"visualDirection\\\":\\\"Show a calm, stable scene with a computer, server room, and data backups.\\\",\\\"mood\\\":\\\"Reassuring and stable\\\"},{\\\"text\\\":\\\"Redis is super simple to set up and use. Perfect if you're looking for quick configuration and easy management.\\\",\\\"visualDirection\\\":\\\"Show a person easily setting up Redis, smiling and nodding with satisfaction.\\\",\\\"mood\\\":\\\"Simple and straightforward\\\"},{\\\"text\\\":\\\"PostgreSQL is more complex but offers versatile data handling and more features. Its like having a Swiss army knife for data.\\\",\\\"visualDirection\\\":\\\"Show someone using a Swiss army knife, then cut to a screen full of data options.\\\",\\\"mood\\\":\\\"Complex yet powerful\\\"},{\\\"text\\\":\\\"For pure speed and simplicity, go with Redis. For more features and reliability, PostgreSQL is your best bet.\\\",\\\"visualDirection\\\":\\\"Split screen showing Redis on one side, PostgreSQL on the other, with a scale balancing between them.\\\",\\\"mood\\\":\\\"Balanced and informative\\\"}],\\\"reasoning\\\":\\\"The video compares Redis and PostgreSQL for caching, highlighting the speed and simplicity of Redis versus the feature-rich, reliable nature of PostgreSQL.\\\",\\\"title\\\":\\\"Redis vs PostgreSQL: Which is Best for Caching?\\\",\\\"hook\\\":\\\"Choosing between Redis and PostgreSQL for caching? Let's break it down!\\\",\\\"cta\\\":\\\"Choose your caching champion! Comment below with your pick.\\\",\\\"hashtags\\\":[\\\"#Redis\\\",\\\"#PostgreSQL\\\",\\\"#Caching\\\",\\\"#TechTalk\\\",\\\"#Database\\\"]}\\n</Output>\\n<Rubric>\\nFor a versus archetype, the script should clearly compare both options.\\nIt should present pros and cons of each, not just favor one.\\nThe comparison should be fair and technically accurate.\\n\\n</Rubric>\"}]"
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "The script provides a clear recommendation or decision framework at the end.\nViewers should know when to use each option.\n",
                "threshold": 0.7,
                "weight": 1
              },
              "pass": true,
              "score": 1,
              "reason": "The script concludes with a clear recommendation by stating 'For pure speed and simplicity, go with Redis. For more features and reliability, PostgreSQL is your best bet.', which provides viewers with a decision framework.",
              "tokensUsed": {
                "total": 633,
                "prompt": 575,
                "completion": 58,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"Redis is lightning-fast because it keeps everything in memory. It's perfect for real-time apps, but remember, you'll need enough RAM.\\\",\\\"visualDirection\\\":\\\"Show a fast-paced montage of a lightning bolt, RAM chips, and real-time app usage.\\\",\\\"mood\\\":\\\"Energetic and exciting\\\"},{\\\"text\\\":\\\"PostgreSQL offers caching with more durability. It writes data to disk, giving you peace of mind if the server crashes.\\\",\\\"visualDirection\\\":\\\"Show a calm, stable scene with a computer, server room, and data backups.\\\",\\\"mood\\\":\\\"Reassuring and stable\\\"},{\\\"text\\\":\\\"Redis is super simple to set up and use. Perfect if you're looking for quick configuration and easy management.\\\",\\\"visualDirection\\\":\\\"Show a person easily setting up Redis, smiling and nodding with satisfaction.\\\",\\\"mood\\\":\\\"Simple and straightforward\\\"},{\\\"text\\\":\\\"PostgreSQL is more complex but offers versatile data handling and more features. Its like having a Swiss army knife for data.\\\",\\\"visualDirection\\\":\\\"Show someone using a Swiss army knife, then cut to a screen full of data options.\\\",\\\"mood\\\":\\\"Complex yet powerful\\\"},{\\\"text\\\":\\\"For pure speed and simplicity, go with Redis. For more features and reliability, PostgreSQL is your best bet.\\\",\\\"visualDirection\\\":\\\"Split screen showing Redis on one side, PostgreSQL on the other, with a scale balancing between them.\\\",\\\"mood\\\":\\\"Balanced and informative\\\"}],\\\"reasoning\\\":\\\"The video compares Redis and PostgreSQL for caching, highlighting the speed and simplicity of Redis versus the feature-rich, reliable nature of PostgreSQL.\\\",\\\"title\\\":\\\"Redis vs PostgreSQL: Which is Best for Caching?\\\",\\\"hook\\\":\\\"Choosing between Redis and PostgreSQL for caching? Let's break it down!\\\",\\\"cta\\\":\\\"Choose your caching champion! Comment below with your pick.\\\",\\\"hashtags\\\":[\\\"#Redis\\\",\\\"#PostgreSQL\\\",\\\"#Caching\\\",\\\"#TechTalk\\\",\\\"#Database\\\"]}\\n</Output>\\n<Rubric>\\nThe script provides a clear recommendation or decision framework at the end.\\nViewers should know when to use each option.\\n\\n</Rubric>\"}]"
              }
            }
          ]
        },
        "id": "12440141-fbf5-4c69-adbf-a775c539713d",
        "latencyMs": 5655,
        "namedScores": {},
        "prompt": {
          "raw": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"Redis vs PostgreSQL for caching\"\n\nFORMAT: versus\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Total spoken word count must be between 90-150 words.\n- Use short sentences (<=15 words) and one idea per sentence.\n- Each scene should be 2 sentences and ~22-30 words (minimum 20 words per scene).\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n- Scene 1 must continue after the hook with NEW information (no restating or paraphrasing the hook).\n- Each scene text must be at least 20 words.\n- Double-check total word count before responding.\n\n\n\nPresent a balanced comparison with a clear recommendation at the end.\nThe hook should be a bold statement, not a question.\n\n\n\n\n\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n- Each scene text must be at least 20 words.\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n",
          "label": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"{{ topic }}\"\n\nFORMAT: {{ archetype }}\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Total spoken word count must be between 90-150 words.\n- Use short sentences (<=15 words) and one idea per sentence.\n- Each scene should be 2 sentences and ~22-30 words (minimum 20 words per scene).\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n- Scene 1 must continue after the hook with NEW information (no restating or paraphrasing the hook).\n- Each scene text must be at least 20 words.\n- Double-check total word count before responding.\n\n{% if archetype == \"listicle\" %}\nStructure as a numbered list with a hook, clear items, and a call-to-action.\nPrefix each point with an explicit number label (e.g., \"Tip 1:\", \"2)\", \"Number 3:\").\n{% endif %}\n{% if archetype == \"versus\" %}\nPresent a balanced comparison with a clear recommendation at the end.\nThe hook should be a bold statement, not a question.\n{% endif %}\n{% if archetype == \"howto\" %}\nGive step-by-step instructions that are easy to follow.\n{% endif %}\n{% if archetype == \"myth\" %}\nStart with the myth, then reveal the reality with evidence.\nUse explicit \"Myth: X\" and \"Reality: Y\" phrasing in scene text.\n{% endif %}\n{% if archetype == \"story\" %}\nUse narrative structure: setup, conflict, resolution.\n{% endif %}\n{% if archetype == \"hot-take\" %}\nLead with a provocative opinion, then back it up with reasoning.\n{% endif %}\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n- Each scene text must be at least 20 words.\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n"
        },
        "promptId": "d06ca5ffe45d88de94b47be11ed6547ff6c739ca21958980b959177eed65db1b",
        "promptIdx": 0,
        "provider": {
          "id": "openai:gpt-4o",
          "label": ""
        },
        "response": {
          "output": "{\n  \"scenes\": [\n    {\n      \"text\": \"Redis is lightning-fast because it keeps everything in memory. It's perfect for real-time apps, but remember, you'll need enough RAM.\",\n      \"visualDirection\": \"Show a fast-paced montage of a lightning bolt, RAM chips, and real-time app usage.\",\n      \"mood\": \"Energetic and exciting\"\n    },\n    {\n      \"text\": \"PostgreSQL offers caching with more durability. It writes data to disk, giving you peace of mind if the server crashes.\",\n      \"visualDirection\": \"Show a calm, stable scene with a computer, server room, and data backups.\",\n      \"mood\": \"Reassuring and stable\"\n    },\n    {\n      \"text\": \"Redis is super simple to set up and use. Perfect if you're looking for quick configuration and easy management.\",\n      \"visualDirection\": \"Show a person easily setting up Redis, smiling and nodding with satisfaction.\",\n      \"mood\": \"Simple and straightforward\"\n    },\n    {\n      \"text\": \"PostgreSQL is more complex but offers versatile data handling and more features. Its like having a Swiss army knife for data.\",\n      \"visualDirection\": \"Show someone using a Swiss army knife, then cut to a screen full of data options.\",\n      \"mood\": \"Complex yet powerful\"\n    },\n    {\n      \"text\": \"For pure speed and simplicity, go with Redis. For more features and reliability, PostgreSQL is your best bet.\",\n      \"visualDirection\": \"Split screen showing Redis on one side, PostgreSQL on the other, with a scale balancing between them.\",\n      \"mood\": \"Balanced and informative\"\n    }\n  ],\n  \"reasoning\": \"The video compares Redis and PostgreSQL for caching, highlighting the speed and simplicity of Redis versus the feature-rich, reliable nature of PostgreSQL.\",\n  \"title\": \"Redis vs PostgreSQL: Which is Best for Caching?\",\n  \"hook\": \"Choosing between Redis and PostgreSQL for caching? Let's break it down!\",\n  \"cta\": \"Choose your caching champion! Comment below with your pick.\",\n  \"hashtags\": [\"#Redis\", \"#PostgreSQL\", \"#Caching\", \"#TechTalk\", \"#Database\"]\n}",
          "tokenUsage": {
            "total": 945,
            "prompt": 486,
            "completion": 459,
            "numRequests": 1,
            "completionDetails": {
              "reasoning": 0,
              "acceptedPrediction": 0,
              "rejectedPrediction": 0
            }
          },
          "cached": false,
          "latencyMs": 5655,
          "finishReason": "stop",
          "cost": 0.005805,
          "guardrails": {
            "flagged": false
          }
        },
        "score": 0.9333333333333333,
        "success": false,
        "testCase": {
          "vars": {
            "topic": "Redis vs PostgreSQL for caching",
            "archetype": "versus"
          },
          "assert": [
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return (\n    Array.isArray(script.scenes) &&\n    script.scenes.length >= 3 &&\n    script.scenes.length <= 7\n  );\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 90 && wordCount <= 150;\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return (script.scenes || []).every((scene) =>\n    typeof scene.visualDirection === 'string' && scene.visualDirection.trim().length > 5\n  );\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  return (script.scenes || []).every((scene) => countWords(scene.text) >= 20);\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean)\n    .join(' ');\n  const hasEmoji = /\\p{Extended_Pictographic}/u.test(spoken);\n  const hasMarkdown = /[`*_]/.test(spoken) || /\\[(.+?)\\]\\((.+?)\\)/.test(spoken);\n  const hasHashtag = /(^|\\s)#\\w+/.test(spoken);\n  return !hasEmoji && !hasMarkdown && !hasHashtag;\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return typeof script.reasoning === 'string' && script.reasoning.trim().length > 10;\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "llm-rubric",
              "value": "The script opens with an attention-grabbing hook.\nFor a versus video, this might be a provocative statement like \"You're using the wrong database\"\nor a relatable problem statement.\n",
              "threshold": 0.7,
              "weight": 2
            },
            {
              "type": "llm-rubric",
              "value": "For a versus archetype, the script should clearly compare both options.\nIt should present pros and cons of each, not just favor one.\nThe comparison should be fair and technically accurate.\n",
              "threshold": 0.8,
              "weight": 2
            },
            {
              "type": "llm-rubric",
              "value": "The script provides a clear recommendation or decision framework at the end.\nViewers should know when to use each option.\n",
              "threshold": 0.7,
              "weight": 1
            }
          ],
          "options": {
            "provider": "openai:gpt-4o-mini"
          },
          "metadata": {}
        },
        "testIdx": 1,
        "vars": {
          "topic": "Redis vs PostgreSQL for caching",
          "archetype": "versus"
        },
        "metadata": {
          "_promptfooFileMetadata": {}
        },
        "failureReason": 1
      },
      {
        "cost": 0.005365000000000001,
        "error": "Custom function returned false\ntry {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  return (script.scenes || []).every((scene) => countWords(scene.text) >= 20);\n} catch { return false; }",
        "gradingResult": {
          "pass": false,
          "score": 0.9230769230769231,
          "reason": "Custom function returned false\ntry {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  return (script.scenes || []).every((scene) => countWords(scene.text) >= 20);\n} catch { return false; }",
          "namedScores": {},
          "tokensUsed": {
            "total": 1219,
            "prompt": 1073,
            "completion": 146,
            "cached": 0,
            "numRequests": 2
          },
          "componentResults": [
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return (\n    Array.isArray(script.scenes) &&\n    script.scenes.length >= 3 &&\n    script.scenes.length <= 7\n  );\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 90 && wordCount <= 150;\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return (script.scenes || []).every((scene) =>\n    typeof scene.visualDirection === 'string' && scene.visualDirection.trim().length > 5\n  );\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": false,
              "score": 0,
              "reason": "Custom function returned false\ntry {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  return (script.scenes || []).every((scene) => countWords(scene.text) >= 20);\n} catch { return false; }",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  return (script.scenes || []).every((scene) => countWords(scene.text) >= 20);\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean)\n    .join(' ');\n  const hasEmoji = /\\p{Extended_Pictographic}/u.test(spoken);\n  const hasMarkdown = /[`*_]/.test(spoken) || /\\[(.+?)\\]\\((.+?)\\)/.test(spoken);\n  const hasHashtag = /(^|\\s)#\\w+/.test(spoken);\n  return !hasEmoji && !hasMarkdown && !hasHashtag;\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return typeof script.reasoning === 'string' && script.reasoning.trim().length > 10;\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "The script has a narrative arc: setup, challenge, resolution.\nIt should feel like a personal story, not a tutorial.\n",
                "threshold": 0.8,
                "weight": 2
              },
              "pass": true,
              "score": 1,
              "reason": "The script follows a clear narrative structure with a setup (beginning of learning), challenges (hitting a wall with state management), and resolution (completing the project). It is presented as a personal story about learning React.",
              "tokensUsed": {
                "total": 602,
                "prompt": 539,
                "completion": 63,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"I was staring at my screen, thinking, how do I even start with React? First, I grabbed a beginner's course online.\\\",\\\"visualDirection\\\":\\\"Show a confused expression and computer screen with React logo.\\\",\\\"mood\\\":\\\"Curious\\\"},{\\\"text\\\":\\\"Day three, and I was deep into tutorials. I made a simple app, and it felt amazing!\\\",\\\"visualDirection\\\":\\\"Show snippets of code and a simple React app in action.\\\",\\\"mood\\\":\\\"Excited\\\"},{\\\"text\\\":\\\"Halfway through, I hit a wall with state management. It was tough, but YouTube saved the day with some awesome tips.\\\",\\\"visualDirection\\\":\\\"Show frustration, then relief with a thumbs up.\\\",\\\"mood\\\":\\\"Relieved\\\"},{\\\"text\\\":\\\"By day ten, I was building components like a pro. I couldn't believe how far I'd come!\\\",\\\"visualDirection\\\":\\\"Show progress with code snippets and a feeling of accomplishment.\\\",\\\"mood\\\":\\\"Proud\\\"},{\\\"text\\\":\\\"Finally, two weeks in, I completed my first full React project. It was challenging, but so rewarding!\\\",\\\"visualDirection\\\":\\\"Show final project and a celebratory moment.\\\",\\\"mood\\\":\\\"Triumphant\\\"}],\\\"reasoning\\\":\\\"The script uses a narrative structure to engage viewers with a personal learning journey. The setup, conflict, and resolution provide a relatable and motivational story. The scenes are visually engaging, enhancing the storytelling.\\\",\\\"title\\\":\\\"Mastering React in Just Two Weeks!\\\",\\\"hook\\\":\\\"Two weeks ago, I knew nothing about React.\\\",\\\"cta\\\":\\\"If I can learn React in two weeks, so can you! Follow for more tips.\\\",\\\"hashtags\\\":[\\\"#ReactJS\\\",\\\"#CodingJourney\\\",\\\"#LearnToCode\\\",\\\"#Programming\\\"]}\\n</Output>\\n<Rubric>\\nThe script has a narrative arc: setup, challenge, resolution.\\nIt should feel like a personal story, not a tutorial.\\n\\n</Rubric>\"}]"
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "The language uses first-person perspective and includes emotional elements.\nThe viewer should feel connected to the storyteller.\n",
                "threshold": 0.7,
                "weight": 1
              },
              "pass": true,
              "score": 1,
              "reason": "The output is written in first-person perspective, using phrases like 'I was staring' and 'I couldn't believe how far I'd come.' It also includes emotional elements such as feeling 'curious', 'excited', 'relieved', 'proud', and 'triumphant', which help create a connection with the viewer.",
              "tokensUsed": {
                "total": 617,
                "prompt": 534,
                "completion": 83,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"I was staring at my screen, thinking, how do I even start with React? First, I grabbed a beginner's course online.\\\",\\\"visualDirection\\\":\\\"Show a confused expression and computer screen with React logo.\\\",\\\"mood\\\":\\\"Curious\\\"},{\\\"text\\\":\\\"Day three, and I was deep into tutorials. I made a simple app, and it felt amazing!\\\",\\\"visualDirection\\\":\\\"Show snippets of code and a simple React app in action.\\\",\\\"mood\\\":\\\"Excited\\\"},{\\\"text\\\":\\\"Halfway through, I hit a wall with state management. It was tough, but YouTube saved the day with some awesome tips.\\\",\\\"visualDirection\\\":\\\"Show frustration, then relief with a thumbs up.\\\",\\\"mood\\\":\\\"Relieved\\\"},{\\\"text\\\":\\\"By day ten, I was building components like a pro. I couldn't believe how far I'd come!\\\",\\\"visualDirection\\\":\\\"Show progress with code snippets and a feeling of accomplishment.\\\",\\\"mood\\\":\\\"Proud\\\"},{\\\"text\\\":\\\"Finally, two weeks in, I completed my first full React project. It was challenging, but so rewarding!\\\",\\\"visualDirection\\\":\\\"Show final project and a celebratory moment.\\\",\\\"mood\\\":\\\"Triumphant\\\"}],\\\"reasoning\\\":\\\"The script uses a narrative structure to engage viewers with a personal learning journey. The setup, conflict, and resolution provide a relatable and motivational story. The scenes are visually engaging, enhancing the storytelling.\\\",\\\"title\\\":\\\"Mastering React in Just Two Weeks!\\\",\\\"hook\\\":\\\"Two weeks ago, I knew nothing about React.\\\",\\\"cta\\\":\\\"If I can learn React in two weeks, so can you! Follow for more tips.\\\",\\\"hashtags\\\":[\\\"#ReactJS\\\",\\\"#CodingJourney\\\",\\\"#LearnToCode\\\",\\\"#Programming\\\"]}\\n</Output>\\n<Rubric>\\nThe language uses first-person perspective and includes emotional elements.\\nThe viewer should feel connected to the storyteller.\\n\\n</Rubric>\"}]"
              }
            }
          ]
        },
        "id": "caffea84-41fd-424a-8a14-13ad8605d813",
        "latencyMs": 7208,
        "namedScores": {},
        "prompt": {
          "raw": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"How I learned React in 2 weeks\"\n\nFORMAT: story\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Total spoken word count must be between 90-150 words.\n- Use short sentences (<=15 words) and one idea per sentence.\n- Each scene should be 2 sentences and ~22-30 words (minimum 20 words per scene).\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n- Scene 1 must continue after the hook with NEW information (no restating or paraphrasing the hook).\n- Each scene text must be at least 20 words.\n- Double-check total word count before responding.\n\n\n\n\n\n\nUse narrative structure: setup, conflict, resolution.\n\n\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n- Each scene text must be at least 20 words.\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n",
          "label": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"{{ topic }}\"\n\nFORMAT: {{ archetype }}\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Total spoken word count must be between 90-150 words.\n- Use short sentences (<=15 words) and one idea per sentence.\n- Each scene should be 2 sentences and ~22-30 words (minimum 20 words per scene).\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n- Scene 1 must continue after the hook with NEW information (no restating or paraphrasing the hook).\n- Each scene text must be at least 20 words.\n- Double-check total word count before responding.\n\n{% if archetype == \"listicle\" %}\nStructure as a numbered list with a hook, clear items, and a call-to-action.\nPrefix each point with an explicit number label (e.g., \"Tip 1:\", \"2)\", \"Number 3:\").\n{% endif %}\n{% if archetype == \"versus\" %}\nPresent a balanced comparison with a clear recommendation at the end.\nThe hook should be a bold statement, not a question.\n{% endif %}\n{% if archetype == \"howto\" %}\nGive step-by-step instructions that are easy to follow.\n{% endif %}\n{% if archetype == \"myth\" %}\nStart with the myth, then reveal the reality with evidence.\nUse explicit \"Myth: X\" and \"Reality: Y\" phrasing in scene text.\n{% endif %}\n{% if archetype == \"story\" %}\nUse narrative structure: setup, conflict, resolution.\n{% endif %}\n{% if archetype == \"hot-take\" %}\nLead with a provocative opinion, then back it up with reasoning.\n{% endif %}\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n- Each scene text must be at least 20 words.\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n"
        },
        "promptId": "d06ca5ffe45d88de94b47be11ed6547ff6c739ca21958980b959177eed65db1b",
        "promptIdx": 0,
        "provider": {
          "id": "openai:gpt-4o",
          "label": ""
        },
        "response": {
          "output": "{\n  \"scenes\": [\n    {\n      \"text\": \"I was staring at my screen, thinking, how do I even start with React? First, I grabbed a beginner's course online.\",\n      \"visualDirection\": \"Show a confused expression and computer screen with React logo.\",\n      \"mood\": \"Curious\"\n    },\n    {\n      \"text\": \"Day three, and I was deep into tutorials. I made a simple app, and it felt amazing!\",\n      \"visualDirection\": \"Show snippets of code and a simple React app in action.\",\n      \"mood\": \"Excited\"\n    },\n    {\n      \"text\": \"Halfway through, I hit a wall with state management. It was tough, but YouTube saved the day with some awesome tips.\",\n      \"visualDirection\": \"Show frustration, then relief with a thumbs up.\",\n      \"mood\": \"Relieved\"\n    },\n    {\n      \"text\": \"By day ten, I was building components like a pro. I couldn't believe how far I'd come!\",\n      \"visualDirection\": \"Show progress with code snippets and a feeling of accomplishment.\",\n      \"mood\": \"Proud\"\n    },\n    {\n      \"text\": \"Finally, two weeks in, I completed my first full React project. It was challenging, but so rewarding!\",\n      \"visualDirection\": \"Show final project and a celebratory moment.\",\n      \"mood\": \"Triumphant\"\n    }\n  ],\n  \"reasoning\": \"The script uses a narrative structure to engage viewers with a personal learning journey. The setup, conflict, and resolution provide a relatable and motivational story. The scenes are visually engaging, enhancing the storytelling.\",\n  \"title\": \"Mastering React in Just Two Weeks!\",\n  \"hook\": \"Two weeks ago, I knew nothing about React.\",\n  \"cta\": \"If I can learn React in two weeks, so can you! Follow for more tips.\",\n  \"hashtags\": [\"#ReactJS\", \"#CodingJourney\", \"#LearnToCode\", \"#Programming\"]\n}",
          "tokenUsage": {
            "total": 892,
            "prompt": 474,
            "completion": 418,
            "numRequests": 1,
            "completionDetails": {
              "reasoning": 0,
              "acceptedPrediction": 0,
              "rejectedPrediction": 0
            }
          },
          "cached": false,
          "latencyMs": 7208,
          "finishReason": "stop",
          "cost": 0.005365000000000001,
          "guardrails": {
            "flagged": false
          }
        },
        "score": 0.9230769230769231,
        "success": false,
        "testCase": {
          "vars": {
            "topic": "How I learned React in 2 weeks",
            "archetype": "story"
          },
          "assert": [
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return (\n    Array.isArray(script.scenes) &&\n    script.scenes.length >= 3 &&\n    script.scenes.length <= 7\n  );\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 90 && wordCount <= 150;\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return (script.scenes || []).every((scene) =>\n    typeof scene.visualDirection === 'string' && scene.visualDirection.trim().length > 5\n  );\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  return (script.scenes || []).every((scene) => countWords(scene.text) >= 20);\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean)\n    .join(' ');\n  const hasEmoji = /\\p{Extended_Pictographic}/u.test(spoken);\n  const hasMarkdown = /[`*_]/.test(spoken) || /\\[(.+?)\\]\\((.+?)\\)/.test(spoken);\n  const hasHashtag = /(^|\\s)#\\w+/.test(spoken);\n  return !hasEmoji && !hasMarkdown && !hasHashtag;\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return typeof script.reasoning === 'string' && script.reasoning.trim().length > 10;\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "llm-rubric",
              "value": "The script has a narrative arc: setup, challenge, resolution.\nIt should feel like a personal story, not a tutorial.\n",
              "threshold": 0.8,
              "weight": 2
            },
            {
              "type": "llm-rubric",
              "value": "The language uses first-person perspective and includes emotional elements.\nThe viewer should feel connected to the storyteller.\n",
              "threshold": 0.7,
              "weight": 1
            }
          ],
          "options": {
            "provider": "openai:gpt-4o-mini"
          },
          "metadata": {}
        },
        "testIdx": 2,
        "vars": {
          "topic": "How I learned React in 2 weeks",
          "archetype": "story"
        },
        "metadata": {
          "_promptfooFileMetadata": {}
        },
        "failureReason": 1
      },
      {
        "cost": 0.00572,
        "gradingResult": {
          "pass": true,
          "score": 1,
          "reason": "All assertions passed",
          "namedScores": {},
          "tokensUsed": {
            "total": 1243,
            "prompt": 1151,
            "completion": 92,
            "cached": 0,
            "numRequests": 2
          },
          "componentResults": [
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return (\n    Array.isArray(script.scenes) &&\n    script.scenes.length >= 3 &&\n    script.scenes.length <= 7\n  );\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 90 && wordCount <= 150;\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return (script.scenes || []).every((scene) =>\n    typeof scene.visualDirection === 'string' && scene.visualDirection.trim().length > 5\n  );\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  return (script.scenes || []).every((scene) => countWords(scene.text) >= 20);\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean)\n    .join(' ');\n  const hasEmoji = /\\p{Extended_Pictographic}/u.test(spoken);\n  const hasMarkdown = /[`*_]/.test(spoken) || /\\[(.+?)\\]\\((.+?)\\)/.test(spoken);\n  const hasHashtag = /(^|\\s)#\\w+/.test(spoken);\n  return !hasEmoji && !hasMarkdown && !hasHashtag;\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return typeof script.reasoning === 'string' && script.reasoning.trim().length > 10;\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "The script opens with a bold, controversial statement that will spark debate.\nIt should immediately make viewers want to comment (agree or disagree).\n",
                "threshold": 0.8,
                "weight": 2
              },
              "pass": true,
              "score": 1,
              "reason": "The script opens with the bold statement 'TypeScript is overrated, and here's why!' which is likely to provoke a reaction and encourage viewers to share their opinions.",
              "tokensUsed": {
                "total": 625,
                "prompt": 575,
                "completion": 50,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"TypeScript might slow you down more than you think. It adds layers of complexity to your codebase, and sometimes it feels like you're fighting the language.\\\",\\\"visualDirection\\\":\\\"Developer sitting frustrated at a computer, surrounded by TypeScript error messages.\\\",\\\"mood\\\":\\\"Frustrated, skeptical\\\"},{\\\"text\\\":\\\"Sure, TypeScript catches bugs early. But isn't that what testing is for? You could spend all that time writing tests instead of types.\\\",\\\"visualDirection\\\":\\\"Cut to a developer confidently running tests, showing passing results.\\\",\\\"mood\\\":\\\"Confident, questioning\\\"},{\\\"text\\\":\\\"And let's talk about flexibility. JavaScript lets you move fast and break things. TypeScript's strict rules can actually slow down your creative process.\\\",\\\"visualDirection\\\":\\\"Developer quickly prototyping an app in JavaScript, looking satisfied.\\\",\\\"mood\\\":\\\"Inspired, energetic\\\"},{\\\"text\\\":\\\"TypeScript is great for huge teams. But if you're solo or in a small team, plain JavaScript might be all you need.\\\",\\\"visualDirection\\\":\\\"Solo developer working efficiently on a sleek, minimal setup.\\\",\\\"mood\\\":\\\"Casual, practical\\\"},{\\\"text\\\":\\\"So, is TypeScript really worth the hype for everyone? Maybe not. Think about your own needs before jumping on the bandwagon.\\\",\\\"visualDirection\\\":\\\"Developer pondering thoughtfully, with a split-screen comparison of TypeScript and JavaScript.\\\",\\\"mood\\\":\\\"Reflective, open-minded\\\"}],\\\"reasoning\\\":\\\"The script challenges the necessity of TypeScript for all developers by highlighting potential drawbacks like complexity, reduced flexibility, and suitability mainly for large teams.\\\",\\\"title\\\":\\\"Is TypeScript Overrated?\\\",\\\"hook\\\":\\\"TypeScript is overrated, and here's why!\\\",\\\"cta\\\":\\\"So, what do you think? Are you Team TypeScript or Team JavaScript?\\\",\\\"hashtags\\\":[\\\"#TypeScript\\\",\\\"#JavaScript\\\",\\\"#CodingDebate\\\",\\\"#WebDevelopment\\\"]}\\n</Output>\\n<Rubric>\\nThe script opens with a bold, controversial statement that will spark debate.\\nIt should immediately make viewers want to comment (agree or disagree).\\n\\n</Rubric>\"}]"
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "Despite being a hot take, the script provides actual reasoning and evidence.\nIt's not just rage bait; there should be substance behind the opinion.\n",
                "threshold": 0.7,
                "weight": 2
              },
              "pass": true,
              "score": 1,
              "reason": "The output provides reasoned arguments against TypeScript, discussing its complexity, flexibility issues, and appropriate team size for its use.",
              "tokensUsed": {
                "total": 618,
                "prompt": 576,
                "completion": 42,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"TypeScript might slow you down more than you think. It adds layers of complexity to your codebase, and sometimes it feels like you're fighting the language.\\\",\\\"visualDirection\\\":\\\"Developer sitting frustrated at a computer, surrounded by TypeScript error messages.\\\",\\\"mood\\\":\\\"Frustrated, skeptical\\\"},{\\\"text\\\":\\\"Sure, TypeScript catches bugs early. But isn't that what testing is for? You could spend all that time writing tests instead of types.\\\",\\\"visualDirection\\\":\\\"Cut to a developer confidently running tests, showing passing results.\\\",\\\"mood\\\":\\\"Confident, questioning\\\"},{\\\"text\\\":\\\"And let's talk about flexibility. JavaScript lets you move fast and break things. TypeScript's strict rules can actually slow down your creative process.\\\",\\\"visualDirection\\\":\\\"Developer quickly prototyping an app in JavaScript, looking satisfied.\\\",\\\"mood\\\":\\\"Inspired, energetic\\\"},{\\\"text\\\":\\\"TypeScript is great for huge teams. But if you're solo or in a small team, plain JavaScript might be all you need.\\\",\\\"visualDirection\\\":\\\"Solo developer working efficiently on a sleek, minimal setup.\\\",\\\"mood\\\":\\\"Casual, practical\\\"},{\\\"text\\\":\\\"So, is TypeScript really worth the hype for everyone? Maybe not. Think about your own needs before jumping on the bandwagon.\\\",\\\"visualDirection\\\":\\\"Developer pondering thoughtfully, with a split-screen comparison of TypeScript and JavaScript.\\\",\\\"mood\\\":\\\"Reflective, open-minded\\\"}],\\\"reasoning\\\":\\\"The script challenges the necessity of TypeScript for all developers by highlighting potential drawbacks like complexity, reduced flexibility, and suitability mainly for large teams.\\\",\\\"title\\\":\\\"Is TypeScript Overrated?\\\",\\\"hook\\\":\\\"TypeScript is overrated, and here's why!\\\",\\\"cta\\\":\\\"So, what do you think? Are you Team TypeScript or Team JavaScript?\\\",\\\"hashtags\\\":[\\\"#TypeScript\\\",\\\"#JavaScript\\\",\\\"#CodingDebate\\\",\\\"#WebDevelopment\\\"]}\\n</Output>\\n<Rubric>\\nDespite being a hot take, the script provides actual reasoning and evidence.\\nIt's not just rage bait; there should be substance behind the opinion.\\n\\n</Rubric>\"}]"
              }
            }
          ]
        },
        "id": "57fccbad-51f5-4e40-8a73-8c661f0d89bf",
        "latencyMs": 7670,
        "namedScores": {},
        "prompt": {
          "raw": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"TypeScript is overrated\"\n\nFORMAT: hot-take\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Total spoken word count must be between 90-150 words.\n- Use short sentences (<=15 words) and one idea per sentence.\n- Each scene should be 2 sentences and ~22-30 words (minimum 20 words per scene).\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n- Scene 1 must continue after the hook with NEW information (no restating or paraphrasing the hook).\n- Each scene text must be at least 20 words.\n- Double-check total word count before responding.\n\n\n\n\n\n\n\nLead with a provocative opinion, then back it up with reasoning.\n\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n- Each scene text must be at least 20 words.\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n",
          "label": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"{{ topic }}\"\n\nFORMAT: {{ archetype }}\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Total spoken word count must be between 90-150 words.\n- Use short sentences (<=15 words) and one idea per sentence.\n- Each scene should be 2 sentences and ~22-30 words (minimum 20 words per scene).\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n- Scene 1 must continue after the hook with NEW information (no restating or paraphrasing the hook).\n- Each scene text must be at least 20 words.\n- Double-check total word count before responding.\n\n{% if archetype == \"listicle\" %}\nStructure as a numbered list with a hook, clear items, and a call-to-action.\nPrefix each point with an explicit number label (e.g., \"Tip 1:\", \"2)\", \"Number 3:\").\n{% endif %}\n{% if archetype == \"versus\" %}\nPresent a balanced comparison with a clear recommendation at the end.\nThe hook should be a bold statement, not a question.\n{% endif %}\n{% if archetype == \"howto\" %}\nGive step-by-step instructions that are easy to follow.\n{% endif %}\n{% if archetype == \"myth\" %}\nStart with the myth, then reveal the reality with evidence.\nUse explicit \"Myth: X\" and \"Reality: Y\" phrasing in scene text.\n{% endif %}\n{% if archetype == \"story\" %}\nUse narrative structure: setup, conflict, resolution.\n{% endif %}\n{% if archetype == \"hot-take\" %}\nLead with a provocative opinion, then back it up with reasoning.\n{% endif %}\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n- Each scene text must be at least 20 words.\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n"
        },
        "promptId": "d06ca5ffe45d88de94b47be11ed6547ff6c739ca21958980b959177eed65db1b",
        "promptIdx": 0,
        "provider": {
          "id": "openai:gpt-4o",
          "label": ""
        },
        "response": {
          "output": "{\n  \"scenes\": [\n    {\n      \"text\": \"TypeScript might slow you down more than you think. It adds layers of complexity to your codebase, and sometimes it feels like you're fighting the language.\",\n      \"visualDirection\": \"Developer sitting frustrated at a computer, surrounded by TypeScript error messages.\",\n      \"mood\": \"Frustrated, skeptical\"\n    },\n    {\n      \"text\": \"Sure, TypeScript catches bugs early. But isn't that what testing is for? You could spend all that time writing tests instead of types.\",\n      \"visualDirection\": \"Cut to a developer confidently running tests, showing passing results.\",\n      \"mood\": \"Confident, questioning\"\n    },\n    {\n      \"text\": \"And let's talk about flexibility. JavaScript lets you move fast and break things. TypeScript's strict rules can actually slow down your creative process.\",\n      \"visualDirection\": \"Developer quickly prototyping an app in JavaScript, looking satisfied.\",\n      \"mood\": \"Inspired, energetic\"\n    },\n    {\n      \"text\": \"TypeScript is great for huge teams. But if you're solo or in a small team, plain JavaScript might be all you need.\",\n      \"visualDirection\": \"Solo developer working efficiently on a sleek, minimal setup.\",\n      \"mood\": \"Casual, practical\"\n    },\n    {\n      \"text\": \"So, is TypeScript really worth the hype for everyone? Maybe not. Think about your own needs before jumping on the bandwagon.\",\n      \"visualDirection\": \"Developer pondering thoughtfully, with a split-screen comparison of TypeScript and JavaScript.\",\n      \"mood\": \"Reflective, open-minded\"\n    }\n  ],\n  \"reasoning\": \"The script challenges the necessity of TypeScript for all developers by highlighting potential drawbacks like complexity, reduced flexibility, and suitability mainly for large teams.\",\n  \"title\": \"Is TypeScript Overrated?\",\n  \"hook\": \"TypeScript is overrated, and here's why!\",\n  \"cta\": \"So, what do you think? Are you Team TypeScript or Team JavaScript?\",\n  \"hashtags\": [\"#TypeScript\", \"#JavaScript\", \"#CodingDebate\", \"#WebDevelopment\"]\n}",
          "tokenUsage": {
            "total": 929,
            "prompt": 476,
            "completion": 453,
            "numRequests": 1,
            "completionDetails": {
              "reasoning": 0,
              "acceptedPrediction": 0,
              "rejectedPrediction": 0
            }
          },
          "cached": false,
          "latencyMs": 7670,
          "finishReason": "stop",
          "cost": 0.00572,
          "guardrails": {
            "flagged": false
          }
        },
        "score": 1,
        "success": true,
        "testCase": {
          "vars": {
            "topic": "TypeScript is overrated",
            "archetype": "hot-take"
          },
          "assert": [
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return (\n    Array.isArray(script.scenes) &&\n    script.scenes.length >= 3 &&\n    script.scenes.length <= 7\n  );\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 90 && wordCount <= 150;\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return (script.scenes || []).every((scene) =>\n    typeof scene.visualDirection === 'string' && scene.visualDirection.trim().length > 5\n  );\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  return (script.scenes || []).every((scene) => countWords(scene.text) >= 20);\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean)\n    .join(' ');\n  const hasEmoji = /\\p{Extended_Pictographic}/u.test(spoken);\n  const hasMarkdown = /[`*_]/.test(spoken) || /\\[(.+?)\\]\\((.+?)\\)/.test(spoken);\n  const hasHashtag = /(^|\\s)#\\w+/.test(spoken);\n  return !hasEmoji && !hasMarkdown && !hasHashtag;\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return typeof script.reasoning === 'string' && script.reasoning.trim().length > 10;\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "llm-rubric",
              "value": "The script opens with a bold, controversial statement that will spark debate.\nIt should immediately make viewers want to comment (agree or disagree).\n",
              "threshold": 0.8,
              "weight": 2
            },
            {
              "type": "llm-rubric",
              "value": "Despite being a hot take, the script provides actual reasoning and evidence.\nIt's not just rage bait; there should be substance behind the opinion.\n",
              "threshold": 0.7,
              "weight": 2
            }
          ],
          "options": {
            "provider": "openai:gpt-4o-mini"
          },
          "metadata": {}
        },
        "testIdx": 3,
        "vars": {
          "topic": "TypeScript is overrated",
          "archetype": "hot-take"
        },
        "metadata": {
          "_promptfooFileMetadata": {}
        },
        "failureReason": 0
      },
      {
        "cost": 0.005695,
        "gradingResult": {
          "pass": true,
          "score": 1,
          "reason": "All assertions passed",
          "namedScores": {},
          "tokensUsed": {
            "total": 1265,
            "prompt": 1154,
            "completion": 111,
            "cached": 0,
            "numRequests": 2
          },
          "componentResults": [
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return (\n    Array.isArray(script.scenes) &&\n    script.scenes.length >= 3 &&\n    script.scenes.length <= 7\n  );\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 90 && wordCount <= 150;\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return (script.scenes || []).every((scene) =>\n    typeof scene.visualDirection === 'string' && scene.visualDirection.trim().length > 5\n  );\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  return (script.scenes || []).every((scene) => countWords(scene.text) >= 20);\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean)\n    .join(' ');\n  const hasEmoji = /\\p{Extended_Pictographic}/u.test(spoken);\n  const hasMarkdown = /[`*_]/.test(spoken) || /\\[(.+?)\\]\\((.+?)\\)/.test(spoken);\n  const hasHashtag = /(^|\\s)#\\w+/.test(spoken);\n  return !hasEmoji && !hasMarkdown && !hasHashtag;\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return typeof script.reasoning === 'string' && script.reasoning.trim().length > 10;\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "The script has clear, sequential steps that are easy to follow.\nEach step should be actionable and specific.\n",
                "threshold": 0.8,
                "weight": 2
              },
              "pass": true,
              "score": 1,
              "reason": "The script exhibits a clear, sequential progression of steps for deploying a Node.js app, starting from installation to running the app, with each step being actionable and specific.",
              "tokensUsed": {
                "total": 624,
                "prompt": 574,
                "completion": 50,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"Start by installing Node.js if you haven't yet. Visit nodejs dot org, download, and follow the setup instructions. You're just a few clicks away from Node power!\\\",\\\"visualDirection\\\":\\\"Show Node.js website, download and installation steps.\\\",\\\"mood\\\":\\\"Excited and encouraging.\\\"},{\\\"text\\\":\\\"Next, create a simple Node app. Open your terminal, type npm init, and hit enter. Follow the prompts to set up your package.json file.\\\",\\\"visualDirection\\\":\\\"Screen recording of terminal commands with npm init.\\\",\\\"mood\\\":\\\"Energetic and motivating.\\\"},{\\\"text\\\":\\\"Install Express. Type npm install express in your terminal. This'll set up your server framework in seconds. You're building real stuff now!\\\",\\\"visualDirection\\\":\\\"Terminal showing npm install express command and progress.\\\",\\\"mood\\\":\\\"Empowering and upbeat.\\\"},{\\\"text\\\":\\\"Create your app file. In your project folder, make a new file called app dot js. Include a simple 'Hello World' Express server.\\\",\\\"visualDirection\\\":\\\"Show creating and editing app.js file in a code editor.\\\",\\\"mood\\\":\\\"Creative and confident.\\\"},{\\\"text\\\":\\\"Time to run your app! Type node app.js in your terminal. Open your browser, enter localhost colon three thousand, and see your app live!\\\",\\\"visualDirection\\\":\\\"Terminal running node app.js, browser showing 'Hello World'.\\\",\\\"mood\\\":\\\"Victorious and joyful.\\\"}],\\\"reasoning\\\":\\\"The script provides a clear, step-by-step guide to deploying a Node.js app quickly, making it accessible for beginners. Each step is simple and builds on the previous one.\\\",\\\"title\\\":\\\"Deploy a Node.js App in 5 Minutes\\\",\\\"hook\\\":\\\"Want to deploy a Node.js app in five minutes? Let's go!\\\",\\\"cta\\\":\\\"Try it out and deploy your app now!\\\",\\\"hashtags\\\":[\\\"#NodeJS\\\",\\\"#WebDevelopment\\\",\\\"#CodingTips\\\"]}\\n</Output>\\n<Rubric>\\nThe script has clear, sequential steps that are easy to follow.\\nEach step should be actionable and specific.\\n\\n</Rubric>\"}]"
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "The visual directions show what the viewer should be doing at each step.\nThis could include screen recordings, terminal commands, or UI interactions.\n",
                "threshold": 0.8,
                "weight": 1
              },
              "pass": true,
              "score": 1,
              "reason": "The visual directions provided in each scene mention actions such as showing the Node.js website, screen recording terminal commands, and showing the app.js file creation in a code editor, which align with the expectation of displaying what the viewer should be doing.",
              "tokensUsed": {
                "total": 641,
                "prompt": 580,
                "completion": 61,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"Start by installing Node.js if you haven't yet. Visit nodejs dot org, download, and follow the setup instructions. You're just a few clicks away from Node power!\\\",\\\"visualDirection\\\":\\\"Show Node.js website, download and installation steps.\\\",\\\"mood\\\":\\\"Excited and encouraging.\\\"},{\\\"text\\\":\\\"Next, create a simple Node app. Open your terminal, type npm init, and hit enter. Follow the prompts to set up your package.json file.\\\",\\\"visualDirection\\\":\\\"Screen recording of terminal commands with npm init.\\\",\\\"mood\\\":\\\"Energetic and motivating.\\\"},{\\\"text\\\":\\\"Install Express. Type npm install express in your terminal. This'll set up your server framework in seconds. You're building real stuff now!\\\",\\\"visualDirection\\\":\\\"Terminal showing npm install express command and progress.\\\",\\\"mood\\\":\\\"Empowering and upbeat.\\\"},{\\\"text\\\":\\\"Create your app file. In your project folder, make a new file called app dot js. Include a simple 'Hello World' Express server.\\\",\\\"visualDirection\\\":\\\"Show creating and editing app.js file in a code editor.\\\",\\\"mood\\\":\\\"Creative and confident.\\\"},{\\\"text\\\":\\\"Time to run your app! Type node app.js in your terminal. Open your browser, enter localhost colon three thousand, and see your app live!\\\",\\\"visualDirection\\\":\\\"Terminal running node app.js, browser showing 'Hello World'.\\\",\\\"mood\\\":\\\"Victorious and joyful.\\\"}],\\\"reasoning\\\":\\\"The script provides a clear, step-by-step guide to deploying a Node.js app quickly, making it accessible for beginners. Each step is simple and builds on the previous one.\\\",\\\"title\\\":\\\"Deploy a Node.js App in 5 Minutes\\\",\\\"hook\\\":\\\"Want to deploy a Node.js app in five minutes? Let's go!\\\",\\\"cta\\\":\\\"Try it out and deploy your app now!\\\",\\\"hashtags\\\":[\\\"#NodeJS\\\",\\\"#WebDevelopment\\\",\\\"#CodingTips\\\"]}\\n</Output>\\n<Rubric>\\nThe visual directions show what the viewer should be doing at each step.\\nThis could include screen recordings, terminal commands, or UI interactions.\\n\\n</Rubric>\"}]"
              }
            }
          ]
        },
        "id": "83bd00e0-e82e-4cbf-9df0-499829e88e67",
        "latencyMs": 5427,
        "namedScores": {},
        "prompt": {
          "raw": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"How to deploy a Node.js app in 5 minutes\"\n\nFORMAT: howto\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Total spoken word count must be between 90-150 words.\n- Use short sentences (<=15 words) and one idea per sentence.\n- Each scene should be 2 sentences and ~22-30 words (minimum 20 words per scene).\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n- Scene 1 must continue after the hook with NEW information (no restating or paraphrasing the hook).\n- Each scene text must be at least 20 words.\n- Double-check total word count before responding.\n\n\n\n\nGive step-by-step instructions that are easy to follow.\n\n\n\n\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n- Each scene text must be at least 20 words.\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n",
          "label": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"{{ topic }}\"\n\nFORMAT: {{ archetype }}\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Total spoken word count must be between 90-150 words.\n- Use short sentences (<=15 words) and one idea per sentence.\n- Each scene should be 2 sentences and ~22-30 words (minimum 20 words per scene).\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n- Scene 1 must continue after the hook with NEW information (no restating or paraphrasing the hook).\n- Each scene text must be at least 20 words.\n- Double-check total word count before responding.\n\n{% if archetype == \"listicle\" %}\nStructure as a numbered list with a hook, clear items, and a call-to-action.\nPrefix each point with an explicit number label (e.g., \"Tip 1:\", \"2)\", \"Number 3:\").\n{% endif %}\n{% if archetype == \"versus\" %}\nPresent a balanced comparison with a clear recommendation at the end.\nThe hook should be a bold statement, not a question.\n{% endif %}\n{% if archetype == \"howto\" %}\nGive step-by-step instructions that are easy to follow.\n{% endif %}\n{% if archetype == \"myth\" %}\nStart with the myth, then reveal the reality with evidence.\nUse explicit \"Myth: X\" and \"Reality: Y\" phrasing in scene text.\n{% endif %}\n{% if archetype == \"story\" %}\nUse narrative structure: setup, conflict, resolution.\n{% endif %}\n{% if archetype == \"hot-take\" %}\nLead with a provocative opinion, then back it up with reasoning.\n{% endif %}\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n- Each scene text must be at least 20 words.\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n"
        },
        "promptId": "d06ca5ffe45d88de94b47be11ed6547ff6c739ca21958980b959177eed65db1b",
        "promptIdx": 0,
        "provider": {
          "id": "openai:gpt-4o",
          "label": ""
        },
        "response": {
          "output": "{\n  \"scenes\": [\n    {\n      \"text\": \"Start by installing Node.js if you haven't yet. Visit nodejs dot org, download, and follow the setup instructions. You're just a few clicks away from Node power!\",\n      \"visualDirection\": \"Show Node.js website, download and installation steps.\",\n      \"mood\": \"Excited and encouraging.\"\n    },\n    {\n      \"text\": \"Next, create a simple Node app. Open your terminal, type npm init, and hit enter. Follow the prompts to set up your package.json file.\",\n      \"visualDirection\": \"Screen recording of terminal commands with npm init.\",\n      \"mood\": \"Energetic and motivating.\"\n    },\n    {\n      \"text\": \"Install Express. Type npm install express in your terminal. This'll set up your server framework in seconds. You're building real stuff now!\",\n      \"visualDirection\": \"Terminal showing npm install express command and progress.\",\n      \"mood\": \"Empowering and upbeat.\"\n    },\n    {\n      \"text\": \"Create your app file. In your project folder, make a new file called app dot js. Include a simple 'Hello World' Express server.\",\n      \"visualDirection\": \"Show creating and editing app.js file in a code editor.\",\n      \"mood\": \"Creative and confident.\"\n    },\n    {\n      \"text\": \"Time to run your app! Type node app.js in your terminal. Open your browser, enter localhost colon three thousand, and see your app live!\",\n      \"visualDirection\": \"Terminal running node app.js, browser showing 'Hello World'.\",\n      \"mood\": \"Victorious and joyful.\"\n    }\n  ],\n  \"reasoning\": \"The script provides a clear, step-by-step guide to deploying a Node.js app quickly, making it accessible for beginners. Each step is simple and builds on the previous one.\",\n  \"title\": \"Deploy a Node.js App in 5 Minutes\",\n  \"hook\": \"Want to deploy a Node.js app in five minutes? Let's go!\",\n  \"cta\": \"Try it out and deploy your app now!\",\n  \"hashtags\": [\"#NodeJS\", \"#WebDevelopment\", \"#CodingTips\"]\n}",
          "tokenUsage": {
            "total": 928,
            "prompt": 478,
            "completion": 450,
            "numRequests": 1,
            "completionDetails": {
              "reasoning": 0,
              "acceptedPrediction": 0,
              "rejectedPrediction": 0
            }
          },
          "cached": false,
          "latencyMs": 5427,
          "finishReason": "stop",
          "cost": 0.005695,
          "guardrails": {
            "flagged": false
          }
        },
        "score": 1,
        "success": true,
        "testCase": {
          "vars": {
            "topic": "How to deploy a Node.js app in 5 minutes",
            "archetype": "howto"
          },
          "assert": [
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return (\n    Array.isArray(script.scenes) &&\n    script.scenes.length >= 3 &&\n    script.scenes.length <= 7\n  );\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 90 && wordCount <= 150;\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return (script.scenes || []).every((scene) =>\n    typeof scene.visualDirection === 'string' && scene.visualDirection.trim().length > 5\n  );\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  return (script.scenes || []).every((scene) => countWords(scene.text) >= 20);\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean)\n    .join(' ');\n  const hasEmoji = /\\p{Extended_Pictographic}/u.test(spoken);\n  const hasMarkdown = /[`*_]/.test(spoken) || /\\[(.+?)\\]\\((.+?)\\)/.test(spoken);\n  const hasHashtag = /(^|\\s)#\\w+/.test(spoken);\n  return !hasEmoji && !hasMarkdown && !hasHashtag;\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return typeof script.reasoning === 'string' && script.reasoning.trim().length > 10;\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "llm-rubric",
              "value": "The script has clear, sequential steps that are easy to follow.\nEach step should be actionable and specific.\n",
              "threshold": 0.8,
              "weight": 2
            },
            {
              "type": "llm-rubric",
              "value": "The visual directions show what the viewer should be doing at each step.\nThis could include screen recordings, terminal commands, or UI interactions.\n",
              "threshold": 0.8,
              "weight": 1
            }
          ],
          "options": {
            "provider": "openai:gpt-4o-mini"
          },
          "metadata": {}
        },
        "testIdx": 4,
        "vars": {
          "topic": "How to deploy a Node.js app in 5 minutes",
          "archetype": "howto"
        },
        "metadata": {
          "_promptfooFileMetadata": {}
        },
        "failureReason": 0
      },
      {
        "cost": 0.00535,
        "error": "Custom function returned false\ntry {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  return (script.scenes || []).every((scene) => countWords(scene.text) >= 20);\n} catch { return false; }",
        "gradingResult": {
          "pass": false,
          "score": 0.9230769230769231,
          "reason": "Custom function returned false\ntry {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  return (script.scenes || []).every((scene) => countWords(scene.text) >= 20);\n} catch { return false; }",
          "namedScores": {},
          "tokensUsed": {
            "total": 1156,
            "prompt": 1066,
            "completion": 90,
            "cached": 0,
            "numRequests": 2
          },
          "componentResults": [
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return (\n    Array.isArray(script.scenes) &&\n    script.scenes.length >= 3 &&\n    script.scenes.length <= 7\n  );\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 90 && wordCount <= 150;\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return (script.scenes || []).every((scene) =>\n    typeof scene.visualDirection === 'string' && scene.visualDirection.trim().length > 5\n  );\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": false,
              "score": 0,
              "reason": "Custom function returned false\ntry {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  return (script.scenes || []).every((scene) => countWords(scene.text) >= 20);\n} catch { return false; }",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  return (script.scenes || []).every((scene) => countWords(scene.text) >= 20);\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean)\n    .join(' ');\n  const hasEmoji = /\\p{Extended_Pictographic}/u.test(spoken);\n  const hasMarkdown = /[`*_]/.test(spoken) || /\\[(.+?)\\]\\((.+?)\\)/.test(spoken);\n  const hasHashtag = /(^|\\s)#\\w+/.test(spoken);\n  return !hasEmoji && !hasMarkdown && !hasHashtag;\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }\n",
                "weight": 2
              }
            },
            {
              "pass": true,
              "score": 1,
              "reason": "Assertion passed",
              "assertion": {
                "type": "javascript",
                "value": "try {\n  const script = JSON.parse(output);\n  return typeof script.reasoning === 'string' && script.reasoning.trim().length > 10;\n} catch { return false; }\n",
                "weight": 1
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "The script clearly states the myth, then definitively debunks it.\nThe structure should be \"Myth: X / Reality: Y\" or similar.\n",
                "threshold": 0.8,
                "weight": 2
              },
              "pass": true,
              "score": 1,
              "reason": "The script utilizes the myth-versus-reality format to clearly state the myth and provide a definitive reality in response to it.",
              "tokensUsed": {
                "total": 579,
                "prompt": 537,
                "completion": 42,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"Myth: You need a computer science degree to be a developer. Let's bust this myth wide open right now.\\\",\\\"visualDirection\\\":\\\"Person pointing at a myth-busting graphic on screen.\\\",\\\"mood\\\":\\\"Intriguing\\\"},{\\\"text\\\":\\\"Reality: Many top developers are self-taught. Skills matter more than degrees in the tech world.\\\",\\\"visualDirection\\\":\\\"Switch to clips of well-known self-taught developers and their success stories.\\\",\\\"mood\\\":\\\"Empowering\\\"},{\\\"text\\\":\\\"Bootcamps and online courses offer hands-on coding experience, which many employers value highly.\\\",\\\"visualDirection\\\":\\\"Show quick clips of people coding in various environments: cafes, home offices, outdoors.\\\",\\\"mood\\\":\\\"Encouraging\\\"},{\\\"text\\\":\\\"GitHub and personal projects showcase your skills better than a piece of paper can.\\\",\\\"visualDirection\\\":\\\"Zoom in on a GitHub profile with a rich project portfolio.\\\",\\\"mood\\\":\\\"Motivational\\\"},{\\\"text\\\":\\\"Reality check: Passion, persistence, and projects can land you a developer role.\\\",\\\"visualDirection\\\":\\\"Show a montage of people celebrating their job offers.\\\",\\\"mood\\\":\\\"Uplifting\\\"}],\\\"reasoning\\\":\\\"The script uses the myth-versus-reality format to address a common misconception about the necessity of a CS degree for developers. It provides evidence of alternative paths and highlights the importance of practical skills and experience.\\\",\\\"title\\\":\\\"Do You Really Need a CS Degree to Code?\\\",\\\"hook\\\":\\\"Do you really need a degree to code?\\\",\\\"cta\\\":\\\"Think you need a degree to code? Think again. Follow for more tech myths busted.\\\",\\\"hashtags\\\":[\\\"#CodingMyths\\\",\\\"#DeveloperLife\\\",\\\"#TechCareers\\\"]}\\n</Output>\\n<Rubric>\\nThe script clearly states the myth, then definitively debunks it.\\nThe structure should be \\\"Myth: X / Reality: Y\\\" or similar.\\n\\n</Rubric>\"}]"
              }
            },
            {
              "assertion": {
                "type": "llm-rubric",
                "value": "The debunking includes evidence, examples, or statistics.\nIt's not just opinion; there should be factual backing.\n",
                "threshold": 0.7,
                "weight": 1
              },
              "pass": true,
              "score": 1,
              "reason": "The output provides examples of self-taught developers and mentions alternative paths like bootcamps, which serve as evidence against the myth of needing a CS degree.",
              "tokensUsed": {
                "total": 577,
                "prompt": 529,
                "completion": 48,
                "cached": 0,
                "numRequests": 1,
                "completionDetails": {
                  "reasoning": 0,
                  "acceptedPrediction": 0,
                  "rejectedPrediction": 0
                }
              },
              "metadata": {
                "renderedGradingPrompt": "[{\"role\":\"system\",\"content\":\"You are grading output according to a user-specified rubric. If the statement in the rubric is true, then the output passes the test. You respond with a JSON object with this structure: {reason: string, pass: boolean, score: number}\\n\\nExamples:\\n\\n<Output>Hello world</Output>\\n<Rubric>Content contains a greeting</Rubric>\\n{\\\"reason\\\": \\\"the content contains the word 'Hello'\\\", \\\"pass\\\": true, \\\"score\\\": 1.0}\\n\\n<Output>Avast ye swabs, repel the invaders!</Output>\\n<Rubric>Does not speak like a pirate</Rubric>\\n{\\\"reason\\\": \\\"'avast ye' is a common pirate term\\\", \\\"pass\\\": false, \\\"score\\\": 0.0}\"},{\"role\":\"user\",\"content\":\"<Output>\\n{\\\"scenes\\\":[{\\\"text\\\":\\\"Myth: You need a computer science degree to be a developer. Let's bust this myth wide open right now.\\\",\\\"visualDirection\\\":\\\"Person pointing at a myth-busting graphic on screen.\\\",\\\"mood\\\":\\\"Intriguing\\\"},{\\\"text\\\":\\\"Reality: Many top developers are self-taught. Skills matter more than degrees in the tech world.\\\",\\\"visualDirection\\\":\\\"Switch to clips of well-known self-taught developers and their success stories.\\\",\\\"mood\\\":\\\"Empowering\\\"},{\\\"text\\\":\\\"Bootcamps and online courses offer hands-on coding experience, which many employers value highly.\\\",\\\"visualDirection\\\":\\\"Show quick clips of people coding in various environments: cafes, home offices, outdoors.\\\",\\\"mood\\\":\\\"Encouraging\\\"},{\\\"text\\\":\\\"GitHub and personal projects showcase your skills better than a piece of paper can.\\\",\\\"visualDirection\\\":\\\"Zoom in on a GitHub profile with a rich project portfolio.\\\",\\\"mood\\\":\\\"Motivational\\\"},{\\\"text\\\":\\\"Reality check: Passion, persistence, and projects can land you a developer role.\\\",\\\"visualDirection\\\":\\\"Show a montage of people celebrating their job offers.\\\",\\\"mood\\\":\\\"Uplifting\\\"}],\\\"reasoning\\\":\\\"The script uses the myth-versus-reality format to address a common misconception about the necessity of a CS degree for developers. It provides evidence of alternative paths and highlights the importance of practical skills and experience.\\\",\\\"title\\\":\\\"Do You Really Need a CS Degree to Code?\\\",\\\"hook\\\":\\\"Do you really need a degree to code?\\\",\\\"cta\\\":\\\"Think you need a degree to code? Think again. Follow for more tech myths busted.\\\",\\\"hashtags\\\":[\\\"#CodingMyths\\\",\\\"#DeveloperLife\\\",\\\"#TechCareers\\\"]}\\n</Output>\\n<Rubric>\\nThe debunking includes evidence, examples, or statistics.\\nIt's not just opinion; there should be factual backing.\\n\\n</Rubric>\"}]"
              }
            }
          ]
        },
        "id": "c65fe102-96b4-4c30-b9c7-6272357bd88e",
        "latencyMs": 7701,
        "namedScores": {},
        "prompt": {
          "raw": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"You need a CS degree to be a developer\"\n\nFORMAT: myth\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Total spoken word count must be between 90-150 words.\n- Use short sentences (<=15 words) and one idea per sentence.\n- Each scene should be 2 sentences and ~22-30 words (minimum 20 words per scene).\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n- Scene 1 must continue after the hook with NEW information (no restating or paraphrasing the hook).\n- Each scene text must be at least 20 words.\n- Double-check total word count before responding.\n\n\n\n\n\nStart with the myth, then reveal the reality with evidence.\nUse explicit \"Myth: X\" and \"Reality: Y\" phrasing in scene text.\n\n\n\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n- Each scene text must be at least 20 words.\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n",
          "label": "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"{{ topic }}\"\n\nFORMAT: {{ archetype }}\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Total spoken word count must be between 90-150 words.\n- Use short sentences (<=15 words) and one idea per sentence.\n- Each scene should be 2 sentences and ~22-30 words (minimum 20 words per scene).\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n- Scene 1 must continue after the hook with NEW information (no restating or paraphrasing the hook).\n- Each scene text must be at least 20 words.\n- Double-check total word count before responding.\n\n{% if archetype == \"listicle\" %}\nStructure as a numbered list with a hook, clear items, and a call-to-action.\nPrefix each point with an explicit number label (e.g., \"Tip 1:\", \"2)\", \"Number 3:\").\n{% endif %}\n{% if archetype == \"versus\" %}\nPresent a balanced comparison with a clear recommendation at the end.\nThe hook should be a bold statement, not a question.\n{% endif %}\n{% if archetype == \"howto\" %}\nGive step-by-step instructions that are easy to follow.\n{% endif %}\n{% if archetype == \"myth\" %}\nStart with the myth, then reveal the reality with evidence.\nUse explicit \"Myth: X\" and \"Reality: Y\" phrasing in scene text.\n{% endif %}\n{% if archetype == \"story\" %}\nUse narrative structure: setup, conflict, resolution.\n{% endif %}\n{% if archetype == \"hot-take\" %}\nLead with a provocative opinion, then back it up with reasoning.\n{% endif %}\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n- Each scene text must be at least 20 words.\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n"
        },
        "promptId": "d06ca5ffe45d88de94b47be11ed6547ff6c739ca21958980b959177eed65db1b",
        "promptIdx": 0,
        "provider": {
          "id": "openai:gpt-4o",
          "label": ""
        },
        "response": {
          "output": "{\n  \"scenes\": [\n    {\n      \"text\": \"Myth: You need a computer science degree to be a developer. Let's bust this myth wide open right now.\",\n      \"visualDirection\": \"Person pointing at a myth-busting graphic on screen.\",\n      \"mood\": \"Intriguing\"\n    },\n    {\n      \"text\": \"Reality: Many top developers are self-taught. Skills matter more than degrees in the tech world.\",\n      \"visualDirection\": \"Switch to clips of well-known self-taught developers and their success stories.\",\n      \"mood\": \"Empowering\"\n    },\n    {\n      \"text\": \"Bootcamps and online courses offer hands-on coding experience, which many employers value highly.\",\n      \"visualDirection\": \"Show quick clips of people coding in various environments: cafes, home offices, outdoors.\",\n      \"mood\": \"Encouraging\"\n    },\n    {\n      \"text\": \"GitHub and personal projects showcase your skills better than a piece of paper can.\",\n      \"visualDirection\": \"Zoom in on a GitHub profile with a rich project portfolio.\",\n      \"mood\": \"Motivational\"\n    },\n    {\n      \"text\": \"Reality check: Passion, persistence, and projects can land you a developer role.\",\n      \"visualDirection\": \"Show a montage of people celebrating their job offers.\",\n      \"mood\": \"Uplifting\"\n    }\n  ],\n  \"reasoning\": \"The script uses the myth-versus-reality format to address a common misconception about the necessity of a CS degree for developers. It provides evidence of alternative paths and highlights the importance of practical skills and experience.\",\n  \"title\": \"Do You Really Need a CS Degree to Code?\",\n  \"hook\": \"Do you really need a degree to code?\",\n  \"cta\": \"Think you need a degree to code? Think again. Follow for more tech myths busted.\",\n  \"hashtags\": [\"#CodingMyths\", \"#DeveloperLife\", \"#TechCareers\"]\n}",
          "tokenUsage": {
            "total": 907,
            "prompt": 496,
            "completion": 411,
            "numRequests": 1,
            "completionDetails": {
              "reasoning": 0,
              "acceptedPrediction": 0,
              "rejectedPrediction": 0
            }
          },
          "cached": false,
          "latencyMs": 7701,
          "finishReason": "stop",
          "cost": 0.00535,
          "guardrails": {
            "flagged": false
          }
        },
        "score": 0.9230769230769231,
        "success": false,
        "testCase": {
          "vars": {
            "topic": "You need a CS degree to be a developer",
            "archetype": "myth"
          },
          "assert": [
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return (\n    Array.isArray(script.scenes) &&\n    script.scenes.length >= 3 &&\n    script.scenes.length <= 7\n  );\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 90 && wordCount <= 150;\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return (script.scenes || []).every((scene) =>\n    typeof scene.visualDirection === 'string' && scene.visualDirection.trim().length > 5\n  );\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  return (script.scenes || []).every((scene) => countWords(scene.text) >= 20);\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean)\n    .join(' ');\n  const hasEmoji = /\\p{Extended_Pictographic}/u.test(spoken);\n  const hasMarkdown = /[`*_]/.test(spoken) || /\\[(.+?)\\]\\((.+?)\\)/.test(spoken);\n  const hasHashtag = /(^|\\s)#\\w+/.test(spoken);\n  return !hasEmoji && !hasMarkdown && !hasHashtag;\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }\n",
              "weight": 2
            },
            {
              "type": "javascript",
              "value": "try {\n  const script = JSON.parse(output);\n  return typeof script.reasoning === 'string' && script.reasoning.trim().length > 10;\n} catch { return false; }\n",
              "weight": 1
            },
            {
              "type": "llm-rubric",
              "value": "The script clearly states the myth, then definitively debunks it.\nThe structure should be \"Myth: X / Reality: Y\" or similar.\n",
              "threshold": 0.8,
              "weight": 2
            },
            {
              "type": "llm-rubric",
              "value": "The debunking includes evidence, examples, or statistics.\nIt's not just opinion; there should be factual backing.\n",
              "threshold": 0.7,
              "weight": 1
            }
          ],
          "options": {
            "provider": "openai:gpt-4o-mini"
          },
          "metadata": {}
        },
        "testIdx": 5,
        "vars": {
          "topic": "You need a CS degree to be a developer",
          "archetype": "myth"
        },
        "metadata": {
          "_promptfooFileMetadata": {}
        },
        "failureReason": 1
      }
    ],
    "stats": {
      "successes": 2,
      "failures": 4,
      "errors": 0,
      "tokenUsage": {
        "prompt": 2919,
        "completion": 2632,
        "cached": 0,
        "total": 5551,
        "numRequests": 6,
        "completionDetails": {
          "reasoning": 0,
          "acceptedPrediction": 0,
          "rejectedPrediction": 0
        },
        "assertions": {
          "total": 9316,
          "prompt": 8538,
          "completion": 778,
          "cached": 0,
          "numRequests": 0,
          "completionDetails": {
            "reasoning": 0,
            "acceptedPrediction": 0,
            "rejectedPrediction": 0
          }
        }
      },
      "durationMs": 61845
    }
  },
  "config": {
    "tags": {},
    "description": "content-machine script generation quality evaluation",
    "prompts": [
      "You are an expert short-form video scriptwriter. You write engaging scripts for TikTok, Reels, and YouTube Shorts.\n\nCreate a short-form video script about: \"{{ topic }}\"\n\nFORMAT: {{ archetype }}\n\nREQUIREMENTS:\n- Start with a compelling hook that creates curiosity (first 2-3 seconds).\n- 3-7 scenes, each with spoken text, visual direction, and mood.\n- End with a concise call-to-action.\n- Use conversational, TikTok-style language.\n\nTTS WRITING RULES:\n- Write for spoken delivery at 120-180 WPM.\n- Target length: ~110-140 words (~45 seconds).\n- Total spoken word count must be between 90-150 words.\n- Use short sentences (<=15 words) and one idea per sentence.\n- Each scene should be 2 sentences and ~22-30 words (minimum 20 words per scene).\n- Use contractions and second person (\"you\", \"you'll\").\n- Use punctuation for timing (commas = micro-pause, periods = full beat).\n- Normalize text for speech: expand numbers, acronyms, URLs, emails, file paths, and units.\n- Avoid openers like \"In this video\" or \"Today we're going to\".\n- Hook must be a single sentence and must not be repeated in scene 1.\n- Scene 1 must continue after the hook with NEW information (no restating or paraphrasing the hook).\n- Each scene text must be at least 20 words.\n- Double-check total word count before responding.\n\n{% if archetype == \"listicle\" %}\nStructure as a numbered list with a hook, clear items, and a call-to-action.\nPrefix each point with an explicit number label (e.g., \"Tip 1:\", \"2)\", \"Number 3:\").\n{% endif %}\n{% if archetype == \"versus\" %}\nPresent a balanced comparison with a clear recommendation at the end.\nThe hook should be a bold statement, not a question.\n{% endif %}\n{% if archetype == \"howto\" %}\nGive step-by-step instructions that are easy to follow.\n{% endif %}\n{% if archetype == \"myth\" %}\nStart with the myth, then reveal the reality with evidence.\nUse explicit \"Myth: X\" and \"Reality: Y\" phrasing in scene text.\n{% endif %}\n{% if archetype == \"story\" %}\nUse narrative structure: setup, conflict, resolution.\n{% endif %}\n{% if archetype == \"hot-take\" %}\nLead with a provocative opinion, then back it up with reasoning.\n{% endif %}\n\nOUTPUT RULES:\n- Respond with JSON only. No markdown or code fences.\n- Spoken text fields (hook, scenes[].text, cta) must be plain text: no emojis, no markdown, no hashtags.\n- Hashtags only go in the hashtags array.\n- Each scene text must be at least 20 words.\n\nOutput as JSON:\n{\n  \"scenes\": [\n    {\"text\": \"...\", \"visualDirection\": \"...\", \"mood\": \"...\"}\n  ],\n  \"reasoning\": \"...\",\n  \"title\": \"...\",\n  \"hook\": \"...\",\n  \"cta\": \"...\",\n  \"hashtags\": [\"#tag1\", \"#tag2\"]\n}\n"
    ],
    "providers": [
      {
        "id": "openai:gpt-4o",
        "config": {
          "temperature": 0.7,
          "response_format": {
            "type": "json_object"
          }
        }
      }
    ],
    "tests": [
      {
        "vars": {
          "topic": "5 JavaScript tips every developer should know",
          "archetype": "listicle"
        },
        "assert": [
          {
            "type": "llm-rubric",
            "value": "The script opens with an attention-grabbing hook that would stop a TikTok user from scrolling.\nThe first sentence should be surprising, controversial, or promise immediate value.\nScore 0 if it's a generic introduction like \"In this video...\" or \"Today we'll cover...\".\n",
            "threshold": 0.7,
            "weight": 2
          },
          {
            "type": "llm-rubric",
            "value": "The language is casual, conversational, and suitable for TikTok/Reels/Shorts.\nNo corporate jargon, no formal academic language, no \"as a developer\" phrases.\nShould sound like a friend giving advice, not a textbook.\n",
            "threshold": 0.8,
            "weight": 1
          },
          {
            "type": "llm-rubric",
            "value": "Each scene has a specific, filmable visual description.\nVisual directions should describe what the viewer will SEE on screen.\nAvoid abstract concepts that cannot be filmed (like \"efficiency\" or \"code quality\").\n",
            "threshold": 0.8,
            "weight": 1
          },
          {
            "type": "llm-rubric",
            "value": "For a listicle archetype, the script should have a clear numbered structure.\nEach tip should be distinct and actionable.\nThe list should feel complete, not like it was cut off.\n",
            "threshold": 0.8,
            "weight": 1
          }
        ]
      },
      {
        "vars": {
          "topic": "Redis vs PostgreSQL for caching",
          "archetype": "versus"
        },
        "assert": [
          {
            "type": "llm-rubric",
            "value": "The script opens with an attention-grabbing hook.\nFor a versus video, this might be a provocative statement like \"You're using the wrong database\"\nor a relatable problem statement.\n",
            "threshold": 0.7,
            "weight": 2
          },
          {
            "type": "llm-rubric",
            "value": "For a versus archetype, the script should clearly compare both options.\nIt should present pros and cons of each, not just favor one.\nThe comparison should be fair and technically accurate.\n",
            "threshold": 0.8,
            "weight": 2
          },
          {
            "type": "llm-rubric",
            "value": "The script provides a clear recommendation or decision framework at the end.\nViewers should know when to use each option.\n",
            "threshold": 0.7,
            "weight": 1
          }
        ]
      },
      {
        "vars": {
          "topic": "How I learned React in 2 weeks",
          "archetype": "story"
        },
        "assert": [
          {
            "type": "llm-rubric",
            "value": "The script has a narrative arc: setup, challenge, resolution.\nIt should feel like a personal story, not a tutorial.\n",
            "threshold": 0.8,
            "weight": 2
          },
          {
            "type": "llm-rubric",
            "value": "The language uses first-person perspective and includes emotional elements.\nThe viewer should feel connected to the storyteller.\n",
            "threshold": 0.7,
            "weight": 1
          }
        ]
      },
      {
        "vars": {
          "topic": "TypeScript is overrated",
          "archetype": "hot-take"
        },
        "assert": [
          {
            "type": "llm-rubric",
            "value": "The script opens with a bold, controversial statement that will spark debate.\nIt should immediately make viewers want to comment (agree or disagree).\n",
            "threshold": 0.8,
            "weight": 2
          },
          {
            "type": "llm-rubric",
            "value": "Despite being a hot take, the script provides actual reasoning and evidence.\nIt's not just rage bait; there should be substance behind the opinion.\n",
            "threshold": 0.7,
            "weight": 2
          }
        ]
      },
      {
        "vars": {
          "topic": "How to deploy a Node.js app in 5 minutes",
          "archetype": "howto"
        },
        "assert": [
          {
            "type": "llm-rubric",
            "value": "The script has clear, sequential steps that are easy to follow.\nEach step should be actionable and specific.\n",
            "threshold": 0.8,
            "weight": 2
          },
          {
            "type": "llm-rubric",
            "value": "The visual directions show what the viewer should be doing at each step.\nThis could include screen recordings, terminal commands, or UI interactions.\n",
            "threshold": 0.8,
            "weight": 1
          }
        ]
      },
      {
        "vars": {
          "topic": "You need a CS degree to be a developer",
          "archetype": "myth"
        },
        "assert": [
          {
            "type": "llm-rubric",
            "value": "The script clearly states the myth, then definitively debunks it.\nThe structure should be \"Myth: X / Reality: Y\" or similar.\n",
            "threshold": 0.8,
            "weight": 2
          },
          {
            "type": "llm-rubric",
            "value": "The debunking includes evidence, examples, or statistics.\nIt's not just opinion; there should be factual backing.\n",
            "threshold": 0.7,
            "weight": 1
          }
        ]
      }
    ],
    "scenarios": [],
    "env": {},
    "defaultTest": {
      "options": {
        "provider": "openai:gpt-4o-mini"
      },
      "assert": [
        {
          "type": "javascript",
          "value": "try {\n  const script = JSON.parse(output);\n  return (\n    Array.isArray(script.scenes) &&\n    script.scenes.length >= 3 &&\n    script.scenes.length <= 7\n  );\n} catch { return false; }\n",
          "weight": 2
        },
        {
          "type": "javascript",
          "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean);\n  const wordCount = spoken.reduce((acc, text) => acc + countWords(text), 0);\n  return wordCount >= 90 && wordCount <= 150;\n} catch { return false; }\n",
          "weight": 1
        },
        {
          "type": "javascript",
          "value": "try {\n  const script = JSON.parse(output);\n  return (script.scenes || []).every((scene) =>\n    typeof scene.visualDirection === 'string' && scene.visualDirection.trim().length > 5\n  );\n} catch { return false; }\n",
          "weight": 1
        },
        {
          "type": "javascript",
          "value": "try {\n  const script = JSON.parse(output);\n  const countWords = (text) =>\n    text ? text.trim().split(/\\s+/).filter(Boolean).length : 0;\n  return (script.scenes || []).every((scene) => countWords(scene.text) >= 20);\n} catch { return false; }\n",
          "weight": 1
        },
        {
          "type": "javascript",
          "value": "try {\n  const script = JSON.parse(output);\n  const spoken = [script.hook, ...(script.scenes || []).map((s) => s.text), script.cta]\n    .filter(Boolean)\n    .join(' ');\n  const hasEmoji = /\\p{Extended_Pictographic}/u.test(spoken);\n  const hasMarkdown = /[`*_]/.test(spoken) || /\\[(.+?)\\]\\((.+?)\\)/.test(spoken);\n  const hasHashtag = /(^|\\s)#\\w+/.test(spoken);\n  return !hasEmoji && !hasMarkdown && !hasHashtag;\n} catch { return false; }\n",
          "weight": 2
        },
        {
          "type": "javascript",
          "value": "try {\n  const script = JSON.parse(output);\n  const normalize = (text) =>\n    (text || '')\n      .toLowerCase()\n      .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  const hook = normalize(script.hook);\n  const scene1 = normalize(script.scenes?.[0]?.text);\n  if (!hook || !scene1) return true;\n  if (scene1.startsWith(hook) || scene1.includes(hook)) return false;\n  const hookWords = hook.split(' ');\n  const sceneWords = scene1.split(' ');\n  if (hookWords.length >= 4 && sceneWords.length >= 4) {\n    const prefixLen = Math.min(6, hookWords.length, sceneWords.length);\n    const hookPrefix = hookWords.slice(0, prefixLen).join(' ');\n    const scenePrefix = sceneWords.slice(0, prefixLen).join(' ');\n    if (hookPrefix === scenePrefix) return false;\n  }\n  return true;\n} catch { return false; }\n",
          "weight": 2
        },
        {
          "type": "javascript",
          "value": "try {\n  const script = JSON.parse(output);\n  return typeof script.reasoning === 'string' && script.reasoning.trim().length > 10;\n} catch { return false; }\n",
          "weight": 1
        }
      ],
      "vars": {},
      "metadata": {}
    },
    "outputPath": [],
    "extensions": [],
    "metadata": {},
    "evaluateOptions": {}
  },
  "shareableUrl": null,
  "metadata": {
    "promptfooVersion": "0.120.11",
    "nodeVersion": "v22.16.0",
    "platform": "win32",
    "arch": "x64",
    "exportedAt": "2026-01-10T09:13:57.365Z",
    "evaluationCreatedAt": "2026-01-10T09:12:36.668Z"
  }
}